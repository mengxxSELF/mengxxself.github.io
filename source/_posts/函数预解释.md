---
title: 函数预解释
date: 2017-09-09 18:59:46
categories: javascript基础
tags: [笔记迁移, 预解释]
---

> 笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加

<!-- More -->

1 预解释 var 和 function

2 函数操作过程，四步。

3 奇怪的预解释

### js中的预解释

#### 什么是预解释

js中，在代码执行前，带var 和function关键字是需要预解释的。

在当前作用域下，在JS代码执行之前，浏览器会对带var和带function的，进行提前声明或定义；

* var 和 function的预解释不同

var 声明变量的时候，只是发生了声明，而不会发生定义，即赋值

function关键字的预解释，声明和定义，在整个代码执行前，就已经将函数名存入内存并且给这个函数名进行了赋值。即将函数空间地址赋值给函数名，


#### 函数的四个步骤

1 形成私有作用域

2 形参赋值

3 变量预解释

4 代码从上到下执行

#### 预解释是在私有作用域的

##### 私有作用域

函数运行时会形成一个自己的私有作用域，预解释是在函数私有作用域进行的。

作用域链：当函数被调用的时候，会形成一个私有作用域，

我们看该私有作用域下，是否有私有变量A：

1）如果有私有变量A：那么该作用域中的A，都是私有变量，跟外界没有任何关系
2）如果没有私有变量A：到上级作用域进行查找，如果没有，继续往上找，找到window全局作用域还没有的话，报错；

在私有作用域内有变量a，则与外界作用域无关

如果没有私有变量a,则到上级作用域进行查找

##### 私有变量【两种】

1 形参 2 带var的

##### 堆内存和栈内存

1 栈内存提供了代码的运行环境  里面保存基本数据类型的变量

运行环境： 包括私有作用域和全局作用域

2 堆内存保存引用数据类型的数据，其中对象以键值对形式保存，函数以字符串形式保存

##### 关于带var 的和不带var 的

如果是全局变量，无论是带不带var，都属于全局window

而带var的会进行预解释，不带var的则不进行预解释

##### 内存释放

* 堆内存释放

```js
var a =['hi'];

a=null; // 内存释放
```

* 栈内存释放

栈内存，是形成js代码的执行环境，也就是私有作用域和全局作用域。所以需要进行作用域的销毁。

全局作用域的产生是伴随浏览器而形成，所以当关闭浏览器，全局作用域自然销毁。

私有作用域一般情况下，当函数执行完毕就会被js的垃圾回收机制自动销毁。

特殊情况有两种分为，1 不销毁 2 暂时不销毁

不销毁状态： 函数内部有东西被外部变量占用

暂时不销毁：一般是内层函数执行完毕先销毁内层之后外层函数进行销毁

### 奇怪的预解释

3.1 对于var在左侧的，只进行变量声明

3.2 已经声明过的，不会重复声明。但是可以进行赋值操作。

3.3 预解释阶段，函数优先级高于var 变量

3.4 自执行函数，不会进行预解释。只有执行到的时候，就是开始那个函数的四步操作

3.5 条件判断语句中，无论条件是否成立，都会进行预解释

3.6 return后面的语句不会进行预解释，但是return下面的，会进行预解释

##### Other

* 上级作用域只跟函数在哪里开辟内存空间有关，与在哪里执行无关

*  练习

6.1

```javascript
var n=9;
function fn(){
    alert(n)
    var n=9;
}
fn()
```

上面的结果输出值为 undefined。函数运行分析

1  函数运行时候，先解释关键字var和function的变量，方法中有var  n=9; 所以会先对n进行定义，但是不进行赋值操作。这个过程是函数预解释。

2 函数预解释完毕，开始按代码顺序执行函数，执行到alert(n).此时变量n由于函数的预解释作用，已经进行了变量声明，但未赋值。所以此时输出为undefined

3 继续执行代码 var n=9; 此时完成变量赋值。

6.2

```javascript
var a=[23,48,98,666];
 //1.私有作用域 2.形参赋值 3.预解释 4.代码从上到下的执行
 function fn(a){
     a[0]=123;//【123,48,98,666】
     console.log(a)
     a=[];
     a[a.length]=456;
     console.log(a);//[456]
 }
 fn(a);
console.log(a);
```

6.3

```javascript
function fn(){console.log('fn')}
function fn2(){
    console.log(fn)
    fn = 2;
    return ;
    function fn(){console.log('i am inner')}
}
fn2()
```

当执行fn2时候，会输出

```javascript
function fn(){console.log('i am inner')}
```

函数解释：

当fn2执行时，在函数内部形成作用域，作用域内发生了变量预解释。function关键字的预解释不但有声明，而且有定义，所以可以输出函数内部定义的fn，而不是全局变量中的fn

### es6 

let const 已经不存在预解释了