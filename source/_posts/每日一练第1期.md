---
title: 每日一练第一期
date: 2018-07-31 19:44:16
categories: 练习
tags: 练习
---

![Test](https://user-gold-cdn.xitu.io/2018/8/30/1658a9d289c1e11b?w=1210&h=508&f=png&s=31924)

> 08-03 -- flex 

<!--more-->

## Q: flex 布局和传统布局的不同

传统布局，基于盒模型，依赖 display属性 、position属性 、float属性，而FLEX用来为盒状模型提供最大的灵活性,不强制要求子元素的大小,任何一个容器都可以指定为 Flex 布局,可以简便、完整、响应式地实现各种页面布局。


## Q: 如何比较两个颜色的差值

### 个人思路

利用第三方插件 nodejs-color-model 将格式为十六进制需要转化为rgba格式，然后R G B 三个颜色通道的数值各自做减法

* 第三方库直接计算差值

nodejs-color-difference

### answer

首先将颜色拆分成r/g/b三个值，如果是字符串的颜色如#aabbff或者rgb(255,128,100)可以用正则表达式取出对应的r/g/b值。对于16进制字符串，可以使用parseInt('0xaa')转10进制整数。

然后对于两个颜色，可以使用距离

```javascript
Math.sqrt( (r1-r2) *(r1-r2) +(g1-g2)*(g1-g2)+(b1-b2)*(b1-b2) )
```
进行比较， 距离近则相似。 当然可以用

```javascript
Math.hypot( r1-r2, g1-t2, b1-b2)
```

来简化上述运算

```javascript
Math.hypot() // 函数返回它的所有参数的平方和的平方根
```

## Q: 单页面应用

一个单页面应用，有6张页面，F、E、A、B、C、D。 页面ABCD构成了一个冗长的用户验证过程。目前A、B、C对应用户验证过程的第1步，第2步，第3步。 页面F是首页，E是某张业务相关页面。用户到达页面E后，系统发现用户没有认证，触发验证流程，到达页面A，然后开始A->B->C->D流程。 页面D是验证结果页面（验证成功页面）。 请问，如果到达页面D后，如何让用户点击返回可以返回页面F，而忽略中间流程（注：用户可能根本没有到达过F，比如微信分享直接进入了E


补充下： 场景是上述场景，最好能做到到达页面D后，浏览器自然返回是F，再按返回，单页面系统退出；

另外请思考下各个流程如何实现流畅切换，不会有中间闪烁的页面

### 个人思路

这种单页面应用在react项目中非常常见也很容易处理，直接变更页面哈希值就可以实现页面回退并且用户体验非常好。

如果不是框架的话，又不确定刘浏览器中是否有首页历史记录，那只想到了页面重新刷新了。

而且两种方式都需要注意的是，在返回到首页的时候，已经完成了用户登录行为，所以要保存用户状态，可以考虑jwt来处理鉴权


## Q: 算法

一个无序正负项 数组，

```
[3, -6, 123, -945, -231, 112]
```

找出其中的最大的连续子序列

有如下乱序数组 A1, A2, A3, A4,........An, 求 i, j (1<= i <= j<= n), 使得Ai +  .... + Aj 和最大, 输出i j

### answer

1）最简单也最暴力的解法：首先列出 所有的子序列，然后找出其中和最大的 即可；
实现思路：一个 记录当前最大值的变量maxSum；一个 子序列开始和结束的游标 变量；一个 当前子序列的和 的暂存变量，我们称之为 currentSum 或者 tmpSum（下文中 使用currentSum）
找到所有的 子序列 我们可以通过两层循环的方式来解决
第一层循环 i 从 0~ length-1;
第二层循环 j 从 i ~ length - 1;
这样的循环里 就可以找到所有的子序列了
下一步 我们是要计算出所有子序列的和
最简单的办法 就是 第三层循环从 i ~ j 累加求出和 然后求出来的每个和  和 maxSum 去比较，如果比maxSum 大 就替换

伪代码：

```
maxSum = maxSum < currentSum ? currentSum : maxSum;
```

三层循环结束后 maxSum就是我们要 求的解
return maxSum即可
这个算法的时间复杂度是O(n^3);

2）简化解法：我们在第二层循环中，我们已经知道 当前的 i/j之前的方法是在第三层的循环中 计算 i ~ j 的和
现在 我们在第二层中 在进入第二层之前 我们重置一下currentSum
第一次循环 是 i ~ i 当前我们就把 i 的值 记录到 currentSum去跟 maxSum 对比 然后 maxSum = maxSum < currentSum ? currentSum : maxSum;
第二次循环 是 i ~ i + 1 我们就把 当前的 i+1 累加到currentSum 这时候的 currentSum就是 i ~ i+1 的值，再去跟maxSum去比 然后 maxSum = maxSum < currentSum ? currentSum : maxSum;
以此类推
第二层的循环中 就可以 计算出 以当前 i 开头的子序列中 最大的子序列是多少
现在我们看回 到 第一层循环 i 的取值 是从 0 ~ length-1 那么我们是不是 可以找到 i 从 0 ~ length-1 所有的子序列中和最大的

伪代码思路：

```
第一层 i (0 ~ length-1)
  currentSum 清零
    第二层 j(i ~ length-1)
        currentSum 累加
        maxSum = maxSum < currentSum ? currentSum : maxSum;
return maxSum;
```

算法的时间复杂度是 O(n^2)

3）demo数组：[-2, 1, -3, 4, -1, 2 , 1, -5, 4]

首先 我们可以简单的简化一下 这个数组把相邻的同 正负的数字合起来，因为同符号的连续数 一定会同时存在在最大子序列里
比如 [-1, -2, -3, 1, 2, 13] 那跟 [-6, 16] 是没有区别的

```
[-2, 1, -3, 4, -1, 2, 1, -5, 4] ==> [-2, 1, -3, 4, -1, 3, -5, 4]
```

然后 我们从头开始看 -2 这是第一个元素  那么 我们认为 当前的 最大子序列和 就是 -2
然后 发现了一个正数 1 那我们可以确定 -2 一定不包含在 我们的最大子序列中
也就是说 数组开头 如果是负数 可以忽略过去

现在 我们的数组 变成了 [1, -3, 4, -1, 3, -5, 4] 同理 结尾的如果是 负数 也不需要考虑

现在我们的数组 变成了 [1, -3, 4, -1, 3, -5, 4]

我们继续，现在 第一个元素是 1 最大和 是1 然后下一个数是 -3
那么 -3 对 1 这个数 起到了阻断作用 也就是说 -3 把 前边所有正数 积累的能量都磨平了 甚至还变成了一个负数 那么 -3 我们称之为 一个阻断

当前的 最大和 还是 1 现在 我们到了 4 那么现在的最大值 就是4
我们继续向下看

下个数字是 -1 之前最大的和是 4 加起来之后是 3 影响并不大 我们继续带着他 向后看

下一个 是个正数 3 也就是 4 -1 3 这样的情况

我们是不是可以认为 这个 -1 虽然降低了 和 但是 他连接了左右的正数 让我们当前的最大值 变成了 6 更新最大值 继续看

下一个是-5 同理 之前的 6+ -5 和 还是1 也没有阻断 我们去看看 后边 有没有一个大数 拯救我 后边 一个数 是 4
加上 我们刚才记录的 1 和是5 最后还是没有挑战成功 所以 最大的和 还是之前的 6

公式：

nums是我们的源数组 nums[i] 就是我们的当前元素 currentMax[i] 记录 我们以 i 结尾的子序列里 最大的一个子序列 那么

```
currentMax[i] = max(currentMax[i - 1] + nums[i], nums[i])

```

这个公式被称之为 状态转移公式 我们的这种解法 称之为 动态规划解法 简称：PD

然后我们去遍历 currentMax 这个数组 里边的最大值 就是我们要找的 最大值

```
var maxSubArray = function(nums) {
    // 初始化源数组，初始化An为结束的最大值
    let A = nums;
    let dp = [];
    let maxSum = A[0];
    dp[0] = A[0];
    for(let i = 1; i < A.length; i++) {
        //状态转移公式
        dp[i] = max(A[i], dp[i-1] + A[i])
        maxSum = dp[i] > maxSum ? dp[i] : maxSum;
    }
    return maxSum;
}

function max(a, b) {
    return a > b ? a : b;
}
```

### 文章导读

* [一道递归算法题](http://blog.cgsdream.org/2015/11/11/recursion-algorithm-analysis/)

## Q: 如何处理函数节流与防抖

函数节流： 指定时间间隔触发一次任务

函数防抖： 多次任务触发，但是只有任务触发的间隔大于某一个时间段才去执行此任务

### 个人思路

处理节流： 全局变量flag 当符合条件变更flag 值为TRUE 开始执行任务 任务执行完毕 则flag 为false

并且在下次任务过来的时候 去判断flag  如果flag 为TRUE了 则return掉 不去执行之后的逻辑

处理防抖：全局时间点time 当第一次任务
