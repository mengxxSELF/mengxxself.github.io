---
title: 缓存
date: 2017-11-01 19:02:22
categories: javascript
tags: [优化, 缓存]
---



现在的大型网站，随便一个页面都是一两百个请求，每天 pv 都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。  缓存和重用以前获取的资源的是优化网页性能很重要的一个方面。

<!--more-->

## 缓存的优缺点

### 优点

* 减少网络延迟，加快页面打开速度

缓存比源服务器离客户端更近，因此，从缓存请求内容比从源服务器所用时间更少，缓存的使用能够明显加快页面打开速度，达到更好的体验。

* 降低服务器的压力

给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。

* 减少网络带宽损耗

无论对于网站运营者或者用户，带宽都代表着金钱,当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。


### 缺点

* 缓存没有清理机制

这些缓存的文件会永久性地保存在机器上，在特定的时间内，这些文件可能是帮了你大忙，但是时间一长，我们已经不再需要浏览之前的这些网页，这些文件就成了无效或者无用的文件，它们存储在用户硬盘中只会占用空间而没有任何用处，如果要缓存的东西非常多，那就会撑暴整个硬盘空间。

* 给开发带来的困扰

明明修改了样式文件、图片、视频或脚本，刷新页面或部署到站点之后看不到修改之后的效果。

所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。

## 缓存分类

Web应用领域，Web缓存大致可以分为以下几种类型：

### 数据库数据缓存

  Web应用，特别是社交网络服务类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached,redis等。  

### 服务器端缓存

#### 代理服务器缓存

 代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid,Nginx,Apache等。

 ![agent Server](/img/cache/agentServer.png)

#### CDN缓存

CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，浏览器和服务器之间的缓存机制，在这种架构下同样适用。

### 浏览器端缓存

浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。

### Web应用层缓存

应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率

例如 本地存储和离线存储

## 什么是浏览器缓存

>  Web缓存存在于服务器和客户端之间。Web缓存密切注视着服务器-客户端之间的通信，监控请求，并且把请求输出的内容（例如html页面、 图片和文件）另存一份；然后，如果下一个请求是相同的URL，则直接使用保存的副本，而不是再次请求源服务器。

http缓存是** 基于HTTP协议 ** 的浏览器文件级缓存机制。即针对文件的 ** 重复请求情况 ** 下，浏览器可以根据 ** 协议头 ** 判断从服务器端请求文件还是从本地读取文件

HTTP协议基于请求响应模式，客户端向服务器发送一个请求，请求头包含请求的方法，URI，协议版本以及包含请求修饰符，
客户端信息和内容的类似 MIME的消息结果。 服务器则以一个状态行为作为响应，相应的内容包括消息协议的版本，成功或错误编码加上包含服务器信息，实体元信息以及可能的实体内容。

当浏览器第一次请求某个URL时，顺利访问的话，服务器返回状态200的状态, 同时会返回给浏览器一些Headers集合，例如set-cookie,Last-Mondified,Etag等等

## 关于处理缓存的信息头关键字

HTTP协议中关于缓存的信息头关键字包括Cache-Control(HTTP1.1)，Pragma(HTTP1.0)，last-Modified，Expires等。

### 缓存控制头 Cache-Control

Cache-Control 是最重要的规则。这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。这些指令指定用于阻止缓存对请求或响应造成不利干扰的行为。这些指令 通常覆盖默认缓存算法。缓存指令是单向的，即请求中存在一个指令并不意味着响应中将存在同一个指令。

cache-control 定义是：Cache-Control = “Cache-Control” “:” cache-directive

cache-directive 的取值请参加本文 -- 名词解析 -- 部分

### 过期头 (Expires)

指定资源在浏览器缓存中的过期时间 (需要在服务端设定)

如果给文件加上关于过期时间(Expires)的header报文,这样浏览器就会先检查缓存中的文件，如果没有过期，就直接使用缓存中的文件,从而不会发送http请求

### 控制文件是否有修改 Last-Modified/E-Tag

Last-Modified: 资源更新时间  Etag: 资源的状态唯一标识 一般选择哈希值

Last-Modified PK  Etag

你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？

HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

* (1) Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间

* (2)如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存

* (3)有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。

Last-Modified与ETag是可以一起使用的，** 服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，** 最后才决定是否返回304。

### 浏览器缓存流程图

首次请求

![cache](/img/cache/cache1.png)

第二次访问页面的缓存流程

1 判断expires，如果未过期，直接读取http缓存文件，不发http请求，否则进入下一步

2 判断是否含有etag，有则带上if-none-match发送请求，未修改返回304，修改返回200，否则进入下一步

3 判断是否含有last-modified，有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器请求

![cache](/img/cache/cache2.png)

如果通过etag和last-modified判断，即使返回304有至少有一次http请求，只不过返回的是304的返回内容，而不是文件内容。所以合理设计实现expires参数可以减少较多的浏览器请求

## 名词解析

### Pragma

Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存

当该字段值为no-cache的时候，会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行

在 http1.0 时代，给客户端设定缓存方式可通过两个字段Pragma和Expires来规范。虽然这两个字段早可抛弃，但http协议做了向下兼容，所以依然可以看到

### Expires

响应报文中Expires其定义的是资源“失效时刻”

这里的缓存时间是相对服务器上的时间而言的, 如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了

### Cache-Control

针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间

这三者的优先级从高到低分别是 Pragma -> Cache-Control -> Expires

** 作为请求首部时 ** 其可选属性为

![cache-control](/img/cache/cache-control.png)

Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存。

实际上Cache-Control: no-cache是会被缓存的， 只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。

Cache-Control: no-store：这个才是响应不被缓存的意思。

** 作为响应首部时 ** 其可选属性

![cache-control](/img/cache/cacheControl.png)

### Last-Modified

标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间

### If-Modified-Since

If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。

web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），

HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。

Last-Modified/If-Modified-Since要配合Cache-Control使用

### ETag

ETag 是HTTP1.1中才加入的一个属性，用来帮助服务器控制Web端的缓存验证。

![ETag](/img/cache/etag.png)

它的原理是这样的，当浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值(3f80f-1b6-3e1cb03b)并通过 ETag 返回给浏览器，浏览器把"3f80f-1b6-3e1cb03b" 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: "3f80f-1b6-3e1cb03b" 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一个304未修改。

并未指定ETag是如何产生的 但是哈希是最好的选择方案

### If-None-Match

If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。

Etag/If-None-Match也要配合Cache-Control使用

## 参考文章

1 [浏览器缓存原理](http://www.cnblogs.com/wangpenghui522/p/5498427.html)
