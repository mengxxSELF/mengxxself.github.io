<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>mock数据</title>
      <link href="/2018/12/26/mock%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/12/26/mock%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/12/27/167ee440eb91144c?w=1160&amp;h=634&amp;f=png&amp;s=383086" alt="mock"></p><blockquote><p>前端可通过 <a href="http://mockjs.com/" target="_blank" rel="noopener">Mockjs</a> 模拟数据 独立与后端开发 </p></blockquote><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm i mockjs -D</span><br><span class="line"><span class="keyword">import</span> mock <span class="keyword">from</span> <span class="string">'mockjs'</span></span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Mock.mock(template)</p><p>mock 接受一个模板，将根据定义的模板生成对应格式的数据</p><h4 id="数据模板"><a href="#数据模板" class="headerlink" title="数据模板"></a>数据模板</h4><p>template 可以是一个数据对象 – 属性名、生成规则、属性值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'name|rule'</span>: value</span><br></pre></td></tr></table></figure><p>比如生成一个长度为 3 的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">'id|3'</span>: [<span class="number">1</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &#123; id: [ 1, 1, 1 ] &#125;</span></span><br></pre></td></tr></table></figure><ul><li>‘name|min-max’: value</li></ul><table><thead><tr><th>value格式</th><th>作用</th></tr></thead><tbody><tr><td>string</td><td>重复string生成结果，重复次数区间[min, max]</td></tr><tr><td>number</td><td>生成整数, 区间[min, max]。 也就是这里的 value 并没有什么意义</td></tr><tr><td>object</td><td>随机选取 object 中 min 到 max 个属性 生成新对象</td></tr><tr><td>array</td><td>重复属性值 array 生成一个新数组，重复次数区间[min, max]</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'name|1-3'</span>: <span class="string">'中文'</span> <span class="comment">// name: '中文中文中文' </span></span><br><span class="line"><span class="string">'id|1-3'</span>: <span class="number">18</span> <span class="comment">// id: 3</span></span><br></pre></td></tr></table></figure><ul><li>‘name|count’: values</li></ul><table><thead><tr><th>value格式</th><th>作用</th></tr></thead><tbody><tr><td>string</td><td>重复string生成结果，重复次数 count</td></tr><tr><td>object</td><td>从对象 object 中随机选取 count 个属性</td></tr><tr><td>array</td><td>重复属性值 array 生成一个新数组，重复次数区间[min, max]</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'users|2'</span>: &#123;</span><br><span class="line">  name: <span class="string">'tome'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  habit: <span class="string">'listen'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  users: &#123; age: 20, habit: 'listen' &#125; </span></span><br><span class="line"><span class="comment">//  users: &#123; name: 'tome', habit: 'listen' &#125;</span></span><br></pre></td></tr></table></figure><ul><li>other</li></ul><p>‘name|1’: boolean </p><p>随机生成一个布尔值, true/false 的概率各为50%</p><h4 id="数据占位符-占位符"><a href="#数据占位符-占位符" class="headerlink" title="数据占位符 @占位符"></a>数据占位符 @占位符</h4><p>template 可以是一个占位符</p><p>Mock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数])</p><p>这里简单列举几个常用的占位符</p><p>比如生成 长度为5 的字符 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(<span class="string">'@string(5)'</span>) </span><br><span class="line">Mock.mock(<span class="string">'@csentence(5)'</span>) <span class="comment">// 中文</span></span><br></pre></td></tr></table></figure><p>生成 图片</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random.image(<span class="string">'200x100'</span>, <span class="string">'#50B347'</span>, <span class="string">'#FFF'</span>, <span class="string">'Mock.js'</span>)</span><br></pre></td></tr></table></figure><p><a href="http://mockjs.com/examples.html#DPD" target="_blank" rel="noopener">具体点击查看文档</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://juejin.im/entry/564b293c60b259caed3e7e2c" target="_blank" rel="noopener">Mock.js - 模拟数据生成器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 第三方插件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> mockjs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react源码解析</title>
      <link href="/2018/12/25/react%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/12/25/react%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/12/27/167ee4749d7dfa68?w=1380&amp;h=440&amp;f=png&amp;s=207589" alt="react"></p><blockquote><p>react 源码分析第一章节</p></blockquote><a id="more"></a><p>写一个简单的react组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"App"</span>&gt;</span></span><br><span class="line">  react box</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在babel中看一下，代码将会被编译为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">"App"</span> &#125;,</span><br><span class="line">  <span class="string">"react box"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加一个子元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">  react box</span><br><span class="line">  &lt;p className=<span class="string">'p'</span> data-age=<span class="string">'1123'</span>&gt; i am p &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>babel的转义结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line">React.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">"App"</span> &#125;,</span><br><span class="line">  <span class="string">"react box"</span>,</span><br><span class="line">  React.createElement(</span><br><span class="line">    <span class="string">"p"</span>,</span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">'p'</span>, <span class="string">'data-age'</span>: <span class="string">'1123'</span> &#125;,</span><br><span class="line">    <span class="string">" i am p "</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们在组件中log一下这个结果是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> end = React.createElement(</span><br><span class="line">  <span class="string">"div"</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">"App"</span> &#125;,</span><br><span class="line">  <span class="string">"react box"</span>,</span><br><span class="line">  React.createElement(</span><br><span class="line">    <span class="string">"p"</span>,</span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">'p'</span>, <span class="string">'data-age'</span>: <span class="string">'1123'</span> &#125;,</span><br><span class="line">    <span class="string">" i am p "</span></span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(end, <span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/25/167e476a9210d239?w=854&amp;h=370&amp;f=png&amp;s=180957" alt="log"></p><p>简单概括为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  children: [</span><br><span class="line">    子元素A, 子元素B</span><br><span class="line">  ],</span><br><span class="line">  className: <span class="string">'本元素的类名'</span>,</span><br><span class="line">  本元素的其他属性名: <span class="string">'本元素对应的其他属性值'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">type: <span class="string">'本元素的标签名'</span></span><br></pre></td></tr></table></figure><p>这个 ReactElement 类型的js对象就是React组件了</p><p>也就是 react 将这种对象最后 render 到html文件中的</p><p>看下流程图</p><h2 id="createElement-方法"><a href="#createElement-方法" class="headerlink" title="createElement 方法"></a>createElement 方法</h2><p>看下react 的 createElement 源码</p><p>源码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">return</span> ReactElement(...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactElement</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> element = &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    _owner: owner</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.createElement(</span></span><br><span class="line"><span class="comment">//   type,</span></span><br><span class="line"><span class="comment">//   [props],</span></span><br><span class="line"><span class="comment">//   [...children]</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line">React.createElement(</span><br><span class="line">  div,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'ele'</span>&#125;,</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>实现 createElement 方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">React</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (type, props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type</span><br><span class="line">    <span class="keyword">this</span>.props = props</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(type, props, ...content) &#123;</span><br><span class="line">    <span class="comment">// 因为 props 和 content 都会变为 React 对象的 props 属性值</span></span><br><span class="line">    <span class="keyword">let</span> allProps = <span class="built_in">Object</span>.assign(&#123;&#125;, props, &#123; <span class="attr">children</span>: content&#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> React(type, allProps)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ele = <span class="keyword">new</span> createElement(<span class="string">'div'</span>, &#123; <span class="attr">className</span>: <span class="string">'ele'</span> &#125;, <span class="string">'i am div'</span>, <span class="keyword">new</span> createElement(<span class="string">'p'</span>, &#123;&#125;, <span class="string">'i am p'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(ele)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文章阅读笔记-技术杂谈</title>
      <link href="/2018/12/24/%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/"/>
      <url>/2018/12/24/%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1659022b84159eb5?w=1354&amp;h=544&amp;f=png&amp;s=43243" alt="tips"></p><blockquote><p>在阅读文章的时候，一些有意思的知识点</p></blockquote><a id="more"></a><ul><li>css </li></ul><h3 id="Chrome-调试技巧"><a href="#Chrome-调试技巧" class="headerlink" title="Chrome - 调试技巧"></a>Chrome - <a href="https://juejin.im/post/5c09a80151882521c81168a2" target="_blank" rel="noopener">调试技巧</a></h3><ul><li><p>$ </p></li><li><p>console.table</p></li></ul><p>当想要输出的对象是一个数组的时候 可以用这个以表格形式查看</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167de48407e61b1f?w=587&amp;h=467&amp;f=png&amp;s=69031" alt="table"></p><ul><li>h 隐藏、显示元素</li></ul><p>选中元素后 按一下’h’来轻松隐藏你在元素面板中选择的元素。再次按下’h’可以使它出现</p><ul><li>run commend</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>img在flex布局中的表现</title>
      <link href="/2018/12/21/img%E5%9C%A8flex%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0/"/>
      <url>/2018/12/21/img%E5%9C%A8flex%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167d0f7313c08452?w=1112&amp;h=440&amp;f=png&amp;s=125964" alt="flex"></p><blockquote><p>奇奇怪怪</p></blockquote><a id="more"></a><p>最近在进行css布局调试的时候，发现一些flex布局的有趣现象</p><p>html 结构如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> something <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"xxx"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>css 为flex 布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果为</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167d040d4bfee932?w=1216&amp;h=1008&amp;f=png&amp;s=1910237" alt="page"></p><p>灰色块为div部分</p><p>这里的图片可以看到是超出了div盒子</p><p>我的预期是图片可以被缩小，不会超出盒子</p><p>然后不用图片，换成普通元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> something <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span>&gt;</span> xxxx <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167d0481ffa27437?w=1246&amp;h=516&amp;f=png&amp;s=587504" alt="ele"></p><p>可以看到 右侧的section并没有发生像图片那种超出盒子的现象</p><p>而且即使给 右侧元素添加一个超大的width值，其样式并不会变化</p><p>也就是对于图片没有做像文字这种折行处理，也没有按照预想的进行缩小处理</p><p>要想实现这种图片占满剩余空间的效果，需要给图片添加指定宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span><br></pre></td></tr></table></figure><p>为什么出现这种问题呢？</p><ul><li>对于有默认大小的元素</li></ul><p>图片本身是有大小的，不像 div p span 这些标签。那用input 尝试一下</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167d0d4c9a16d445?w=844&amp;h=530&amp;f=png&amp;s=393204" alt="input"></p><p>和图片的表现一样</p><ul><li>width &amp;&amp; min-width</li></ul><p>一个元素 同时设定width 和 min-width 值 其真正展示的效果是按照这里面的最大值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'width'</span>&gt;</span> width or min-width <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>指定这个元素的 min-width 高于 width</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.width</span> &#123; <span class="attribute">width</span>: <span class="number">100px</span>; <span class="attribute">min-width</span>: <span class="number">300px</span>; <span class="attribute">color </span>: <span class="number">#fff</span>; &#125;</span><br></pre></td></tr></table></figure><p>最后呈现出来的元素是 300px 的效果</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167d0e1dbcf96eea?w=910&amp;h=452&amp;f=png&amp;s=293021" alt="300"></p><p>图片本身有宽度，就相当于有一个 min-width 值呢</p><p>来模拟一个 div</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'min'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> a b c <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子元素 同时设置 width 和 min-width</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div &#123; <span class="attr">display</span>: flex; &#125;</span><br><span class="line">.basis p &#123;</span><br><span class="line">  width: <span class="number">100</span>%; </span><br><span class="line">  min-width: <span class="number">300</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167d0f1124e38309?w=914&amp;h=350&amp;f=png&amp;s=247627" alt="min"></p><p>也是超出了盒子大小</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://www.w3cplus.com/css3/flexbox-layout-and-calculation.html" target="_blank" rel="noopener">深入理解 flex 布局以及计算</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络编程</title>
      <link href="/2018/12/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-node%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"/>
      <url>/2018/12/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-node%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167ceda84509da96?w=920&amp;h=450&amp;f=png&amp;s=122361" alt="network"></p><blockquote><p>第七章 网络编程</p></blockquote><a id="more"></a><h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/20/167cc05df95ccae3?w=982&amp;h=532&amp;f=png&amp;s=68841" alt="model"></p><p>每一层实现各自的功能和协议，并完成与相邻层的接口通信。</p><ul><li>物理层</li></ul><p>网线 </p><ul><li>数据链路层 </li></ul><p>比如网卡，处理与物理设备做交互</p><ul><li>网络层</li></ul><p>ip 协议什么的，基础的网络</p><p>数据在网络中分组传输，网络层处理这些分组数据</p><ul><li>传输层</li></ul><p>tcp 协议什么的</p><p>处理端口之间的通信</p><ul><li><p>会话层</p></li><li><p>表示层</p></li></ul><p>处理数据安全等</p><ul><li>应用层</li></ul><p>http  https</p><p>处理网络数据和应用程序的交互</p><p>平时有用过的那个 nginx 是处理的7层，http协议部分</p><p>在四层中（数据链路层 、网络层、 传输层、应用层）运行的协议，称之为 TCP/IP协议族</p><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/11/b3017842bdddd50386f54ffd64d5491c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="tcp"></p><p>数据传输的时候 在每一层会做加工处理</p><p>通过上图可以看出来，这七层，每一层都可以做的事情</p><p>1 将上层传递数据包装为满足该层协议的数据包</p><p>2 将下层的数据解析为满足该层协议的数据包</p><p>3 与其余层的数据交互</p><p>看一下常见的协议与七层的关系</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/20/167cc24f5f4055e6?w=1464&amp;h=531&amp;f=png&amp;s=79201" alt="tcp"></p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>TCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。</p><p>端口是传输层的东西</p><p>在同一台计算机，两个不同的进程 （pid为进程的标识） 之前进行数据传递，可以通过共享内存等方式。那如果是不同计算机的两个进程呢，需要借助另外的方式处理 — 借助 端口（全称是协议端口号 (protocol port number)，简称端口）</p><p>套接字概念 ： IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：「ip地址＋协议＋端口号」唯一标示网络中的一个进程</p><p>这就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由 TCP 来完成了</p><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><ul><li>服务端</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务端：收到来自客户端的请求'</span>)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'服务端：收到客户端数据，内容为&#123;'</span> + data + <span class="string">'&#125;'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给客户端返回数据</span></span><br><span class="line">        socket.write(<span class="string">'你好，我是服务端'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'服务端：客户端连接断开'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="string">'8124'</span>, <span class="string">'localhost'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务端：开始监听来自客户端的请求'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>talnet 可以和服务器进行对话</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167cf60d3a3194f2?w=1736&amp;h=596&amp;f=png&amp;s=151626" alt="net"></p><h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><p>udp 和 tcp 同属于网络传输层</p><p>创建udp套接字</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>)</span><br><span class="line"><span class="keyword">let</span> server = dgram.createSocket(<span class="string">'udp4'</span>)</span><br></pre></td></tr></table></figure><p>server 既可以做为客户端发送数据 也可以作为服务端接受数据</p><p>dgram模块用于创建基于UDP协议的网络服务，创建不分客户端不分客户端、服务器端，在一端使用dgram.createSocket即可发送数据也可以接收数据。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单元测试</title>
      <link href="/2018/12/06/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/12/06/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/12/6/167822385bf2576a?w=500&amp;h=224&amp;f=png&amp;s=16627" alt="mocha"></p><blockquote><p>mocha + chai</p></blockquote><a id="more"></a><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><blockquote><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作</p></blockquote><p>可以理解为对功能的基本验证</p><p>目前node中的测试框架，一般使用的是 mocha +  断言库 chai </p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install mocha -g</span><br><span class="line">npm install mocha</span><br><span class="line">npm install chai</span><br></pre></td></tr></table></figure><h2 id="mocha-amp-amp-chai"><a href="#mocha-amp-amp-chai" class="headerlink" title="mocha &amp;&amp; chai"></a>mocha &amp;&amp; chai</h2><h3 id="mocha-API"><a href="#mocha-API" class="headerlink" title="mocha API"></a>mocha API</h3><h4 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h4><p> describe 是一个 用例测试集， 他可以进行嵌套</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'进行首页的测试'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="it"><a href="#it" class="headerlink" title="it"></a>it</h4><p>一个it对应一个单元测试用例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'测试接口xxx'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="only-skip"><a href="#only-skip" class="headerlink" title="only skip"></a>only skip</h4><p>only – 在当前的父describe块下，只执行该单元的测试</p><p>skip – 在当前的父describe块下，跳过该单元的测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'Array'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  describe.only(<span class="string">'父describe块下只执行该测试单元'</span>, () =&gt; &#123;</span><br><span class="line">    it.skip(<span class="string">'跳过的测试单元'</span>, () =&gt; &#123; &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>describe 和 it 都可以使用这两个方法</p><h4 id="timeout-设超时"><a href="#timeout-设超时" class="headerlink" title="timeout - 设超时"></a>timeout - 设超时</h4><p>测试集合上定义超时时间，会对这个测试集合中所有的测试用例和测试集合起作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">time</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, time))</span><br><span class="line"> it(<span class="string">'timeout'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.timeout(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">3000</span>)</span><br><span class="line">    expect(<span class="literal">true</span>).to.be.ok</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/6/167819f41d5fcc07?w=432&amp;h=81&amp;f=png&amp;s=15009" alt="timeout"></p><h4 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h4><p>提供了几个函数，在特定的事件发生时被触发</p><p>before()、after()、beforeEach()、afterEach() </p><p>同一个describe下的执行顺序为before、beforeEach、afterEach、after</p><p>before, after 执行一次</p><p>beforeEach，afterEach 每一个测试用例都会触发一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.info(<span class="string">'首页测试开始'</span>))</span><br><span class="line">after(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.info(<span class="string">'首页测试结束'</span>))</span><br><span class="line"></span><br><span class="line">beforeEach(<span class="string">'check check check '</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i am check'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="chai-API"><a href="#chai-API" class="headerlink" title="chai API"></a>chai API</h3><p>chai有三种断言风格，expect，should，assert, 我的项目使用的是 expect</p><h4 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h4><p>列出几个常用的方法</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>equal</td><td>相等（严格比较）</td></tr><tr><td>not</td><td>取反</td></tr><tr><td>include</td><td>包含</td></tr></tbody></table><ul><li>判断数据类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(<span class="string">'username'</span>).to.be.a(<span class="string">'string'</span>)</span><br><span class="line">expect(<span class="literal">false</span>).to.be.a(<span class="string">'boolean'</span>)</span><br><span class="line">expect(obj).to.have.property(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><h2 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h2><p>项目中的大部分函数为异步的，这个需要借助 done 来处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">`处理异步请求`</span>, (done) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  done()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异步函数在函数内部手动调用done()表示测试成功，done(err)表示测试出错</p><p>async await 可以不使用done </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">it(<span class="string">'更新用户对于文章的态度'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> updateAttitude(&#123; <span class="attr">articleId</span>: <span class="number">123</span>, <span class="attr">userId</span>: <span class="number">131</span>, <span class="attr">status</span>: <span class="number">0</span>&#125;)</span><br><span class="line">  expect(result).to.be.a(<span class="string">'number'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最常见的接口测试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'获取某一个频道下的所有文章列表'</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> chai</span><br><span class="line">    .request(app)</span><br><span class="line">    .get(<span class="string">'/articles/3/1'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res.body</span><br><span class="line">    &#125;)</span><br><span class="line">  expect(result).to.have.property(<span class="string">'data'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="测试结果检查"><a href="#测试结果检查" class="headerlink" title="测试结果检查"></a>测试结果检查</h2><h3 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h3><p>生成测试报告使用的是 mochawesome 模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"mocha:report"</span>: <span class="string">"mocha --reporter mochawesome"</span></span><br></pre></td></tr></table></figure><p>会自动在项目创建 一个 mochawesome-report 目录,</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677e7efd6f6e106?w=840&amp;h=198&amp;f=png&amp;s=32489" alt="report"></p><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>简单来说，就是判断你的测试用例对于函数的覆盖程度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g istanbul</span><br></pre></td></tr></table></figure><p>生成测试率覆盖报告</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istanbul cover _mocha -- -R spec</span><br></pre></td></tr></table></figure><p>注： 这里是 _mocha 不要丢掉这下划线</p><p>会在项目中自动创建 coverage 文件夹</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/6/16781777cf7ef1ca?w=536&amp;h=202&amp;f=png&amp;s=24940" alt="coverage"></p><p>在浏览器中打开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open coverage/lcov-report/index.html</span><br></pre></td></tr></table></figure><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ul><li>是否所有的函数都要编写测试用例</li></ul><p>接口是肯定需要编写测试用例的，至于是否需要对函数做处理，个人感觉可以对重要的函数进行测试</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/f200a75a15d2" target="_blank" rel="noopener">Chai.js–API</a></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>git常用操作</title>
      <link href="/2018/12/06/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/12/06/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/12/14/167aad6f6ad558c8?w=1177&amp;h=507&amp;f=png&amp;s=131075" alt="git"></p><blockquote><p>git</p></blockquote><a id="more"></a><ul><li>撤销commit</li></ul><p>1 查看每一commit的版本号  git log </p><p>2 代码恢复</p><p>git reset –hard commit_id</p><p>完成撤销,同时将代码恢复到前一commit_id 对应的版本。</p><p>3 git reset commit_id  – 取消commit</p><p>完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改</p><ul><li>撤销 merge</li></ul><p>1 查看版本号</p><p>git reflog</p><p>2 代码恢复</p><p>git reset –hard xxx</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack升级v4</title>
      <link href="/2018/11/02/webpack%E5%8D%87%E7%BA%A7v4/"/>
      <url>/2018/11/02/webpack%E5%8D%87%E7%BA%A7v4/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16735279fb5413b5?w=497&amp;h=304&amp;f=jpeg&amp;s=19072" alt="webpack4"></p><blockquote><p>webpack4</p></blockquote><a id="more"></a><p>最近项目在做重构，刚好把webpack升级到V4</p><p>基本配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  watch,</span><br><span class="line">  optimization,</span><br><span class="line">  entry,</span><br><span class="line">  output,</span><br><span class="line">  <span class="built_in">module</span>,</span><br><span class="line">  plugins,</span><br><span class="line">  resolve</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><ul><li><p>CleanPlugin</p></li><li><p>MiniCssExtractPlugin</p></li></ul><p>代替 V3 中经常使用的 extract-text-webpack-plugin</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Node中包的查找机制</title>
      <link href="/2018/10/26/Node%E4%B8%AD%E5%8C%85%E7%9A%84%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/10/26/Node%E4%B8%AD%E5%8C%85%E7%9A%84%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/12/25/167e37f97791f498?w=944&amp;h=351&amp;f=png&amp;s=57015" alt="npm"></p><blockquote><p>模块查找</p></blockquote><a id="more"></a><h3 id="项目中引用的模块"><a href="#项目中引用的模块" class="headerlink" title="项目中引用的模块"></a>项目中引用的模块</h3><p>Node中的模块可以分为三类，根据模块类型不同，其使用方式也有差别</p><p>核心模块  自定义模块  文件模块</p><p>核心模块是Node本身就提供的模块，会在Node源码编译时就编译为二进制执行文件并在Node进程启动时加载进内存</p><p>自定义模块和文件模块从加载形式上可以分为一类，都是在运行时动态加载，区别在于文件查找的策略不同</p><p>Node对引入过的模块都会缓存，每一次引入模块时都会首先检查缓存，如果不存在，则进入模块查找流程</p><p>查看模块缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>.cache)</span><br></pre></td></tr></table></figure><p>对于每一个被加载的文件模块 都在创建的时候 会自动携带一个path属性 是根据当前文件路径计算的 可以输出一个module.paths 会得到问文件的查找路径</p><p>一般是在当前文件目录下查找node_modules 目录 然后进入父级目录的node_modules  最后会查找到根级目录node_modules</p><p>看一个模块的查找路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.paths)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/10/26/166ae676f4494713?w=657&amp;h=190&amp;f=png&amp;s=38578" alt="path"></p><p>层级逐渐向上</p><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>在package.json中一般会配置项目一些启动方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scripts: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"nodemon index.js"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --config webpack.config.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这里所需的 nodemon 或者是  webpack 模块加载机制，并不是上面那种逐级向上查找的方式了</p><p>每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令</p><p>比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p><p>这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径</p><p>看下这里 .bin 文件里有什么命令可被执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim node_modules/.bin</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/10/26/166ae763718ebc4e?w=656&amp;h=842&amp;f=png&amp;s=84408" alt="bin"></p><ul><li><p>如果全局和本地都安装了webpack 那么使用的是哪一个呢</p><p>使用本地，如果本地没有，获取查找全局</p></li></ul><h3 id="命令行直接输入命令"><a href="#命令行直接输入命令" class="headerlink" title="命令行直接输入命令"></a>命令行直接输入命令</h3><p>在项目中，如果直接在命令行输入执行命令，则其使用全局的模块还是本地的模块</p><p>全局会判断本地是否有此模块，有就使用本地，没有就使用全局</p><ul><li>如果本地和全局都有安装</li></ul><p>会使用本地模块</p><ul><li>本地没有安装，只有全局有</li></ul><p>使用全局模块</p><h3 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h3><ul><li><p><a href="https://www.sweetalkos.com/post/97" target="_blank" rel="noopener">《Node的模块与包管理机制》</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener">《npm scripts 使用指南》</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1030一期文章分享</title>
      <link href="/2018/10/25/1030%E4%B8%80%E6%9C%9F%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
      <url>/2018/10/25/1030%E4%B8%80%E6%9C%9F%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章阅读</p></blockquote><a id="more"></a><h1 id="1207-第七期"><a href="#1207-第七期" class="headerlink" title="1207 第七期"></a>1207 第七期</h1><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a><a href="http://caibaojian.com/http-cache-code.html" target="_blank" rel="noopener">cache</a></h2><h1 id="1123-第五期"><a href="#1123-第五期" class="headerlink" title="1123 第五期"></a>1123 第五期</h1><h2 id="JavaScript-复杂判断的更优雅写法"><a href="#JavaScript-复杂判断的更优雅写法" class="headerlink" title="JavaScript 复杂判断的更优雅写法"></a><a href="https://www.jianshu.com/p/8ea39cb9c2ad" target="_blank" rel="noopener">JavaScript 复杂判断的更优雅写法</a></h2><p>文章分类: 奇淫技巧</p><p>文章点评:</p><p>条件判断是很常见的逻辑，当需要处理大量判断条件的时候，可以改变逻辑方式。虽然文章中的方案在代码直观理解方面不如基本写法，但是合理的代码注释可以弥补这个不足</p><h2 id="危险的-target-”-blank”-与-“opener”"><a href="#危险的-target-”-blank”-与-“opener”" class="headerlink" title="危险的 target=”_blank” 与 “opener”"></a><a href="https://knownsec-fed.com/2018-03-01-wei-xian-de-targetblank-yu-opener/" target="_blank" rel="noopener">危险的 target=”_blank” 与 “opener”</a></h2><p>文章分类: 奇淫技巧</p><p>文章点评: </p><p>处理一个a标签的点击可能带来的哪些风险</p><h1 id="1116-第四期"><a href="#1116-第四期" class="headerlink" title="1116 第四期"></a>1116 第四期</h1><h2 id="React-Profiler-介绍"><a href="#React-Profiler-介绍" class="headerlink" title="React Profiler 介绍"></a><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/introducing-the-react-profiler.md" target="_blank" rel="noopener">React Profiler 介绍</a></h2><p>文章分类: 工具</p><p>文章点评:</p><p>需要react 16.5 版本支持，可以看到每一个组件的渲染，从性能分布图可以找到哪一个组件耗费时间最长并做出调整</p><h2 id="CSS-Grid带来的新单位：分数单位fr"><a href="#CSS-Grid带来的新单位：分数单位fr" class="headerlink" title="CSS Grid带来的新单位：分数单位fr"></a><a href="https://www.w3cplus.com/css/css-grid-fr-unit.html" target="_blank" rel="noopener">CSS Grid带来的新单位：分数单位fr</a></h2><p>文章分类: CSS</p><p>文章点评:</p><p>Grid 中出现的计算单位 fr， 但仅限于 Grid 使用 </p><h1 id="1109-第三期"><a href="#1109-第三期" class="headerlink" title="1109 第三期"></a>1109 第三期</h1><h2 id="如何写一个通用的README规范"><a href="#如何写一个通用的README规范" class="headerlink" title="如何写一个通用的README规范"></a><a href="https://juejin.im/post/5aaa06e4f265da237b21cf63" target="_blank" rel="noopener">如何写一个通用的README规范</a></h2><p>文章分类: 文档规范</p><p>文章点评:</p><p>readme 可以看做是与项目沟通的重要文档，是不可缺少的一个文件。</p><p>一个没有readme的仓库让人痛苦。写好reademe，造福你我他。</p><h2 id="大前端神器安利之-Puppeteer"><a href="#大前端神器安利之-Puppeteer" class="headerlink" title="大前端神器安利之 Puppeteer"></a><a href="https://www.jeffjade.com/2017/12/17/134-kinds-of-toss-using-puppeteer/" target="_blank" rel="noopener">大前端神器安利之 Puppeteer</a></h2><p>文章分类: 工具</p><p>文章点评:</p><p>Puppeteer 是很棒的爬虫工具，API很强大，网上的参考资料也很多，十分钟</p><p>就可以写demo了</p><h1 id="1102-第二期"><a href="#1102-第二期" class="headerlink" title="1102 第二期"></a>1102 第二期</h1><h2 id="TypeScript-2-8下的终极React组件模式"><a href="#TypeScript-2-8下的终极React组件模式" class="headerlink" title="TypeScript 2.8下的终极React组件模式"></a><a href="https://juejin.im/post/5b07caf16fb9a07aa83f2977" target="_blank" rel="noopener">TypeScript 2.8下的终极React组件模式</a></h2><p>文章分类: 框架</p><p>文章点评:</p><p>react几种组件的开发方式都有提到。里面附带的编译工具可以方便的体验TS，省去之前麻烦的环境搭建流程。文章有的地方翻译的有些生硬，理解就好不必强求</p><h2 id="sequelize"><a href="#sequelize" class="headerlink" title="sequelize"></a><a href="https://itbilu.com/nodejs/npm/VkYIaRPz-.html" target="_blank" rel="noopener">sequelize</a></h2><p>文章分类: API</p><p>文章点评:</p><p>非常全面的 sequelize 使用介绍，在使用sequelize-typescript之前可以按照这个系列文章敲一敲代码，如果全部理解可以很轻松的过渡到TS</p><h2 id="《作为前端你拿什么证明网站体验》"><a href="#《作为前端你拿什么证明网站体验》" class="headerlink" title="《作为前端你拿什么证明网站体验》"></a><a href="https://juejin.im/post/5b9e61b15188255c980bc6fd" target="_blank" rel="noopener">《作为前端你拿什么证明网站体验》</a></h2><p>文章分类: 用户体验，性能优化</p><p>文章点评:</p><p>1 关于数据请求</p><p>文章中提到的数据请求方面的优化，采用的是预判用户行为加载数据 – 当鼠标滑动到tab组 未点击时 就进行数据请求</p><p>不过对于移动端页面，以电商首页为例，无法借鉴这种优化方式</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/25/166a9cd3ef14e688?w=1080&amp;h=1920&amp;f=jpeg&amp;s=125216" alt="channel]"></p><p>由于分类列表数据变动次数不是非常频繁，采用的优化方式为</p><p>在用户点击了本次频道后，将数据保存到本地，当二次请求的时候，不在做数据请求</p><p>2 补充文章</p><p><a href="https://zhuanlan.zhihu.com/p/43282197" target="_blank" rel="noopener">《css加载会造成阻塞吗》</a></p><p><a href="https://www.zhihu.com/question/25952487" target="_blank" rel="noopener">《阿里巴巴iconfont怎么是正确的使用方式？》</a></p><h2 id="《前端异常监控》"><a href="#《前端异常监控》" class="headerlink" title="《前端异常监控》"></a><a href="https://juejin.im/post/5b53218cf265da0f9313a3de" target="_blank" rel="noopener">《前端异常监控》</a></h2><p>文章分类：前端监控</p><p>文章点评:</p><p>使用过的第三方的关于前端监控信息处理</p><p>1 最基本的页面异常上报 <a href="https://git.blued.cn/xudong/blued-et" target="_blank" rel="noopener">blued-et</a></p><p>监控页面error，需要去编写上报异常的router</p><p>2 听云</p><p>可以监控到各个页面解析渲染情况，比如页面耗时占比、访问量排序以及用户打开页面分析等</p><p>3 sentry (目前在用)</p><p>异常上报，可以设置邮件提醒，查看报错代码，设备型号等</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nginx使用指南</title>
      <link href="/2018/10/22/nginx%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2018/10/22/nginx%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sequelize入门篇</title>
      <link href="/2018/10/21/sequelize%E5%85%A5%E9%97%A8%E7%AF%87/"/>
      <url>/2018/10/21/sequelize%E5%85%A5%E9%97%A8%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/22/16699aab6d18add9?w=774&amp;h=380&amp;f=png&amp;s=44639" alt="sequelize"></p><blockquote><p>ORM框架 — sequelize 用于将数据库的表关系映射到对象</p></blockquote><a id="more"></a><p>mysql的一个表的数据结构如下</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16680010bf1d2e17?w=296&amp;h=181&amp;f=png&amp;s=13797" alt="mysql"></p><p>每一行其实是一个对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">    name: <span class="string">'tom'</span>,</span><br><span class="line">    password: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是 ORM 框架做的事情</p><p>ORM使我们读写的都是JavaScript对象，Sequelize帮我们把对象变成数据库中的行</p><h3 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h3><h4 id="本地安装-mysql"><a href="#本地安装-mysql" class="headerlink" title="本地安装 mysql"></a>本地安装 mysql</h4><p>网上提供了两种方式，文件安装或者使用 homebrew，先使用文件安装，之后一直无法启动。后来删除之后使用brew重新安装</p><p>有的Mac可以直接使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure><p>但是我的一直安装失败，查阅资料发现，是因为系统没有升级，所以不能这么处理 需要指定安装mysql的版本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew search mysql <span class="comment">// 查看有哪些版本可安装</span></span><br><span class="line"></span><br><span class="line">brew install mysql@<span class="number">5.7</span></span><br><span class="line"></span><br><span class="line">brew services start mysql@<span class="number">5.7</span></span><br></pre></td></tr></table></figure><p>安装之后启动时mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start</span><br></pre></td></tr></table></figure><p>关于其中会一直报错 命令找不到，需要调整 全局变量 修改了两个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/usr/local/opt/mysql@5.7/bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>登录mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>这个方式是需要输入 mysql 密码的，但是我并没有注意到安装mysql的时候 有提示密码是什么。。。</p><p>更换登录方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root mysql</span><br></pre></td></tr></table></figure><p>这个命令虽然可以登录，但是我们想使用sequel pro 本地连接，还是需要密码的，所以找了一个重置密码的方式</p><p><a href="https://www.cnblogs.com/jiuyi/p/6211271.html" target="_blank" rel="noopener">参考文章</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止mysql</span></span><br><span class="line">mysql.server stop</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入安全模式</span></span><br><span class="line"></span><br><span class="line">sudo mysqld_safe --skip-grant-tables</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录mysql</span></span><br><span class="line">mysql -u root mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换数据库</span></span><br><span class="line">use mysql;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 密码 -- 密码字段为 authentication_string</span></span><br><span class="line"></span><br><span class="line">UPDATE mysql.user SET authentication_string=PASSWORD(<span class="string">'mypassword'</span>) where User=<span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新权限，使配置生效</span></span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 MySQL</span></span><br><span class="line"></span><br><span class="line">mysql.server start</span><br></pre></td></tr></table></figure><p>总结一下，就是修改 mysql 库的user表中 User 为 root 的 authentication_string 字段值</p><h4 id="sequel-pro-可视化工具链接mysql"><a href="#sequel-pro-可视化工具链接mysql" class="headerlink" title="sequel pro 可视化工具链接mysql"></a>sequel pro 可视化工具链接mysql</h4><p>mysql这种表结构一般使用 可视化工具方便查看信息</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16680258114aa571?w=992&amp;h=732&amp;f=png&amp;s=87561" alt="mysql"></p><p>这里的host 不可以使用 localhost</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/1668026c4729dbfd?w=806&amp;h=404&amp;f=png&amp;s=104581" alt=""></p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>普通的直接使用mysql链接</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mysqlConfig = &#123;</span><br><span class="line">  host: [<span class="string">'127.0.0.1'</span>], <span class="comment">// 网址ip</span></span><br><span class="line">  port: <span class="number">3306</span>,  <span class="comment">// 端口</span></span><br><span class="line">  user: <span class="string">'root'</span>,  <span class="comment">// 用户</span></span><br><span class="line">  password: <span class="string">'5211314mxx'</span>, <span class="comment">// 密码</span></span><br><span class="line">  database: <span class="string">'activity'</span>, <span class="comment">// 数据库</span></span><br><span class="line">  key: <span class="string">'mysql'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pool = mysql.createPool(mysqlConfig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> query = <span class="function"><span class="keyword">function</span>(<span class="params"> sql, values </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params"> resolve, reject </span>) =&gt;</span> &#123;</span><br><span class="line">    pool.getConnection(<span class="function"><span class="keyword">function</span>(<span class="params">err, connection</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        resolve( err )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connection.query(sql, values, ( err, rows) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> ( err ) &#123;</span><br><span class="line">            reject( err )</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve( rows )</span><br><span class="line">          &#125;</span><br><span class="line">          connection.release()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sequelize"><a href="#sequelize" class="headerlink" title="sequelize"></a>sequelize</h3><blockquote><p>Sequelize是一个关系型数据库ORM框架，它基于Promise构建。支持MySQL、PostgreSQL、MariaDB、SQLite和MSSQL几种关系型数据库，功能非常强大。</p></blockquote><p>安装包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i sequelize mysql2</span><br></pre></td></tr></table></figure><p>sequelize 类对象，通过new关键字进行实例化，以连接池的形式连接到所使用的数据库</p><p>创建一个实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sequelizeObj = <span class="keyword">new</span> Sequelize(数据库， 用户名， 密码， 配置参数config )</span><br></pre></td></tr></table></figure><p>sequelize 实例API</p><ul><li><p>define 定义模型</p></li><li><p>getDialect 返回数据库类型</p></li><li><p>models 返回所有模型</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequelizeObj.models()</span><br></pre></td></tr></table></figure><ul><li>import 导入模型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequelize.import(path) -&gt; Model</span><br></pre></td></tr></table></figure><ul><li>query  执行SQL语句的查询</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequelize.query(sql, [options=&#123;&#125;]) -&gt; <span class="built_in">Promise</span></span><br></pre></td></tr></table></figure><ul><li>sync 同步模型到数据库</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequelize.sync()</span><br></pre></td></tr></table></figure><ul><li>drop 删除表<br>*</li></ul><h4 id="链接mysql表"><a href="#链接mysql表" class="headerlink" title="链接mysql表"></a>链接mysql表</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sequelize = <span class="built_in">require</span>(<span class="string">"sequelize"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelizeObject = <span class="keyword">new</span> Sequelize(<span class="string">'activity'</span>, <span class="string">'root'</span>, <span class="string">'5211314mxx'</span>, &#123;</span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="string">'3306'</span>,</span><br><span class="line">  dialect: <span class="string">'mysql'</span>,</span><br><span class="line">  pool: &#123;   <span class="comment">//连接池设置</span></span><br><span class="line">    max: <span class="number">5</span>, <span class="comment">//最大连接数</span></span><br><span class="line">    min: <span class="number">0</span>, <span class="comment">//最小连接数</span></span><br><span class="line">    idle: <span class="number">10000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  define: &#123;</span><br><span class="line">    underscored: <span class="literal">false</span>, <span class="comment">// 驼峰命名</span></span><br><span class="line">    timestamps: <span class="literal">true</span>, <span class="comment">// 时间戳</span></span><br><span class="line">    freezeTableName: <span class="literal">true</span> <span class="comment">// Model 对应的表名将与model名相同</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数含义</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>host</td><td>数据库地址,默认本机</td></tr><tr><td>dialect</td><td>数据库 ‘mysql’</td><td>‘mariadb’</td><td>‘sqlite’</td><td>‘postgres’</td><td>‘mssql’</td></tr><tr><td>pool</td><td>连接池设置</td></tr><tr><td>logging</td><td>是否将SQL语句输出到命令行</td></tr><tr><td>define</td><td>定义一些其余属性</td></tr></tbody></table><table><thead><tr><th>define 参数</th><th>含义</th></tr></thead><tbody><tr><td>freezeTableName</td><td>在查询的时候，sequelize可能会使用复数的表名 比如 use-&gt; users , 设定为TRUE 则不会使用这种复数的表名</td></tr></tbody></table><p>其实还可以将配置参数简写为一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Sequelize(<span class="string">'mysql://root:5211314mxx@127.0.0.1/activity'</span>, &#123;&#125;)</span><br><span class="line">&lt;!-- 数据库类型 用户名 密码  IP databases  --&gt;</span><br></pre></td></tr></table></figure><p>当实例化对象后，就可以通过其返回的sequelize实例定义Model、执行query查询</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>定义表结构  define 就是常见一个表模型</p><p>define 用于定义模型和表的映射关系</p><p>使用方式</p><p>obj.define(‘你的表名’, {字段配置 segConfig }, {设置其余信息 tableConfig})</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模型</span></span><br><span class="line"><span class="keyword">const</span> User = sequelizeObject.define(<span class="string">'eyes_users'</span>, &#123;</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: Sequelize.INTEGER,</span><br><span class="line">    primaryKey: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  name: Sequelize.STRING(<span class="number">100</span>), <span class="comment">// 用户名</span></span><br><span class="line">  password: Sequelize.INTEGER(<span class="number">100</span>) <span class="comment">// 密码</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  timestamps: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>segConfig 常用参数</li></ul><table><thead><tr><th>属性</th><th>属性值以及含义</th></tr></thead><tbody><tr><td>type</td><td>当前字段类型</td></tr><tr><td>defaultValue</td><td>默认值</td></tr><tr><td>allowNull</td><td>是否可以为null</td></tr><tr><td>primaryKey</td><td>是否是主键</td></tr><tr><td>autoIncrement</td><td>是否是自增</td></tr><tr><td>comment</td><td>相当于注释</td></tr><tr><td>unique</td><td>是否是索引</td></tr></tbody></table><ul><li>tableConfig 常用参数</li></ul><table><thead><tr><th>属性</th><th>属性值以及含义</th></tr></thead><tbody><tr><td>timestamps</td><td>是否添加时间戳, 启用该配置后会自动添加createdAt、updatedAt两个字段，分别表示创建和更新时间</td></tr><tr><td>underscored</td><td>自动添加的字段会在数据段中使用“蛇型命名”规则，如：createdAt在数据库中的字段名会是created_at</td></tr><tr><td>paranoid</td><td>是否使用虚拟删除。启用该配置后，数据不会真实删除，而是添加一个deletedAt属性</td></tr></tbody></table><h3 id="常用的数据类型-Datatypes"><a href="#常用的数据类型-Datatypes" class="headerlink" title="常用的数据类型  Datatypes"></a>常用的数据类型  Datatypes</h3><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>STRING</td><td>字符串 最长255</td></tr><tr><td>STRING(123)</td><td>字符串 最长123</td></tr><tr><td>TEXT</td><td>文本格式</td></tr><tr><td>DATE</td><td>时间</td></tr><tr><td>FLOAT</td><td>浮点数</td></tr><tr><td>TIME</td><td>日期时间</td></tr><tr><td>ARRAY</td><td>数组</td></tr><tr><td>BOOLEAN</td><td>布尔类型</td></tr><tr><td>ENUM</td><td>枚举</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = sequelize.define(<span class="string">'eyes_user'</span>, &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">    &lt;!-- 主键 --&gt;</span><br><span class="line">        type: Sequelize.NUMBER, <span class="attr">primaryKey</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    registerTime: &#123;</span><br><span class="line">    &lt;!--时间  默认值为创建时间--&gt;</span><br><span class="line">        type: Sequelize.DATE, <span class="attr">defaultValue</span>: Sequelize.NOW</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="model-常用API"><a href="#model-常用API" class="headerlink" title="model 常用API"></a>model 常用API</h3><h4 id="sync-同步模型到数据库"><a href="#sync-同步模型到数据库" class="headerlink" title="sync  同步模型到数据库"></a>sync  同步模型到数据库</h4><p>define 定义好了模型对象，这些表是无法自动在数据库中创建的，需要调用一下 sync 才能在对应数据库中创建这些表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.listen(port, <span class="keyword">async</span>() =&gt; &#123;</span><br><span class="line">  <span class="comment">// force:true  表示首先删除表再重新创建表</span></span><br><span class="line">  <span class="keyword">await</span> User.sync(&#123; <span class="attr">force</span>: <span class="literal">true</span> &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    cosnole.log(<span class="string">'created'</span>)  </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'the port is'</span>, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong> 关于 sync方法 </strong></p><p>Model.sync()只会同步当前模型到数据库中</p><p>sequelize.sync()会同步sequelize实例中定义所有模型</p><h4 id="create-find-update-destory"><a href="#create-find-update-destory" class="headerlink" title="create find update destory"></a>create find update destory</h4><p>常用的mysql使用 - 增删改查</p><h5 id="查"><a href="#查" class="headerlink" title="查"></a>查</h5><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>findOne</td><td>检索一个元素</td></tr><tr><td>findAll</td><td>检索所有</td></tr><tr><td>findById</td><td>根据id检索</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> User.findOne(&#123;</span><br><span class="line">  where: &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;,</span><br><span class="line">  attributes: [<span class="string">'password'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对应的sql语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select password <span class="keyword">from</span> table where name = name limit <span class="number">1</span></span><br></pre></td></tr></table></figure><p>有的时候我们需要将检索出来的字段做命名处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid, user_age <span class="keyword">as</span> age <span class="keyword">from</span> table where id = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>就可以写为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">user.findOne(&#123;</span><br><span class="line">   where: &#123;<span class="attr">id</span>: <span class="number">3</span>&#125;,</span><br><span class="line">   attributes: &#123;</span><br><span class="line">    uid,</span><br><span class="line">    [user_age, age]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="增"><a href="#增" class="headerlink" title="增"></a>增</h5><ul><li>单条记录增加</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> User.create(&#123;</span><br><span class="line">  name,</span><br><span class="line">  password: encodePwd</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对应SQL语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into table (name, password) values (name, encodePwd)</span><br></pre></td></tr></table></figure><ul><li>批量增加</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> User.bulkCreate([</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'tom'</span>, <span class="attr">birthday</span>: <span class="string">'123'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'tom2'</span>, <span class="attr">birthday</span>: <span class="string">'1234'</span>&#125;,</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><ul><li>直接更新</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> Info.update(&#123;</span><br><span class="line">    brithday: <span class="number">20180101</span>,</span><br><span class="line">    sex: <span class="string">'boy'</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    where: &#123; name &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对应sql语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udpate table set brithday = <span class="number">20180101</span>, sex = <span class="string">'boy'</span> where name = name</span><br></pre></td></tr></table></figure><ul><li>有则更新 没有则创建</li></ul><p>upsert</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> Info.upsert(&#123;</span><br><span class="line">  birthday,</span><br><span class="line">  userId</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  fields: [<span class="string">'birthday'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>SQL语句为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO <span class="string">`eyes_info`</span> (<span class="string">`userId`</span>,<span class="string">`birthday`</span>) VALUES (<span class="string">'1'</span>,<span class="string">'2088'</span>) ON DUPLICATE KEY UPDATE <span class="string">`birthday`</span>=VALUES(<span class="string">`birthday`</span>);</span><br></pre></td></tr></table></figure><p>感觉这个和replace into 作用一样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace into tabale (<span class="string">`userId`</span>,<span class="string">`birthday`</span>) values (<span class="number">1</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h5 id="删"><a href="#删" class="headerlink" title="删"></a>删</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> User.destroy(&#123;</span><br><span class="line">  where: &#123;id&#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  body = &#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: <span class="string">'success'</span> &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  body = &#123; <span class="attr">code</span>: <span class="number">500</span>, <span class="attr">message</span>: <span class="string">'failture'</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><h5 id="where"><a href="#where" class="headerlink" title="where"></a>where</h5><p>基本使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.findAll(&#123;</span><br><span class="line">    where: &#123;</span><br><span class="line">        id: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">        city: <span class="string">'beijing'</span>,</span><br><span class="line">        home: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>where 字段中的对象， key: value 格式， 彼此之间属于 and 条件，也就是</p><p>key1 = v1 and key2 = v2</p><ul><li><p>key: null 意味着 key is null</p></li><li><p>key: []   意味着  key in ()</p></li><li><p>value 还可以是一个对象格式 可以进一步对字段进行约束，比如 &gt;  like</p></li></ul><p>betweent 等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">id: &#123;</span><br><span class="line">    $eq: <span class="number">1</span> <span class="comment">// = 1</span></span><br><span class="line">    $ne: <span class="number">1</span> <span class="comment">// != 1</span></span><br><span class="line">    $or: [</span><br><span class="line">       [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       &#123; <span class="attr">$gt</span>: <span class="number">10</span> &#125;</span><br><span class="line">    ] <span class="comment">// id in (1, 2, 3) or id &gt; 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>$eq</td><td>=</td></tr><tr><td>$gt</td><td>&gt;</td></tr><tr><td>$gte</td><td>&gt;=</td></tr><tr><td>$lt</td><td>&lt;</td></tr><tr><td>$betweent</td><td>between 6 and 10</td></tr><tr><td>$notBetween</td><td>not between 6 and 10</td></tr><tr><td>$like</td><td>like ‘xxx’</td></tr><tr><td>$or</td><td>or</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">where name != <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">where age &gt; <span class="number">18</span></span><br><span class="line"></span><br><span class="line">where uid <span class="keyword">in</span> (<span class="number">134</span>, <span class="number">145</span>)</span><br></pre></td></tr></table></figure><h5 id="其余常用方法"><a href="#其余常用方法" class="headerlink" title="其余常用方法"></a>其余常用方法</h5><ul><li>limit offset</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User.findAndCountAll(&#123;</span><br><span class="line">  limit: <span class="number">20</span>,</span><br><span class="line">  offset: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>order 做排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User.findAll(&#123; <span class="attr">order</span>: <span class="string">'updateAt'</span> &#125;)</span><br><span class="line"></span><br><span class="line">User.findAll(&#123; <span class="attr">order</span>: <span class="string">'count DESC'</span> &#125;)</span><br></pre></td></tr></table></figure><p>group 做分组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User.findAll(&#123; <span class="attr">group</span>: <span class="string">'uid'</span> &#125;)</span><br></pre></td></tr></table></figure><ul><li>count</li></ul><p>统计元素个数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Info.count()</span><br><span class="line"></span><br><span class="line">Info.count(&#123; <span class="attr">where</span>: &#123; <span class="attr">id</span>: &#123;<span class="attr">$gt</span>: <span class="number">10</span>&#125; &#125; &#125;)</span><br></pre></td></tr></table></figure><ul><li>max min</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Product.min(<span class="string">'id'</span>, &#123; <span class="attr">limit</span>: <span class="number">30</span>, <span class="attr">offset</span>: <span class="number">10</span> &#125;)</span><br></pre></td></tr></table></figure><h4 id="表关系处理"><a href="#表关系处理" class="headerlink" title="表关系处理"></a>表关系处理</h4><p>建立三个表</p><table><thead><tr><th>表</th><th>含义</th></tr></thead><tbody><tr><td>User</td><td>用户注册表 每注册一个用户 则存放一条数据</td></tr><tr><td>Info</td><td>用户信息表 一个用户UID 存放一条数据</td></tr><tr><td>Group</td><td>用户组 一个用户UID  可以加入多个 组  一个组可以有多个用户UID</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户注册表</span></span><br><span class="line"><span class="keyword">const</span> User = sequelizeObject.define(<span class="string">'eyes_users'</span>, &#123;</span><br><span class="line">  id: &#123;</span><br><span class="line">    type: Sequelize.INTEGER,</span><br><span class="line">    primaryKey: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  name: Sequelize.STRING(<span class="number">100</span>), <span class="comment">// 用户名</span></span><br><span class="line">  password: Sequelize.INTEGER(<span class="number">100</span>) <span class="comment">// 密码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户信息表</span></span><br><span class="line"><span class="keyword">const</span> Info = sequelizeObject.define(<span class="string">'eyes_info'</span>, &#123;</span><br><span class="line">  userId: &#123;</span><br><span class="line">    type: Sequelize.INTEGER,</span><br><span class="line">    primaryKey: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  birthday: Sequelize.STRING(<span class="number">100</span>), <span class="comment">// 生日</span></span><br><span class="line">  age: Sequelize.INTEGER(<span class="number">100</span>) <span class="comment">// 年龄</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户组 一组可以有多个UID  同一个UID可以进不同group</span></span><br><span class="line"><span class="keyword">const</span> Group = sequelizeObject.define(<span class="string">'eyes_group'</span>, &#123;</span><br><span class="line">  groupId: &#123;</span><br><span class="line">    type: Sequelize.INTEGER,</span><br><span class="line">    primaryKey: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  uid: &#123;</span><br><span class="line">    type: Sequelize.INTEGER(<span class="number">100</span>),</span><br><span class="line">    primaryKey: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vip   一个用户UID只能有一个vip等级</span></span><br><span class="line"><span class="keyword">const</span> Vip = sequelizeObject.define(<span class="string">'eyes_vip'</span>, &#123;</span><br><span class="line">  vip: &#123;</span><br><span class="line">    type: Sequelize.INTEGER,</span><br><span class="line">    primaryKey: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  uid: &#123;</span><br><span class="line">    type: Sequelize.INTEGER(<span class="number">100</span>),</span><br><span class="line">    primaryKey: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><ul><li>一对一关系</li></ul><blockquote><p> 指一个实体的某个数据与另外一个实体的一个数据有关联关系</p></blockquote><p>比如 User 与 Info 表</p><ul><li>一对多</li></ul><blockquote><p>一对多与多对一是一个概念 指一个实体的某个数据与另外一个实体的多个数据有关联关系</p></blockquote><p>比如 Vip 与 User 表</p><ul><li>多对多关系</li></ul><blockquote><p>一个实体的数据对应另外一个实体的多个数据，另外实体的数据也同样对应当前实体的多个数据</p></blockquote><p>比如 User 与 Group 表</p><h4 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h4><p>以 Info 表和Vip表为例</p><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM join_table</span><br><span class="line">[INNER] JOIN join_table2</span><br><span class="line">[ON join_condition]</span><br><span class="line">WHERE where_definition</span><br></pre></td></tr></table></figure><p>只列出这些连接表中与连接条件相匹配的数据行。INNER可以不写，则默认为内连接。[ON join_condition]里面写的是连接的条件。</p><p>比如 检索 vip 为 2 的 所有用户年龄</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select tableA.uid, tableA.birthday, tableA.age</span><br><span class="line">   <span class="keyword">from</span> eyes_info <span class="keyword">as</span> tableA</span><br><span class="line">   join eyes_vip <span class="keyword">as</span> tabeleB join vip = <span class="number">2</span> and uid = userId</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------+----------+------------+</span><br><span class="line">| uid  | birthday | age      |</span><br><span class="line">+-----------------+----------+------------+</span><br><span class="line">| <span class="number">12</span>   | <span class="number">01</span><span class="number">-10</span>    |       <span class="number">22</span> |</span><br><span class="line">| <span class="number">137</span>  | <span class="number">08</span><span class="number">-9</span>     |       <span class="number">18</span> |</span><br><span class="line">+-----------------+----------+------------+</span><br></pre></td></tr></table></figure><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>左外连接(LEFT [OUTER] JOIN)</p><p>右外连接(RIGHT [OUTER] JOIN)</p><p>不仅列出与连接条件（on）相匹配的行，还列出左表table1(左外连接)、或右表table2(右外连接)、或两个表(全外连接)中所有符合WHERE过滤条件的数据行。一般都是用左连接或者外连接</p><p>其中，[OUTER]部分可以不写，(LEFT | RIGHT | FULL)部分要写其中一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT … FROM join_table1</span><br><span class="line"></span><br><span class="line">(LEFT | RIGHT | FULL) [OUTER] JOIN join_table2</span><br><span class="line"></span><br><span class="line">ON join_condition</span><br><span class="line"></span><br><span class="line">WHERE where_definition</span><br></pre></td></tr></table></figure><ul><li><p>左外连接：左表列出全部，右表只列出匹配的记录</p></li><li><p>右外连接：右表列出全部，左表只列出匹配的记录</p></li></ul>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>rem基本原理</title>
      <link href="/2018/10/20/rem%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2018/10/20/rem%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>移动端适配方案</p></blockquote><a id="more"></a><p>什么是移动端适配</p><p>制作一套页面，在不同设备中，页面图片、文字、间隙大小会变化，但是在比例上保持一致。</p><h3 id="Rem"><a href="#Rem" class="headerlink" title="Rem"></a>Rem</h3><p>简单来说，将原来的px转为rem</p><p>需要判断根元素字体大小 每一个设备的根元素字体大小不同</p><p>设备根元素字体 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize</span><br></pre></td></tr></table></figure><ul><li>如何判断使用多大根字体</li></ul><p>假设设计稿为640px  当设备宽度也为640px  则可完全按照设计稿进行布局 但是单位要使用rem</p><p>将根元素字体大小设置为100px  比较好算</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body&#123;font-size: <span class="number">100</span>px;&#125;</span><br><span class="line">p&#123;margin-top:<span class="number">0.3</span>rem;&#125;<span class="comment">// 相当于 X rem</span></span><br><span class="line"><span class="number">30</span>px/X rem = <span class="number">100</span>;  求出X 为 <span class="number">0.3</span></span><br></pre></td></tr></table></figure><p>关于变化的根元素</p><p>在设计稿640px  有一个元素宽度 20px  根元素字体大小100px    写为自适应 使用rem 单位  0.2 rem</p><p>在设备  320px  有一个元素宽度 20px  根元素字体大小？？？PX         使用rem 单位  0.2 rem</p><p>所以变化的是设备的根元素</p><h4 id="求设备根元素大小"><a href="#求设备根元素大小" class="headerlink" title="求设备根元素大小"></a>求设备根元素大小</h4><p>当设计稿宽度为desW    设备宽度为 docW</p><p>设备宽度的缩放倍数 = 根元素字体大小缩放倍数</p><p>设计稿宽度/设备宽度 = 100/ X</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> desW = <span class="number">750</span>;<span class="comment">// 设计稿宽度</span></span><br><span class="line"><span class="keyword">var</span> winW = <span class="built_in">document</span>.documentElement.clientWidth; <span class="comment">// 设备宽度</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = winW/desW*<span class="number">100</span>+<span class="string">"px"</span>; <span class="comment">// 求出当前设备根元素大小</span></span><br></pre></td></tr></table></figure><p>注意，求出当前设备宽度使用的是document.documentElement.clientWidth  其实这个是文档宽度 而由于在开头有写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>/&gt;</span><br></pre></td></tr></table></figure><p>width=device-width 表明了将文档宽度设置为设备宽度</p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flex布局是Flexible Box的缩写  是弹性布局的意思  用来为盒状模型提供很大灵活性</p><p>所有的容器都可以指定为Flex布局 只要将其指定为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div &#123; <span class="attr">display</span>: flex; &#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以flex布局  display设置为 inline-flex 即可</p><ul><li>设为flex布局之后 子元素的float  clear vertical-align 属性失效</li></ul><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>采用Flex布局的元素称为Flex容器 其子元素为容器成员 称为项目</p><p>容器默认存在主轴【水平方向】和交叉轴【垂直方向】</p><p>主轴开始位置 mian start 结束位置 main end</p><p>容器默认沿着主轴排列 单个项目占据的主轴空间是main size</p><h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><p>flex-direction<br>flex-wrap<br>flex-flow<br>justify-content<br>align-items<br>align-content</p><p>1 flea-direction 决定主轴方向 【项目的排列方向  默认是水平 起点左侧】</p><p>row  【默认值】 主轴为水平方向 左侧为起点位置<br>reo-reverse  主轴为 水平   右侧是起点<br>column 主轴是垂直  上为起点<br>column-reverse  主轴是垂直 下为起点</p><p>2 flex-wrap</p><p>默认情况 项目排列为一条线 又称轴线  flex-warp 属性定义了如果在轴线排列不下的情况 如何换行</p><p>nowrap  【默认】 不换行<br>wrap  正常换行 第一行在上<br>wrap-reverse  换行 第一行在下方</p><p>3 flex-flow</p><p>这个属性其实是flex-direction和flex-wrap的简写形式  默认是 row nowrap</p><p>4 justify-content</p><p>属性定义了项目在主轴上的对齐方式</p><p>flex-start  【默认值】 左对齐<br>flex-end 右对齐<br>center 居中<br>space-between 两端对齐  项目之间间隔相同<br>space-around 每个项目两侧间隔相同  所以 项目之间的间隔比项目与边框之间的间隔大一倍</p><p>5 align-items</p><p>定义项目在交叉轴上 如何对齐  假设交叉轴为默认值 上到下</p><p>flex-strat  与交叉轴的起点对齐<br>flex-end 与交叉轴终点对齐<br>center 与交叉轴中点对齐<br>baseline  项目的第一行文字的基线对齐<br>stretch 【默认值】 如果项目没设置高度 或者设为auto  将沾满全部容器空间</p><p>6 align-content</p><p>定义多跟轴线的对齐方式 这里如果项目只有一根轴线 则设置无效</p><p>flex-start<br>flex-end<br>center<br>space-between<br>space-around</p><p>7 属于项目的属性</p><p>order<br>flex-grow<br>flex-shrink<br>flex-basis<br>flex<br>align-self</p><p>7.1 order</p><p>定义项目排列顺序 数值笑的排位靠前 默认0</p><p>7.2 flex-grow</p><p>定义项目的放大比例 默认0</p><p>7.3 flex-shrink</p><p>定义项目缩小比例 默认为1  如果空间不足 项目按照比例缩小</p><p>7.4 flex-basis</p><p>在分配多余空间前 项目占据的主轴空间大小 默认为auto</p><p>7.5 flex</p><p>这个属性是flex-grow flex-shrink flex-basis的简写 默认是 0 1 auto</p><p>7.6 align-self</p><p>允许单个项目与其余的不同 可以覆盖align-items属性 默认为auto 继承父级元素的align-items属性 如果此元素并没有父元素 则等用于stretch</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
            <tag> rem </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>typescript-react</title>
      <link href="/2018/09/28/typescript-react/"/>
      <url>/2018/09/28/typescript-react/</url>
      
        <content type="html"><![CDATA[<blockquote><p>项目ts版做半重构</p></blockquote><a id="more"></a><h3 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查</p></blockquote><p>在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p><p>定义属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface props &#123;</span><br><span class="line">  readonly name: string</span><br><span class="line">  habit? : string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个函数所需的形状</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface fnBox &#123;</span><br><span class="line">  (len:number, <span class="attr">cont</span>: number): number[]    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pushAry:fnBox</span><br><span class="line">pushAry = <span class="function"><span class="keyword">function</span> (<span class="params">len: number, cont: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(cont)    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这里故意写错cont的类型，会有什么提示</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/28/1661ee46975a3f58?w=925&amp;h=353&amp;f=png&amp;s=269858" alt="inetrface"></p><p>可以定义无返回值的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface props &#123;</span><br><span class="line">  once(): <span class="keyword">void</span> </span><br><span class="line">  twice: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 &amp;&amp; 接口</p><p>implements 可以使类 具有接口的属性功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface int2 &#123;</span><br><span class="line">  once(): <span class="keyword">void</span>,</span><br><span class="line">  touchMore: <span class="function">(<span class="params">count: number</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Btn</span> <span class="title">implements</span> <span class="title">int2</span> </span>&#123;</span><br><span class="line">  once () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'once'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  touchMore (count: number) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'touchMore'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> btns = <span class="keyword">new</span> Btn</span><br><span class="line">btns.once()</span><br><span class="line">btns.touchMore(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><h3 id="配置-tsconfig-json"><a href="#配置-tsconfig-json" class="headerlink" title="配置 tsconfig.json"></a>配置 tsconfig.json</h3><p>1 使用webpack搭建项目的时候，有配置alias参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'utils'</span>: path.resolve(__dirname, <span class="string">'../utils'</span>)</span><br></pre></td></tr></table></figure><p>这样在组件中引入的时候，文件路径可以简化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; log &#125; <span class="keyword">from</span> <span class="string">'utils/statistics'</span></span><br></pre></td></tr></table></figure><p>不过在使用ts之后，会发现组件中有警告信息，表示找不到此模块</p><p>就需要另外在tsconfig中添加配置参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"baseUrl"</span>: <span class="string">"./"</span>,</span><br><span class="line"><span class="string">"paths"</span>: &#123;</span><br><span class="line">  <span class="string">"components"</span>: [<span class="string">"./components/*"</span>],</span><br><span class="line">  <span class="string">"utils"</span>: [<span class="string">"./utils/*"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2  noEmitOnError: true</p><p>当编译出错，则不输出编译后的文件</p><h3 id="全局变量-window"><a href="#全局变量-window" class="headerlink" title="全局变量 window"></a>全局变量 window</h3><p>在访问页面的时候，server会反馈一些基本的用户信息，比如用户名，设备版本号等，将这些全部挂载在CONFIG变量中了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  window.CONFIG = JSON.parse(decodeURIComponent(&apos;&#123;&#123;feConfig&#125;&#125;&apos;))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">const &#123;uid, version&#125; = window.CONFIG // 然后在组件中可以直接获取</span><br></pre></td></tr></table></figure><p>但是在加入TS之后，会提示window中不存在属性CONFIG</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/28/1661f5da919ed31b?w=888&amp;h=167&amp;f=png&amp;s=200358" alt="window"></p><p>这是因为 ts 不允许从未</p><p>处理方案</p><p>1 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare global &#123;</span><br><span class="line">  interface Window &#123; <span class="attr">CONFIG</span>: any &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;uid&#125; = <span class="built_in">window</span>.CONFIG</span><br></pre></td></tr></table></figure><p>2 使用类型断言</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; apk &#125; = (<span class="built_in">window</span> <span class="keyword">as</span> any).CONFIG</span><br></pre></td></tr></table></figure><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">props</span>, <span class="title">state</span>&gt;</span>&#123;</span><br><span class="line">    -- <span class="keyword">do</span> something --</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p></blockquote><p>比如写一个根据指定内容填充到指定长度的数组生成函数 getAry</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getAry (len: number, cont: string | number): string[] | number[] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(cont)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th>参数</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>len</td><td>指定长度</td><td>number</td></tr><tr><td>cont</td><td>指定内容</td><td>string 或 number （使用联合类型处理）</td></tr></tbody></table><p>由于不确定参数cont的输入类型，所以返回值使用了联合类型处理</p><p>这种需要 返回值类型和输入参数类型保持一致的情况，可以使用泛型T来处理</p><p>泛型是类型变量，一种用来表示类型的特殊变量</p><ul><li>使用方式</li></ul><p>在函数名后添加&lt;&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function createFn&lt;T&gt;</span><br><span class="line">function createFn&lt;string&gt; // 明确指定 T 是 string 类型的</span><br></pre></td></tr></table></figure><p>其实泛型函数的类型与非泛型函数的类型没什么不同，只是多了一个类型参数在最前面</p><ul><li>可以指定默认类型</li></ul><p>TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beConfusion</span>&lt;<span class="title">T</span> = <span class="title">boolean</span>&gt; (<span class="params">name: string, isDone: boolean</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>将上面那个函数使用接口来定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface dealFn &#123;</span><br><span class="line">  &lt;T&gt;(len: number, <span class="attr">cont</span>: T): T[]    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> getAry: dealFn</span><br><span class="line">getAry = function &lt;T&gt; (len: number, cont: T): T[] &#123;</span><br><span class="line"> --<span class="keyword">do</span> something--    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>泛型类使用&lt;&gt;括起泛型类型，跟在类名后面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DealAry</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  value: T</span><br><span class="line">  <span class="keyword">constructor</span> (value: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  deal () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><ul><li>其余的一些泛型变量</li></ul><p>虽然可以自己定义泛型变量结构，但是一般会使用已定义好的泛型</p><p>Promise<t></t></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> taobaoGoods =  <span class="function"><span class="keyword">function</span> (<span class="params">ids: number[]</span>): <span class="title">Promise</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> &lt;string&gt;<span class="function">(<span class="params">(reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      reslove(<span class="string">'success'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      reject(<span class="string">'failture'</span>)</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以有多个泛型变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><h4 id="React-component-类的泛型变量"><a href="#React-component-类的泛型变量" class="headerlink" title="React.component 类的泛型变量"></a>React.component 类的泛型变量</h4><p>打开 node_modules/@types/react 可以看到 component 类</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/28/1661f1b1d5cf6f97?w=848&amp;h=425&amp;f=png&amp;s=355775" alt="component"></p><p>简单概括就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span>&lt;<span class="title">P</span> </span>= &#123;&#125; , S = &#123;&#125; &gt; &#123;</span><br><span class="line">  -- other --</span><br><span class="line">  readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt;</span><br><span class="line">  state: Readonly&lt;S&gt;</span><br><span class="line">  -- other --</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 props 和 state 两个对象都是只读的</p><p>所以我们在写React组件的时候，要调整为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface BannerProps &#123;</span><br><span class="line">  showUpdate(): <span class="keyword">void</span>,</span><br><span class="line">  clickOnce: <span class="function">(<span class="params">type: string, id: number</span>) =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface BannerState &#123;</span><br><span class="line">  once: boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">BannerProps</span>, <span class="title">BannerState</span>&gt; </span>&#123;</span><br><span class="line">  --<span class="keyword">do</span> something--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>获取一个元素的某个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  new Swiper(findDomNode(this), Object.assign(&#123;&#125;, options, &#123;</span><br><span class="line">    onInit: () =&gt; &#123;...&#125;  </span><br><span class="line">  &#125;))    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ts提示有错误</p><blockquote><p>类型断言（Type Assertion）可以用来手动指定一个值的类型</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值 或者 值 <span class="keyword">as</span> 类型</span><br></pre></td></tr></table></figure><p><strong> 在jsx中必须使用 第二种方式去处理  </strong></p><p>在不确定类型的时候就访问其中一个类型的属性或方法，可以使用类型断言</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span> (<span class="params">arg: string | boolean</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( arg.length ) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种其实会报错的，如果输入是布尔值，则没有length</p><p>借助类型断言调整一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span> (<span class="params">arg: string | boolean</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (arg <span class="keyword">as</span> string).length  ) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">//  if ( (&lt;string&gt;arg).length ) return true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言成一个联合类型中不存在的类型是不允许的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (arg <span class="keyword">as</span> array).length  ) <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>所以上面组件里 需要调整为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="keyword">new</span> Swiper(findDomNode(<span class="keyword">this</span>), (<span class="built_in">Object</span> <span class="keyword">as</span> any).assign(&#123;&#125;, options, &#123;</span><br><span class="line">    onInit: <span class="function"><span class="params">()</span> =&gt;</span> &#123;...&#125;  </span><br><span class="line">  &#125;))    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="掉坑记录"><a href="#掉坑记录" class="headerlink" title="掉坑记录"></a>掉坑记录</h3><h4 id="获取DOM的style属性"><a href="#获取DOM的style属性" class="headerlink" title="获取DOM的style属性"></a>获取DOM的style属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="built_in">document</span>.body.children </span><br><span class="line">    <span class="keyword">const</span> cont = target[<span class="number">0</span>].style.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要调整为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="built_in">document</span>.body.children </span><br><span class="line">    <span class="keyword">const</span> cont = target[<span class="number">0</span>][<span class="string">'style'</span>].height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写法"><a href="#写法" class="headerlink" title="::写法"></a>::写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Banner once=&#123;::<span class="keyword">this</span>.update&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这个主要是借助了爸bable 的  transform-function-bind </p><p>ts不支持这种写法 必须要调整为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Banner once=&#123;() =&gt; <span class="keyword">this</span>.update&#125; /&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类以及继承</title>
      <link href="/2018/09/26/%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/09/26/%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>es6的继承</p><a id="more"></a><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="es5中的类"><a href="#es5中的类" class="headerlink" title="es5中的类"></a>es5中的类</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Move (left, end) &#123;</span><br><span class="line">  this.left = left</span><br><span class="line">  this.end = end</span><br><span class="line">&#125;</span><br><span class="line">Move.prototype.walk = function () &#123;</span><br><span class="line">  do &#123;</span><br><span class="line">    this.left++</span><br><span class="line">    console.log(this.left)</span><br><span class="line">  &#125; while (this.left &lt; this.end)</span><br><span class="line">&#125;</span><br><span class="line">var move = new Move(2, 5)</span><br><span class="line">move.walk()</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>用来初始化新创建的对象的函数是构造函数 如 Move </p><p>通过构造函数的new操作创建的对象是实例对象 如 move</p><p>构造函数有一个prototype属性，指向实例对象的原型对象。同一个构造函数实例化的多个对象是具有相同的原型对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var move1 = new Move(1, 2)</span><br><span class="line">var move2 = new Move(2, 3)</span><br><span class="line">move1.__propto__ === move2.__propto__ // true</span><br></pre></td></tr></table></figure><p>原型对象有一个constructor属性，指向该原型对象对应的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Move.prototype.contructor === Move // true</span><br></pre></td></tr></table></figure><p>由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(move1.constructor === Move, <span class="string">'constructor'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(move1.hasOwnProperty(<span class="string">'constructor'</span>), <span class="string">'hasOwnPrototype'</span>) <span class="comment">// false  -- constructor 属性是继承自原型对象Move.prototype</span></span><br></pre></td></tr></table></figure><h3 id="es6-的类"><a href="#es6-的类" class="headerlink" title="es6 的类"></a>es6 的类</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (left, end) &#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left</span><br><span class="line">    <span class="keyword">this</span>.end = end</span><br><span class="line">  &#125;</span><br><span class="line">  running () &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.left += <span class="number">10</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.left)</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">this</span>.left &lt; <span class="keyword">this</span>.end)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">new</span> Run(<span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line">run.running()</span><br></pre></td></tr></table></figure><p>定义一个 Run 类 具有 running 方法</p><p>类的所有方法都定义在类的prototype属性上面</p><p>相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Run.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;&#125;</span><br><span class="line">  running () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而类的实例调用方法，就是在调用原型上的方法</p><p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (left, end) &#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left</span><br><span class="line">    <span class="keyword">this</span>.end = end</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Run.prototype, &#123;</span><br><span class="line">  running()&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.left += <span class="number">10</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.left)</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="keyword">this</span>.left &lt; <span class="keyword">this</span>.end)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">new</span> Run(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">run.running()</span><br></pre></td></tr></table></figure><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法</p><p>一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加</p><p>constructor方法默认返回实例对象（即this），也指定返回另外一个对象</p><p>Q: 当constructor 返回值被修改 ， 会有什么后果</p><h4 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h4><p>实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(run.hasOwnProperty(<span class="string">'left'</span>), <span class="string">'left'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(run.hasOwnProperty(<span class="string">'running'</span>), <span class="string">'running'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(run.__proto__.hasOwnProperty(<span class="string">'running'</span>), <span class="string">'running'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>因为 left 和 end 属性都定义在实例自身 (this) 上, 所以 hasOwnProperty 可以找到此属性</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> stop () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'woow, stop it!!'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Run.stop() <span class="comment">// 'woow, stop it!!', Run</span></span><br></pre></td></tr></table></figure><p><strong> 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例 </strong> </p><p>静态方法可以与非静态方法重名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">   stop () &#123;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="number">0</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.left, <span class="string">'stop now, please'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> stop () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'woow, stop it!!'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> run = <span class="keyword">new</span> Run(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">run.running()</span><br><span class="line">run.stop()</span><br></pre></td></tr></table></figure><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><blockquote><p>静态属性指的是 Class 本身的属性，而不是定义在实例对象（this）上的属性</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;&#125;</span><br><span class="line">Run.props1 = <span class="string">'i am props1'</span></span><br></pre></td></tr></table></figure><p>处于提案中的类的静态属性的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> props1 = <span class="string">'i am props1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例的属性</li></ul><p>处于提案中的实例属性的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  whoProps = <span class="string">'i am whoProps'</span></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.whoProps) <span class="comment">// 'i am whoProps'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="es5-的-继承"><a href="#es5-的-继承" class="headerlink" title="es5 的 继承"></a>es5 的 继承</h3><p><a href="https://mengxxself.github.io/2016/12/10/%E7%BB%A7%E6%89%BF/" target="_blank" rel="noopener">继承</a></p><p>ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）</p><h3 id="es6-继承"><a href="#es6-继承" class="headerlink" title="es6 继承"></a>es6 继承</h3><p>通过extends关键字实现继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Walk extends Run &#123;</span><br><span class="line">  constructor (left, end) &#123;</span><br><span class="line">    super(left, end)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const walk = new Walk(1, 20)</span><br><span class="line">walk.running()</span><br></pre></td></tr></table></figure><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/27/166197e8f34e3ccd?w=1996&amp;h=772&amp;f=png&amp;s=500608" alt="constructor"></p><p>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Walk</span> <span class="keyword">extends</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="comment">// constructor (left, end) &#123;</span></span><br><span class="line">  <span class="comment">//   // super(left, end)</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Walk</span> <span class="keyword">extends</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line"> <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是你可以不写 constructor 但是如果写了 constructor 就必须写 super </p><p>实例对象同时是 子类 和 父类 的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(walk <span class="keyword">instanceof</span> Walk, walk <span class="keyword">instanceof</span> Run)</span><br></pre></td></tr></table></figure><p>子类可以继承父类的静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> stop () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'woow, stop it!!'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Run.stop() <span class="comment">// 'woow, stop it!!', Run</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Walk</span> <span class="keyword">extends</span> <span class="title">Run</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Walk.stop() <span class="comment">// 'woow, stop it!!', Walk</span></span><br></pre></td></tr></table></figure><h4 id="Object-getPrototypeOf-获取父类"><a href="#Object-getPrototypeOf-获取父类" class="headerlink" title="Object.getPrototypeOf 获取父类"></a>Object.getPrototypeOf 获取父类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isP = <span class="built_in">Object</span>.getPrototypeOf(Walk) === Run</span><br><span class="line"><span class="built_in">console</span>.log(isP, <span class="string">'isP'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以使用这个方法判断，一个类是否继承了另一个类</p><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><h3 id="作为函数"><a href="#作为函数" class="headerlink" title="作为函数"></a>作为函数</h3><p>作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Walk</span> <span class="keyword">extends</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  back () &#123;</span><br><span class="line">    <span class="keyword">super</span>() <span class="comment">// 报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作为对象"><a href="#作为对象" class="headerlink" title="作为对象"></a>作为对象</h3><ul><li>super作为对象时，在普通方法中，指向父类的原型对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (left, end) &#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left</span><br><span class="line">    <span class="keyword">this</span>.end = end</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.left + <span class="string">'left left'</span></span><br><span class="line">  &#125;</span><br><span class="line">  write () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.left + <span class="string">' write, write'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Walk</span> <span class="keyword">extends</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (left, end) &#123;</span><br><span class="line">    <span class="keyword">super</span>(left, end)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.write())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> walk = <span class="keyword">new</span> Walk(<span class="number">1</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例</p><ul><li>在静态方法中，指向父类</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (left, end) &#123;</span><br><span class="line">    <span class="keyword">this</span>.left = left</span><br><span class="line">    <span class="keyword">this</span>.end = end</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.left + <span class="string">'left left'</span></span><br><span class="line">  &#125;</span><br><span class="line">  stop () &#123;</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="number">0</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.left, <span class="string">'stop now, please'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> stop () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'woow, stop it!!'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Walk</span> <span class="keyword">extends</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (left, end) &#123;</span><br><span class="line">    <span class="keyword">super</span>(left, end)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.write())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> lay () &#123;</span><br><span class="line">    <span class="keyword">super</span>.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Walk.lay() <span class="comment">// woow, stop it!! Walk</span></span><br></pre></td></tr></table></figure><p>在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。</p><p><strong> 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错 </strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">super</span>) <span class="comment">// 这样是会报错的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每日一练第七期</title>
      <link href="/2018/09/17/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E4%B8%83%E6%9C%9F/"/>
      <url>/2018/09/17/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E4%B8%83%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/17/165e75c1e41f4ba8?w=471&amp;h=271&amp;f=png&amp;s=120070" alt="copy"></p><blockquote><p>copy</p></blockquote><a id="more"></a><h2 id="Q-什么是深拷贝和浅拷贝？如何实现深拷贝"><a href="#Q-什么是深拷贝和浅拷贝？如何实现深拷贝" class="headerlink" title="Q: 什么是深拷贝和浅拷贝？如何实现深拷贝?"></a>Q: 什么是深拷贝和浅拷贝？如何实现深拷贝?</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>拷贝相当于在堆内存中开辟一片新的空间，把源数组或者对象的每个属性都复制过来。而不是只是复制一个存放地址</p><h2 id="Q-原型是什么？原型链是什么？用你的语言把下面这张图讲解清楚"><a href="#Q-原型是什么？原型链是什么？用你的语言把下面这张图讲解清楚" class="headerlink" title="Q: 原型是什么？原型链是什么？用你的语言把下面这张图讲解清楚"></a>Q: 原型是什么？原型链是什么？用你的语言把下面这张图讲解清楚</h2>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每日一练第六期</title>
      <link href="/2018/09/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E5%85%AD%E6%9C%9F/"/>
      <url>/2018/09/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E5%85%AD%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c32df21dd7558?w=1110&amp;h=576&amp;f=png&amp;s=72964" alt="6"></p><blockquote><p>new + bind</p></blockquote><a id="more"></a><h2 id="Q-js-中的new-到底做了什么"><a href="#Q-js-中的new-到底做了什么" class="headerlink" title="Q: js 中的new () 到底做了什么"></a>Q: js 中的new () 到底做了什么</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>声明对象，将 类的prototype 赋值给 新对象 <strong>proto</strong> 属性 </p><p>call改变类的this为新对象 返回该对象</p><h3 id="ANSWER"><a href="#ANSWER" class="headerlink" title="ANSWER"></a>ANSWER</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。当代码 new Foo(…) 执行时，会发生以下事情：</p><p>一个继承自 Foo.prototype 的新对象被创建</p><p>使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况</p><p>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">"cat"</span>);</span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">"cat"</span>) = &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">  obj.__proto__ = Animal.prototype;</span><br><span class="line">  <span class="keyword">let</span> result = Animal.call(obj,<span class="string">"cat"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span>? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1）创建一个空对象obj</p><p>（2）把obj的<strong>proto</strong> 指向Animal的原型对象prototype，此时便建立了obj对象的原型链：</p><p>obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</p><p>（3）在obj对象的执行环境调用Animal函数并传递参数“cat”。 相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = obj.Animal(<span class="string">"cat"</span>)</span><br></pre></td></tr></table></figure><p>当这句执行完之后，obj便产生了属性name并赋值为”cat”</p><p>（4）考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回</p><h2 id="Q-下面是一个bind方法的Polyfill-请逐句给别人讲解一下每一行代码的含义"><a href="#Q-下面是一个bind方法的Polyfill-请逐句给别人讲解一下每一行代码的含义" class="headerlink" title="Q  下面是一个bind方法的Polyfill,请逐句给别人讲解一下每一行代码的含义"></a>Q  下面是一个bind方法的Polyfill,请逐句给别人讲解一下每一行代码的含义</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Function.prototype.bind - what is trying to be bound is not callable'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">  <span class="keyword">let</span> fToBind = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> fNOP  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> fBound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP</span><br><span class="line">            ? <span class="keyword">this</span></span><br><span class="line">            : oThis,</span><br><span class="line">            aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">          );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">    fNOP.prototype = <span class="keyword">this</span>.prototype; </span><br><span class="line">  &#125;</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">  <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Q-移动端适配的解决方案-以及其优缺点"><a href="#Q-移动端适配的解决方案-以及其优缺点" class="headerlink" title="Q : 移动端适配的解决方案,以及其优缺点"></a>Q : 移动端适配的解决方案,以及其优缺点</h2><h3 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h3><ul><li>媒体查询</li></ul><p>需要增加很多的不同分辨率的样式代码</p><ul><li>rem</li></ul><p>在变更屏幕大小之后，还需要重新刷新页面才生效</p><ul><li>百分比</li></ul><h2 id="Q-请说下this是使用"><a href="#Q-请说下this是使用" class="headerlink" title="Q: 请说下this是使用"></a>Q: 请说下this是使用</h2><p>1 this跟函数在哪里定义没有关系，函数在哪里调用才决定了this到底引用的是什么</p><p>2 this机制的四种规则</p><p>  2.1 默认绑定全局变量,这条规则是最常见的，也是默认的。当函数被单独定义和调用的时候，应用的规则就是绑定全局变量。<br>  2.2 隐式绑定 隐式调用的意思是，函数调用时拥有一个上下文对象，就好像这个函数是属于该对象的一样<br>  2.3 显示绑定 学过bind()\apply()\call()函数的都应该知道，它接收的第一个参数即是上下文对象并将其赋给this。<br>  2.4 new新对象绑定 如果是一个构造函数，那么用new来调用，那么绑定的将是新创建的对象</p><h2 id="Q-请谈谈v8的垃圾回收机制"><a href="#Q-请谈谈v8的垃圾回收机制" class="headerlink" title="Q 请谈谈v8的垃圾回收机制"></a>Q 请谈谈v8的垃圾回收机制</h2><p>在老生代中，以下情况会先启动标记清除算法：</p><p>1 某一个空间没有分块的时候<br>2 空间中被对象超过一定限制<br>3 空间不能保证新生代中的对象移动到老生代中</p><p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。</p><p>为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。</p><p>但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。<br>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p><p>老生代算法<br>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p><p>在讲算法前，先来说下什么情况下对象会出现在老生代空间中：</p><p>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</p><p>To空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</p><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。<br>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>object-fit</title>
      <link href="/2018/09/07/object-fit/"/>
      <url>/2018/09/07/object-fit/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b29eb537d12cf?w=621&amp;h=335&amp;f=png&amp;s=17010" alt="css"></p><blockquote><p>object-fit 使用</p></blockquote><a id="more"></a><p>这周在处理视频播放的问题，全屏播放，在css中将video宽高强制设置为100%，发现在某些手机中会有两侧黑边</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a863815e2a603?w=1026&amp;h=274&amp;f=png&amp;s=147738" alt="gap"></p><p>并没有全屏，解决方案，使用一个CSS属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">object-fit</span>: <span class="selector-tag">cover</span>;</span><br></pre></td></tr></table></figure><p>但是为什么这个可以实现呢，今天来探究一下</p><h2 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h2><blockquote><p>其内容不受CSS视觉格式化模型控制的元素,比如image,嵌入的文档(iframe之类),叫做替换元素</p></blockquote><ul><li>视觉格式化模型</li></ul><p>可以理解为在视觉媒体上如何处理文档树。参考BFC,IFC</p><p>CSS渲染模型不考虑替换元素内容的渲染。这些替换元素的展现独立于CSS。</p><p>object,video,textarea,input也是替换元素,audio和canvas在某些特定情形下为替换元素。</p><p>使用CSS的content属性插入的对象是匿名替换元素。</p><ul><li>替换元素</li></ul><p>替换元素通常有其固有的尺寸:一个固有的宽度,一个固有的高度和一个固有的比率</p><p>比如图片和视频有宽度和高度,是有自身宽高比率的</p><h2 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h2><table><thead><tr><th>参数</th><th>取值</th></tr></thead><tbody><tr><td>fill</td><td>被替换的内容大小可以填充元素的内容框。 整个对象将<strong>完全填充</strong>此框。 如果对象的高宽比不匹配其框的宽高比，那么该对象将<strong>被拉伸以适应</strong></td></tr><tr><td>contain</td><td>被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时<strong>保留其长宽比</strong>，因此如果宽高比与框的宽高比不匹配，该对象<strong>将被添加黑边</strong></td></tr><tr><td>cover</td><td>被替换的内容大小<strong>保持其宽高比</strong>，同时填充元素的整个内容框。 如果对象的宽高比与盒子的宽高比不匹配，该对象将<strong>被剪裁</strong>以适应</td></tr><tr><td>none</td><td>被替换的内容大小<strong>保持其宽高比</strong>，而且被替换的内容<strong>尺寸不会被改变</strong></td></tr><tr><td>scale-down</td><td>内容的尺寸就像是指定了none或contain，取决于哪一个将导致更小的对象尺寸</td></tr></tbody></table><p>各个浏览器支持情况</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a9914fcb47d78?w=1339&amp;h=373&amp;f=png&amp;s=58499" alt="use"></p><p>object-fit 的默认值为fill，完全填充</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">   <span class="attribute">object-fit</span>: fill;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;img src="https://www.bldimg.com/eshop/photos/1535623413_43938.jpg?imageView2/0/w/250" alt=""&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b1e24971b416a?w=875&amp;h=404&amp;f=png&amp;s=584852" alt="fill"></p><p>从左到右展示， img空元素  原始图片 img按照fill填充了原始图片之后 </p><p>可以看到，图片被强制填充整个Img盒子，完全变形了</p><h2 id="contain"><a href="#contain" class="headerlink" title="contain"></a>contain</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">   <span class="attribute">object-fit</span>: contain;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;img src="https://www.bldimg.com/eshop/photos/1535623413_43938.jpg?imageView2/0/w/250" alt=""&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b1e5bb8a28800?w=928&amp;h=418&amp;f=png&amp;s=646693" alt="contain"></p><p>从左到右展示， img空元素  原始图片 img按照contain填充了原始图片之后 </p><p>图片保持了原始宽高比</p><p>我们找一个宽高比小于1的图片看看</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">   <span class="attribute">object-fit</span>: contain;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;img src="https://web.bldimg.com/cblued/static/img.1cmoujbgofhbhi.png?imageView2/0/w/250" alt=""&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b1ec4d3068935?w=863&amp;h=416&amp;f=png&amp;s=617254" alt="contain"></p><p>contain属性 会选择边比较长的那一个为准，另外的一个边会保持居中</p><table><thead><tr><th>宽高</th><th>结果</th></tr></thead><tbody><tr><td>宽度 &gt; 高度</td><td>水平方向100% 垂直方向居中</td></tr><tr><td>宽度 &lt; 高度</td><td>垂直方向100% 水平方向居中</td></tr></tbody></table><p>所以这个属性也可以用来处理图片居中问题了</p><p>比如这个，商品的图片居中</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a9a6a1501d3cb?w=409&amp;h=380&amp;f=png&amp;s=76418" alt="goods"></p><p>之前的css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">6.06rem</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制宽度，高度自适应。</p><p>但是这样有一个问题，就是在做懒加载的过程中，由于没有固定盒子高度，导致在滑动页面的时候会有一种“跳”的感觉，用户体验不好。</p><p>但是如果固定高度，限制最大width，在遇到宽度比高度要大很多的长方形商品图，会变形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">6.06rem</span>;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a9ad522668485?w=420&amp;h=367&amp;f=png&amp;s=104854" alt="css"></p><p>可以调整为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">6.06rem</span>;</span><br><span class="line">    <span class="attribute">object-fit</span>: contain;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a9adeb4b4e525?w=446&amp;h=369&amp;f=png&amp;s=81318" alt="end"></p><h2 id="cover"><a href="#cover" class="headerlink" title="cover"></a>cover</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">   <span class="attribute">object-fit</span>: cover;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b1efc99dadc5d?w=880&amp;h=415&amp;f=png&amp;s=625234" alt="cover"></p><p>从左到右展示， img空元素  原始图片 img按照cover填充了原始图片之后 </p><p>图片的宽高比没变，但是多余的部分被裁剪掉了</p><h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">   <span class="attribute">object-fit</span>: none;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;img src="https://www.bldimg.com/eshop/photos/1535623413_43938.jpg?imageView2/0/w/250" alt=""&gt;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b1f220321414c?w=904&amp;h=408&amp;f=png&amp;s=587489" alt="none"></p><p>从左到右展示， img空元素  原始图片 img按照none填充了原始图片之后 </p><blockquote><p>被替换的内容大小<strong>保持其宽高比</strong> 并且尺寸不变</p></blockquote><p>由于这里的图片源宽度(250px)是小于img的设置宽度(300px), 图片完整的展示到img盒子中</p><p>找一个图片源大于盒子本身大小的</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b1fa00f269c13?w=926&amp;h=490&amp;f=png&amp;s=871326" alt="none"></p><p>从左到右展示， img空元素  原始图片 img按照none填充了原始图片之后 </p><p>原始图片大小 576 x 636</p><p>none 好像是选取了原始图中一块 300 x 300的区域大小的资源块 填充到Img盒子</p><table><thead><tr><th>图片源和Img盒子大小对比</th><th>结果</th></tr></thead><tbody><tr><td>图片源 &gt;  Img盒子</td><td>选取图片源一块进行填充</td></tr><tr><td>图片源 &lt;  Img盒子</td><td>完整展示</td></tr></tbody></table><h2 id="scale-down"><a href="#scale-down" class="headerlink" title="scale-down"></a>scale-down</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">   <span class="attribute">object-fit</span>: scale-down;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p> scale-down的表现形式取决于 图片源 与 Img盒子 的大小</p><p> 如果  图片源 大于 Img盒子，其呈现结果和 contain 一样，保持图片源宽高比进行填充</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b202c210c3026?w=839&amp;h=374&amp;f=png&amp;s=630571" alt="scale-down"></p><p>如果  图片源 小于 Img盒子, 其呈现结果和 none 一样，直接展现图片</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b206c01103413?w=815&amp;h=377&amp;f=png&amp;s=479489" alt="scale-down"></p><h2 id="object-fit-的作用"><a href="#object-fit-的作用" class="headerlink" title="object-fit 的作用"></a>object-fit 的作用</h2><p>在使用了object-fit的img元素，就像一个盒子，根据object-fit的属性值，填充真正的图片源</p><p>也就是设置了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">   <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这些大小的限制是对于 img盒子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object-fit: xxx;</span><br></pre></td></tr></table></figure><p>这个属性是用于处理真正展示的图片源，也就是控制最后呈现的图片源的样式</p><h2 id="Object-position"><a href="#Object-position" class="headerlink" title="Object-position"></a>Object-position</h2><p>Object-position 可以按照 background-position 理解，用来决定替换资源的展示位置</p><p><a href="http://www.w3school.com.cn/cssref/pr_background-position.asp" target="_blank" rel="noopener">w3c 对于 background-position 的解释</a></p><p>可以简单理解为，你在Img盒子的哪个位置开始放置背景图 （相对于左上角）</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b20acc536f0e1?w=831&amp;h=489&amp;f=png&amp;s=74604" alt="background-position"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">  <span class="attribute">object-position</span>: <span class="number">150px</span> <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">100px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b2160fbd4df91?w=922&amp;h=389&amp;f=png&amp;s=343607" alt="position"></p><p>object-position设置为img盒子的一半, 三个图片的展示样式</p><h2 id="应用于video"><a href="#应用于video" class="headerlink" title="应用于video"></a>应用于video</h2><p>在处理video元素播放的时候，我们经常能看到视频会自动补充黑边</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">src</span>=<span class="string">"。。。"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">src</span>=<span class="string">"。。。"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">100px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgb</span>(207, 154, 94);</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(143, 131, 120);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="selector-tag">video</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b22b88f7d5ff9?w=704&amp;h=444&amp;f=png&amp;s=350513" alt="PC"></p><p>虽然这里已经写了video元素设置为父级盒子大小，但是里面的视频源在播放的时候，并没有按照想要的占据全屏</p><p>加入object-fit属性处理一下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">video</span> &#123;</span><br><span class="line">  <span class="attribute">object-fit</span>: fill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b27ea8f376b76?w=572&amp;h=376&amp;f=png&amp;s=322574" alt="pbject-fit"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>补充一些 video 的知识 </li></ul><p><a href="https://mengxxself.github.io/2017/10/24/video%E5%92%8Caudio%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E8%A1%A8%E7%8E%B0/" target="_blank" rel="noopener">video 和 audio在移动端的表现</a></p><ul><li><p><a href="https://www.jianshu.com/p/8c17967adee7" target="_blank" rel="noopener">阻止视频在移动端页面中全屏播放</a></p></li><li><p><a href="https://www.zhangxinxu.com/wordpress/2015/03/css3-object-position-object-fit/" target="_blank" rel="noopener">半深入理解CSS3 object-position/object-fit属性</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
            <tag> video </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react组件Video</title>
      <link href="/2018/09/06/react%E7%BB%84%E4%BB%B6Video/"/>
      <url>/2018/09/06/react%E7%BB%84%E4%BB%B6Video/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165ade59d09be085?w=1412&amp;h=616&amp;f=png&amp;s=1455389" alt="video"></p><blockquote><p>写一个很简单的video组件</p></blockquote><a id="more"></a><p>之前的一篇文章讨论了 video元素 的使用</p><p><a href="https://mengxxself.github.io/2017/10/24/video%E5%92%8Caudio%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E8%A1%A8%E7%8E%B0/" target="_blank" rel="noopener">video 和 audio在移动端的表现</a></p><p>可以看到在iOS和Android两种系统对于video控件的支持很不一样，在展示控制组件的时候，两者差别很大</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165adfb2a41884ee?w=667&amp;h=487&amp;f=png&amp;s=295192" alt="vs"></p><p>左侧为iOS, 其控件要比Android多</p><p>ISO有提供一个全屏播放的按钮，就是左上角的那个，当点击会进入下图右侧状态。当在点击关闭，会恢复到左侧状态</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165adf8dd1ae98c6?w=612&amp;h=465&amp;f=png&amp;s=267705" alt="vs"></p><p>然后产品同学表示，希望可以实现设备同步</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165ae0086461647f?w=646&amp;h=447&amp;f=png&amp;s=192550" alt="do"></p><p>之后向其解释了video的展示样式是基于设备浏览器的，无法进行控制，比如关闭iOS的全屏按钮，于是就这么处理了</p><p>后面提测之后看这里的代码，因为需求不复杂，决定写个小组件，实现 播放，暂停，进度展示 这三个功能</p><h2 id="组件结构"><a href="#组件结构" class="headerlink" title="组件结构"></a>组件结构</h2><p>1 video </p><p>2 底部控制条</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;video/&gt;</span><br><span class="line">  &lt;controller/&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>video元素 不添加 controls 不展示本身的控件</p><h2 id="事件控制"><a href="#事件控制" class="headerlink" title="事件控制"></a>事件控制</h2><h3 id="onloadedmetadata"><a href="#onloadedmetadata" class="headerlink" title="onloadedmetadata"></a>onloadedmetadata</h3><p>在获取视频总时长的时候，一直拿到的空值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="keyword">this</span>.video</span><br><span class="line">  <span class="keyword">const</span> time = target.duration || <span class="number">0</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怀疑是不是因为这个 target 对象 获取的是空, 然后在添加了console，在控制台是可以看到的，查阅资料有人说这个因为视频资源数据没有被加载</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165ae0e042d85c34?w=795&amp;h=202&amp;f=png&amp;s=121115" alt="load"></p><table><thead><tr><th>事件</th><th>触发机制</th></tr></thead><tbody><tr><td>loadeddata</td><td>当当前帧的数据已加载，但没有足够的数据来播放指定音频/视频的下一帧时，会发生 loadeddata 事件</td></tr><tr><td>loadedmetadata</td><td>当指定的音频/视频的元数据已加载时，会发生 loadedmetadata 事件</td></tr></tbody></table><p>音频/视频的元数据包括：时长、尺寸（仅视频）以及文本轨道</p><p>所以调整为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="keyword">this</span>.video</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取视频总时长</span></span><br><span class="line">  target.onloadedmetadata = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: target.duration &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ontimeupdate"><a href="#ontimeupdate" class="headerlink" title="ontimeupdate"></a>ontimeupdate</h3><table><thead><tr><th>事件</th><th>触发机制</th></tr></thead><tbody><tr><td>timeupdate</td><td>在音频/视频（audio/video）的播放位置发生改变时触发</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target.ontimeupdate = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; currentTime, duration &#125; = target</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">move</span>: currentTime, <span class="attr">width</span>: currentTime / duration &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个事件用于处理展示视频进度</p><h2 id="控制栏"><a href="#控制栏" class="headerlink" title="控制栏"></a>控制栏</h2><p>调整之后，iOS  Android 在微信中的表现</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165ae7a26a512986?w=301&amp;h=433&amp;f=png&amp;s=143203" alt="control"></p><p>只有进度条，播放按钮</p><p>但是进入浏览器环境，发现还是有那个控制组件, 虽然并没有使用controls属性，也会显示控件</p><p>后面查询文章，说在浏览器中无法处理这个问题</p><p>有的人想的办法是，将视频设置的大一点，把自带的控件放在屏幕之外，这样用户就看不到了</p><h2 id="poster"><a href="#poster" class="headerlink" title="poster"></a>poster</h2><p>video组件有设置 点击之后立即播放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放视频</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> videoPlay = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>)</span><br><span class="line">  video &amp;&amp; video.play()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个执行的时候，能看到黑屏展示</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165aeb4c78796f9b?w=307&amp;h=475&amp;f=png&amp;s=70669" alt="poster"></p><p>给video元素添加一个poster属性, 这样会使用封面图填充缓冲时间</p><blockquote><p>poster 属性指定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像</p></blockquote><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p><a href="https://github.com/mengxxSELF/Video" target="_blank" rel="noopener">项目Git地址</a></p><p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165ae0fe2d742de5?w=504&amp;h=340&amp;f=png&amp;s=103725" alt="progress"></p><ul><li><a href="https://segmentfault.com/a/1190000006857675" target="_blank" rel="noopener">html5–移动端视频video的android兼容，去除播放控件、全屏等</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 轮子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> video </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>moment.js使用</title>
      <link href="/2018/09/04/moment-js%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/04/moment-js%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a3684f26f1a8f?w=1442&amp;h=652&amp;f=png&amp;s=380462" alt="moment"></p><blockquote><p>moment.js 使用笔记 </p></blockquote><a id="more"></a><h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = moment()</span><br><span class="line"><span class="keyword">let</span> date = now.date() <span class="comment">// 或者 now.dates()  这个是当月哪一日</span></span><br><span class="line"><span class="keyword">let</span> hour = now.hour() <span class="comment">// 或者 now.hours()</span></span><br><span class="line"><span class="keyword">let</span> minute = now.minute() <span class="comment">// 或者 now.minutes()</span></span><br></pre></td></tr></table></figure><h2 id="时间日期进行格式化"><a href="#时间日期进行格式化" class="headerlink" title="时间日期进行格式化"></a>时间日期进行格式化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> day = moment().format(<span class="string">'YYMMDD'</span>)</span><br></pre></td></tr></table></figure><p>输出什么样的格式可以之间在这里定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">YYMMDD  <span class="number">170315</span></span><br><span class="line">YY-MM-DD <span class="number">17</span><span class="number">-03</span><span class="number">-15</span></span><br><span class="line">YYMMDD <span class="number">20170315</span></span><br><span class="line">YYMMDD HH-mm-ss <span class="number">170315</span> <span class="number">20</span>:<span class="number">23</span>:<span class="number">21</span></span><br></pre></td></tr></table></figure><h3 id="注意大小写是有区别的"><a href="#注意大小写是有区别的" class="headerlink" title="注意大小写是有区别的"></a>注意大小写是有区别的</h3><p>HH 这种形式的获取的是24小时的时间 </p><p>hh是12小时制的 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">YYMMDD hh-mm-ss <span class="number">170315</span> <span class="number">04</span>:<span class="number">23</span>:<span class="number">21</span></span><br></pre></td></tr></table></figure><h2 id="获取相对时间"><a href="#获取相对时间" class="headerlink" title="获取相对时间"></a>获取相对时间</h2><p>有的时候项目考虑到时区问题或者数据展示  比如在每一天的00：00-05：00进行数据展示 展示的是昨天的数据</p><p>此时就需要一个时间参数来表示昨天</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> today = moment()</span><br><span class="line"><span class="keyword">let</span> yesterday = moment().subtract(<span class="number">1</span>,<span class="string">'day'</span>)</span><br></pre></td></tr></table></figure><p>获取第二天</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tomorrow = moment().add(<span class="number">1</span>,<span class="string">'days'</span>)</span><br></pre></td></tr></table></figure><h2 id="时间戳转化"><a href="#时间戳转化" class="headerlink" title="时间戳转化"></a>时间戳转化</h2><p>时间转为时间戳</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment(<span class="string">'2018-09-01 22:00'</span>).unix()</span><br></pre></td></tr></table></figure><p>获取当前时间的时间戳</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">moment().format(<span class="string">'X'</span>)  </span><br><span class="line">moment().format(<span class="string">'x'</span>) </span><br><span class="line">moment().valueOf()</span><br></pre></td></tr></table></figure><p>时间戳转为时间</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment.unix(时间戳).format(<span class="string">'YYYYMMDD'</span>)</span><br></pre></td></tr></table></figure><h2 id="是否处于某个时间段内"><a href="#是否处于某个时间段内" class="headerlink" title="是否处于某个时间段内"></a>是否处于某个时间段内</h2><p>只有当用户注册时间在2017-3-10之间注册的才能参加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> time = moment(user.loginTime).isBefore(<span class="string">'2017-3-10 00:00:00'</span>)</span><br></pre></td></tr></table></figure><p>是否相同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().isSame(<span class="string">'2010-10-20'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>是否之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment().isAfter(<span class="string">'2010-10-19 12:30:00'</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="注意有坑"><a href="#注意有坑" class="headerlink" title="注意有坑"></a>注意有坑</h2><ul><li>当前是第几周</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> week = moment().isoWeeks()</span><br></pre></td></tr></table></figure><p>注意 文档里还有一个 获取周的API是 moment().week()</p><p>这两个API是有区别的，下面的 week 那个的一周 是从 周末到周六 算一周，和平时理解的一周不同</p><h2 id="QUESTION"><a href="#QUESTION" class="headerlink" title="QUESTION"></a>QUESTION</h2><ul><li>今日</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const yesterday = moment().subtract(1, &apos;days&apos;).format(&apos;YYYYMMDD&apos;)</span><br><span class="line">const day = moment().format(&apos;YYYYMMDD&apos;)</span><br></pre></td></tr></table></figure><ul><li>本周</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 年份</span><br><span class="line">const year = moment().format(&apos;YYYY&apos;)</span><br><span class="line">// 当前周是第几周</span><br><span class="line">const week = moment().isoWeeks()</span><br><span class="line"></span><br><span class="line">const start = moment().isoWeekday(1).format(&apos;YYYYMMDD&apos;)</span><br><span class="line">const end = moment().isoWeekday(7).format(&apos;YYYYMMDD&apos;)</span><br></pre></td></tr></table></figure><ul><li>本月</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const month = moment().format(&apos;YYYYMM&apos;)</span><br><span class="line"></span><br><span class="line">const start = moment().startOf(&apos;month&apos;).format(&apos;YYYYMMDD&apos;)</span><br><span class="line">const end = moment().endOf(&apos;month&apos;).format(&apos;YYYYMMDD&apos;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 第三方插件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每日一练第五期</title>
      <link href="/2018/09/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E4%BA%94%E6%9C%9F/"/>
      <url>/2018/09/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E4%BA%94%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/6/165acc06337cb082?w=1294&amp;h=548&amp;f=png&amp;s=271617" alt="test"></p><blockquote><p>cookie + url + 优化</p></blockquote><a id="more"></a><h2 id="Q-请说说cookie，localStorage，sessionStorage，indexDB-之间的区别的使用场景"><a href="#Q-请说说cookie，localStorage，sessionStorage，indexDB-之间的区别的使用场景" class="headerlink" title="Q: 请说说cookie，localStorage，sessionStorage，indexDB 之间的区别的使用场景?"></a>Q: 请说说cookie，localStorage，sessionStorage，indexDB 之间的区别的使用场景?</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>cookie: 两种使用方式， 一种方法是把值保存在浏览器的变量中 , 当浏览器关闭时结束 , 另一种方法是保存在硬盘中 , 只要时间不过期 , 下次还可使用</p><p>localStorage: 关闭浏览器还会存在，除非清除</p><p>sessionStorage: 窗口级别的，关闭浏览器则清除</p><h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><h2 id="Q-写一个函数find-missing-A-low-high-，给定一个范围-low-high-，寻找一个数组中缺失的元素。"><a href="#Q-写一个函数find-missing-A-low-high-，给定一个范围-low-high-，寻找一个数组中缺失的元素。" class="headerlink" title="Q: 写一个函数find_missing(A, low, high)，给定一个范围[low,high]，寻找一个数组中缺失的元素。"></a>Q: 写一个函数find_missing(A, low, high)，给定一个范围[low,high]，寻找一个数组中缺失的元素。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find_missing([<span class="number">10</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>], <span class="number">10</span>, <span class="number">15</span>) <span class="comment">// [13,14]</span></span><br><span class="line"><span class="comment">// 注: low=10 high = 15</span></span><br><span class="line"></span><br><span class="line">find_missing([<span class="number">1</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">51</span>, <span class="number">15</span>],<span class="number">50</span>, <span class="number">55</span>) <span class="comment">// [50, 52, 53, 54]</span></span><br><span class="line"><span class="comment">// 注：low = 50, hight = 55</span></span><br></pre></td></tr></table></figure><h3 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> find_missing = <span class="function">(<span class="params">ary, low, high</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> noAry = []</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ary.includes(low)) &#123;</span><br><span class="line">      noAry.push(low)</span><br><span class="line">    &#125;</span><br><span class="line">    low++</span><br><span class="line">  &#125; <span class="keyword">while</span> (low &lt; high)</span><br><span class="line">  <span class="keyword">return</span> noAry</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q：请说出从输入网址点击回城以后-浏览器发生了什么"><a href="#Q：请说出从输入网址点击回城以后-浏览器发生了什么" class="headerlink" title="Q：请说出从输入网址点击回城以后 浏览器发生了什么"></a>Q：请说出从输入网址点击回城以后 浏览器发生了什么</h2><h3 id="个人理解-2"><a href="#个人理解-2" class="headerlink" title="个人理解"></a>个人理解</h3><p>1 查询本地域名服务器</p><p>2 查找IP地址</p><p>3 根据IP地址访问服务器</p><p>4 获取资源 返回给浏览器</p><h3 id="Answer-1"><a href="#Answer-1" class="headerlink" title="Answer"></a>Answer</h3><ol><li>用户输入URL地址</li><li>浏览器解析URL解析出主机名</li><li>浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）</li><li>浏览器将端口号从URL中解析出来</li><li>浏览器建立一条与目标Web服务器的TCP连接（三次握手）</li><li>浏览器向服务器发送一条HTTP请求报文</li><li>服务器向浏览器返回一条HTTP响应报文</li><li>关闭连接 浏览器解析文档</li><li>如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕</li></ol><p>渲染的基本流程</p><ol><li>HTML解析出DOM Tree</li><li>CSS解析出Style Rules</li><li>将二者关联生成Render Tree</li><li>Layout 根据Render Tree计算每个节点的信息</li><li>Painting 根据计算好的信息绘制整个页面</li></ol><p>补充: 我们都知道，js脚本会造成页面解析和渲染的阻塞，那么CSS呢</p><p><a href="https://juejin.im/post/5b88ddca6fb9a019c7717096" target="_blank" rel="noopener">css加载会造成阻塞吗</a></p><h2 id="Q：谈谈你对前端资源下载性能优化的经验和思考"><a href="#Q：谈谈你对前端资源下载性能优化的经验和思考" class="headerlink" title="Q：谈谈你对前端资源下载性能优化的经验和思考?"></a>Q：谈谈你对前端资源下载性能优化的经验和思考?</h2><h3 id="个人理解-3"><a href="#个人理解-3" class="headerlink" title="个人理解"></a>个人理解</h3><p>减少没必要的图片，JS，CSS以及HTML等，对文件进行压缩优化，开启GZIP压缩传输内容</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>每日一练第四期</title>
      <link href="/2018/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E5%9B%9B%E6%9C%9F/"/>
      <url>/2018/08/29/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E5%9B%9B%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/30/1658a93daf32ec57?w=1326&amp;h=604&amp;f=png&amp;s=312895" alt="Test"></p><blockquote><p>webpack + generator</p></blockquote><a id="more"></a><h2 id="Q-如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？"><a href="#Q-如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？" class="headerlink" title="Q: 如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？"></a>Q: 如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？</h2><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>确定是不是用户设备: 使用多个设备调试</p><p>确定浏览器: 清除浏览器缓存 换个浏览器尝试</p><h2 id="Q-service-workers-是什么"><a href="#Q-service-workers-是什么" class="headerlink" title="Q: service workers 是什么"></a>Q: service workers 是什么</h2><h3 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h3><h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><h2 id="Q-webpack-对于项目的优化"><a href="#Q-webpack-对于项目的优化" class="headerlink" title="Q: webpack 对于项目的优化"></a>Q: webpack 对于项目的优化</h2><h3 id="个人理解-2"><a href="#个人理解-2" class="headerlink" title="个人理解"></a>个人理解</h3><p>1 可以处理按需加载</p><p>2 可以对图片，代码进行压缩</p><p>3 通过设置第三方库为全局引用，可以减少项目打包后的资源大小</p><p>4 抽取公共库</p><h3 id="Answer-1"><a href="#Answer-1" class="headerlink" title="Answer"></a>Answer</h3><ol><li>缩小文件搜索范围,配置比如resolve.modules,resolve.modules,resolve.mainFields,resolve.alias ,resolve.extensions ,module.noParse 配置</li><li>使用DllPlugin 要给 Web 项目构建接入动态链接库<br>3.HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程<br>4.当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成<br>5.可以监听文件的变化，当文件发生变化后可以自动刷新浏览器，从而提高开发效率。<br>6.(Hot Module Replacement)的技术可在不刷新整个网页的情况下做到超灵敏的实时预览。 原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块。<br>7.Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码。它依赖静态的 ES6 模块化语法，例如通过 import 和 export 导入导出<br>8.可以使用CommonsChunkPlugin 把多个页面公共的代码抽离成单独的文件进行加载<br>9.Webpack 内置了强大的分割代码的功能去实现按需加载，可以用import实现路由按需加载。<br>10.Scope Hoisting 可以让 Webpack 打包出来的代码文件更小、运行的更快， 它又译作 “作用域提升”<br>11.可以使用可视化分析工具 Webpack Analyse等去分析输出结果，从页进行优化.</li><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩<br>13.优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ol><h2 id="Q-generator-的实现原理"><a href="#Q-generator-的实现原理" class="headerlink" title="Q: generator 的实现原理"></a>Q: generator 的实现原理</h2><h3 id="个人理解-3"><a href="#个人理解-3" class="headerlink" title="个人理解"></a>个人理解</h3><p>generator 其实就是一个迭代器生成函数</p><p>generator执行后返回的是一个 迭代器对象，通过调用next方法来改变指针位置，每次移动到yield位置处</p><h3 id="Answer-2"><a href="#Answer-2" class="headerlink" title="Answer"></a>Answer</h3><p>使用 * 表示这是一个 Generator 函数<br>内部可以通过 yield 暂停代码<br>通过调用 next 恢复执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = test();</span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>从以上代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      next: <span class="number">0</span>,</span><br><span class="line">      stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q-什么是-IFC，IFC的作用是什么"><a href="#Q-什么是-IFC，IFC的作用是什么" class="headerlink" title="Q: 什么是 IFC，IFC的作用是什么"></a>Q: 什么是 IFC，IFC的作用是什么</h2><h3 id="个人理解-4"><a href="#个人理解-4" class="headerlink" title="个人理解"></a>个人理解</h3><p>IFC则是表示盒子从左到右的水平排列方式</p><p>他的高度也许比包含在它内最高的盒子高</p><h2 id="Q-什么是跨域，如果处理跨域问题"><a href="#Q-什么是跨域，如果处理跨域问题" class="headerlink" title="Q: 什么是跨域，如果处理跨域问题"></a>Q: 什么是跨域，如果处理跨域问题</h2><h3 id="个人理解-5"><a href="#个人理解-5" class="headerlink" title="个人理解"></a>个人理解</h3><p>根据浏览器的同源策略，协议，域名，端口不一致的情况下，不可以调用彼此的对象数据等信息</p><p>常用的处理跨域的方式</p><p>1 JSONP 通过URL中添加回调函数</p><p>2 如果是子域名的关系，可以考虑设置cookie 来传递数据</p><p>3 CORS 需要服务端做处理</p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>有趣的tips</title>
      <link href="/2018/08/11/%E6%9C%89%E8%B6%A3%E7%9A%84tips/"/>
      <url>/2018/08/11/%E6%9C%89%E8%B6%A3%E7%9A%84tips/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1659022b84159eb5?w=1354&amp;h=544&amp;f=png&amp;s=43243" alt="tips"></p><blockquote><p>在阅读文章的时候，一些有意思的知识点</p></blockquote><a id="more"></a><h2 id="react中请求数据为什么在-componentDidMount-这个生命周期"><a href="#react中请求数据为什么在-componentDidMount-这个生命周期" class="headerlink" title="react中请求数据为什么在 componentDidMount 这个生命周期"></a>react中请求数据为什么在 componentDidMount 这个生命周期</h2><p>componentWillMount -&gt; render -&gt; componentDidMount</p><p>如果在 componentWillMount 中做请求，setState 不会引起重新render （如果强制render？）</p><p>并且在react16中，componentWillMount 可能会被调用好多次</p><h2 id="overflow-y"><a href="#overflow-y" class="headerlink" title="overflow-y"></a>overflow-y</h2><p>iOS中 使用overflow-y: scroll; 导致滚动卡顿 </p><ul><li><p><a href="https://segmentfault.com/q/1010000007323949" target="_blank" rel="noopener">overflow-scroll</a></p></li><li><p><a href="https://segmentfault.com/a/1190000012014962" target="_blank" rel="noopener">scroll</a></p></li></ul><h2 id="回流-重绘"><a href="#回流-重绘" class="headerlink" title="回流 重绘"></a>回流 重绘</h2><ul><li><p><a href="http://caibaojian.com/css-reflow-repaint.html" target="_blank" rel="noopener">article</a></p></li><li><p><a href="https://segmentfault.com/a/1190000017491520" target="_blank" rel="noopener">reflow</a></p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据上面的结论</span></span><br><span class="line"><span class="comment"> * 将 2d transform 换成 3d</span></span><br><span class="line"><span class="comment"> * 就可以强制开启 GPU 加速</span></span><br><span class="line"><span class="comment"> * 提高动画性能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate(<span class="number">10</span>px, <span class="number">10</span>px);</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">  transform: translate3d(<span class="number">10</span>px, <span class="number">10</span>px, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> js </tag>
            
            <tag> ndoe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每日一练第二期</title>
      <link href="/2018/08/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E4%BA%8C%E6%9C%9F/"/>
      <url>/2018/08/06/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E4%BA%8C%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/30/1658a97bc1e2ec6f?w=1404&amp;h=678&amp;f=png&amp;s=692482" alt="Test"></p><blockquote><p>cookie + xss + csrf</p></blockquote><a id="more"></a><h2 id="Q-cookie"><a href="#Q-cookie" class="headerlink" title="Q: cookie"></a>Q: cookie</h2><p>电商网站A和电影票网站B合作，A的用户，可以通过A网站下单购买电影票，之后跳转跳转到B（不需要登录）去选座位。</p><p>如果A、B是同域名，比如 a.domain.com, b.domain.com 能不能共享cookie? 如果不同域如何处理？</p><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><p>根据浏览器同源策略，同域名和同端口可以共享cookie。如果不设置 Domain 参数，则cookie只存在于当前URL的所在域名。</p><p>如果A、B是同域名，可以设置Domain 参数为ab的父级域名，这样就可以传递cookie了</p><p>如果a，b 不同域，可以在跳转到b网站的时候，携带A用户的某些信息，比如用户id，在跳转到B 的时候 根据用户id拿到该用户的某些信息。</p><h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><ul><li><p>怎么设置第三方cookie。比如在网站A，那么网站B的cookie如何进入</p></li><li><p>网站A去请求自己的服务端，为什么不可以携带网站B的cookie</p></li></ul><p>其实请求网站B的一个图片资源或者接口，都有可能被写cookie。所以第三方很容易写入cookie。比如在服务端通过设置Header什么的。但是问题是，这个cookie写了是传不到A的网站上去的。</p><p>A, B如果同属于某一个父级的子级域名  设置一级域名的cookie 就可以被子级域名所复用</p><h2 id="Q：什么是XSS攻击-如何防御"><a href="#Q：什么是XSS攻击-如何防御" class="headerlink" title="Q：什么是XSS攻击? 如何防御?"></a>Q：什么是XSS攻击? 如何防御?</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。</p><ul><li>如何防御</li></ul><p>最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义。</p><p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p><p>内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p><p>我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。</p><p>通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP</p><p>只允许加载本站资源， 只允许加载 HTTPS 协议图片，加载任何来源框架</p><h2 id="Q：-CSRF攻击是什么，如何防御"><a href="#Q：-CSRF攻击是什么，如何防御" class="headerlink" title="Q： CSRF攻击是什么，如何防御"></a>Q： CSRF攻击是什么，如何防御</h2><p>### </p><h2 id="Q-如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？"><a href="#Q-如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？" class="headerlink" title="Q: 如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？"></a>Q: 如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？</h2><h3 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h3><p>判断是否是设备问题非常简单，多次更换设备尝试即可。判断是不是CDN问题，可以直接出问题的资源，看看有没有什么报错提示。或者访问下其余使用这个CDN的资源是不是有问题。</p><h2 id="Q-请说说在-hybrid-端实现类似原生般流畅的体验，要注意哪些事项"><a href="#Q-请说说在-hybrid-端实现类似原生般流畅的体验，要注意哪些事项" class="headerlink" title="Q: 请说说在 hybrid 端实现类似原生般流畅的体验，要注意哪些事项"></a>Q: 请说说在 hybrid 端实现类似原生般流畅的体验，要注意哪些事项</h2><ul><li>资源加载</li></ul><p>在后台先打开  离线静态资源下载</p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>每日一练第一期</title>
      <link href="/2018/07/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E4%B8%80%E6%9C%9F/"/>
      <url>/2018/07/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC%E4%B8%80%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/30/1658a9d289c1e11b?w=1210&amp;h=508&amp;f=png&amp;s=31924" alt="Test"></p><blockquote><p>08-03 – flex </p></blockquote><a id="more"></a><h2 id="Q-flex-布局和传统布局的不同"><a href="#Q-flex-布局和传统布局的不同" class="headerlink" title="Q: flex 布局和传统布局的不同"></a>Q: flex 布局和传统布局的不同</h2><p>传统布局，基于盒模型，依赖 display属性 、position属性 、float属性，而FLEX用来为盒状模型提供最大的灵活性,不强制要求子元素的大小,任何一个容器都可以指定为 Flex 布局,可以简便、完整、响应式地实现各种页面布局。</p><h2 id="Q-如何比较两个颜色的差值"><a href="#Q-如何比较两个颜色的差值" class="headerlink" title="Q: 如何比较两个颜色的差值"></a>Q: 如何比较两个颜色的差值</h2><h3 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h3><p>利用第三方插件 nodejs-color-model 将格式为十六进制需要转化为rgba格式，然后R G B 三个颜色通道的数值各自做减法</p><ul><li>第三方库直接计算差值</li></ul><p>nodejs-color-difference</p><h3 id="answer"><a href="#answer" class="headerlink" title="answer"></a>answer</h3><p>首先将颜色拆分成r/g/b三个值，如果是字符串的颜色如#aabbff或者rgb(255,128,100)可以用正则表达式取出对应的r/g/b值。对于16进制字符串，可以使用parseInt(‘0xaa’)转10进制整数。</p><p>然后对于两个颜色，可以使用距离</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sqrt( (r1-r2) *(r1-r2) +(g1-g2)*(g1-g2)+(b1-b2)*(b1-b2) )</span><br></pre></td></tr></table></figure><p>进行比较， 距离近则相似。 当然可以用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.hypot( r1-r2, g1-t2, b1-b2)</span><br></pre></td></tr></table></figure><p>来简化上述运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.hypot() <span class="comment">// 函数返回它的所有参数的平方和的平方根</span></span><br></pre></td></tr></table></figure><h2 id="Q-单页面应用"><a href="#Q-单页面应用" class="headerlink" title="Q: 单页面应用"></a>Q: 单页面应用</h2><p>一个单页面应用，有6张页面，F、E、A、B、C、D。 页面ABCD构成了一个冗长的用户验证过程。目前A、B、C对应用户验证过程的第1步，第2步，第3步。 页面F是首页，E是某张业务相关页面。用户到达页面E后，系统发现用户没有认证，触发验证流程，到达页面A，然后开始A-&gt;B-&gt;C-&gt;D流程。 页面D是验证结果页面（验证成功页面）。 请问，如果到达页面D后，如何让用户点击返回可以返回页面F，而忽略中间流程（注：用户可能根本没有到达过F，比如微信分享直接进入了E</p><p>补充下： 场景是上述场景，最好能做到到达页面D后，浏览器自然返回是F，再按返回，单页面系统退出；</p><p>另外请思考下各个流程如何实现流畅切换，不会有中间闪烁的页面</p><h3 id="个人思路-1"><a href="#个人思路-1" class="headerlink" title="个人思路"></a>个人思路</h3><p>这种单页面应用在react项目中非常常见也很容易处理，直接变更页面哈希值就可以实现页面回退并且用户体验非常好。</p><p>如果不是框架的话，又不确定刘浏览器中是否有首页历史记录，那只想到了页面重新刷新了。</p><p>而且两种方式都需要注意的是，在返回到首页的时候，已经完成了用户登录行为，所以要保存用户状态，可以考虑jwt来处理鉴权</p><h2 id="Q-算法"><a href="#Q-算法" class="headerlink" title="Q: 算法"></a>Q: 算法</h2><p>一个无序正负项 数组，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, -6, 123, -945, -231, 112]</span><br></pre></td></tr></table></figure><p>找出其中的最大的连续子序列</p><p>有如下乱序数组 A1, A2, A3, A4,……..An, 求 i, j (1&lt;= i &lt;= j&lt;= n), 使得Ai +  …. + Aj 和最大, 输出i j</p><h3 id="answer-1"><a href="#answer-1" class="headerlink" title="answer"></a>answer</h3><p>1）最简单也最暴力的解法：首先列出 所有的子序列，然后找出其中和最大的 即可；<br>实现思路：一个 记录当前最大值的变量maxSum；一个 子序列开始和结束的游标 变量；一个 当前子序列的和 的暂存变量，我们称之为 currentSum 或者 tmpSum（下文中 使用currentSum）<br>找到所有的 子序列 我们可以通过两层循环的方式来解决<br>第一层循环 i 从 0~ length-1;<br>第二层循环 j 从 i ~ length - 1;<br>这样的循环里 就可以找到所有的子序列了<br>下一步 我们是要计算出所有子序列的和<br>最简单的办法 就是 第三层循环从 i ~ j 累加求出和 然后求出来的每个和  和 maxSum 去比较，如果比maxSum 大 就替换</p><p>伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxSum = maxSum &lt; currentSum ? currentSum : maxSum;</span><br></pre></td></tr></table></figure><p>三层循环结束后 maxSum就是我们要 求的解<br>return maxSum即可<br>这个算法的时间复杂度是O(n^3);</p><p>2）简化解法：我们在第二层循环中，我们已经知道 当前的 i/j之前的方法是在第三层的循环中 计算 i ~ j 的和<br>现在 我们在第二层中 在进入第二层之前 我们重置一下currentSum<br>第一次循环 是 i ~ i 当前我们就把 i 的值 记录到 currentSum去跟 maxSum 对比 然后 maxSum = maxSum &lt; currentSum ? currentSum : maxSum;<br>第二次循环 是 i ~ i + 1 我们就把 当前的 i+1 累加到currentSum 这时候的 currentSum就是 i ~ i+1 的值，再去跟maxSum去比 然后 maxSum = maxSum &lt; currentSum ? currentSum : maxSum;<br>以此类推<br>第二层的循环中 就可以 计算出 以当前 i 开头的子序列中 最大的子序列是多少<br>现在我们看回 到 第一层循环 i 的取值 是从 0 ~ length-1 那么我们是不是 可以找到 i 从 0 ~ length-1 所有的子序列中和最大的</p><p>伪代码思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一层 i (0 ~ length-1)</span><br><span class="line">  currentSum 清零</span><br><span class="line">    第二层 j(i ~ length-1)</span><br><span class="line">        currentSum 累加</span><br><span class="line">        maxSum = maxSum &lt; currentSum ? currentSum : maxSum;</span><br><span class="line">return maxSum;</span><br></pre></td></tr></table></figure><p>算法的时间复杂度是 O(n^2)</p><p>3）demo数组：[-2, 1, -3, 4, -1, 2 , 1, -5, 4]</p><p>首先 我们可以简单的简化一下 这个数组把相邻的同 正负的数字合起来，因为同符号的连续数 一定会同时存在在最大子序列里<br>比如 [-1, -2, -3, 1, 2, 13] 那跟 [-6, 16] 是没有区别的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-2, 1, -3, 4, -1, 2, 1, -5, 4] ==&gt; [-2, 1, -3, 4, -1, 3, -5, 4]</span><br></pre></td></tr></table></figure><p>然后 我们从头开始看 -2 这是第一个元素  那么 我们认为 当前的 最大子序列和 就是 -2<br>然后 发现了一个正数 1 那我们可以确定 -2 一定不包含在 我们的最大子序列中<br>也就是说 数组开头 如果是负数 可以忽略过去</p><p>现在 我们的数组 变成了 [1, -3, 4, -1, 3, -5, 4] 同理 结尾的如果是 负数 也不需要考虑</p><p>现在我们的数组 变成了 [1, -3, 4, -1, 3, -5, 4]</p><p>我们继续，现在 第一个元素是 1 最大和 是1 然后下一个数是 -3<br>那么 -3 对 1 这个数 起到了阻断作用 也就是说 -3 把 前边所有正数 积累的能量都磨平了 甚至还变成了一个负数 那么 -3 我们称之为 一个阻断</p><p>当前的 最大和 还是 1 现在 我们到了 4 那么现在的最大值 就是4<br>我们继续向下看</p><p>下个数字是 -1 之前最大的和是 4 加起来之后是 3 影响并不大 我们继续带着他 向后看</p><p>下一个 是个正数 3 也就是 4 -1 3 这样的情况</p><p>我们是不是可以认为 这个 -1 虽然降低了 和 但是 他连接了左右的正数 让我们当前的最大值 变成了 6 更新最大值 继续看</p><p>下一个是-5 同理 之前的 6+ -5 和 还是1 也没有阻断 我们去看看 后边 有没有一个大数 拯救我 后边 一个数 是 4<br>加上 我们刚才记录的 1 和是5 最后还是没有挑战成功 所以 最大的和 还是之前的 6</p><p>公式：</p><p>nums是我们的源数组 nums[i] 就是我们的当前元素 currentMax[i] 记录 我们以 i 结尾的子序列里 最大的一个子序列 那么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">currentMax[i] = max(currentMax[i - 1] + nums[i], nums[i])</span><br></pre></td></tr></table></figure><p>这个公式被称之为 状态转移公式 我们的这种解法 称之为 动态规划解法 简称：PD</p><p>然后我们去遍历 currentMax 这个数组 里边的最大值 就是我们要找的 最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var maxSubArray = function(nums) &#123;</span><br><span class="line">    // 初始化源数组，初始化An为结束的最大值</span><br><span class="line">    let A = nums;</span><br><span class="line">    let dp = [];</span><br><span class="line">    let maxSum = A[0];</span><br><span class="line">    dp[0] = A[0];</span><br><span class="line">    for(let i = 1; i &lt; A.length; i++) &#123;</span><br><span class="line">        //状态转移公式</span><br><span class="line">        dp[i] = max(A[i], dp[i-1] + A[i])</span><br><span class="line">        maxSum = dp[i] &gt; maxSum ? dp[i] : maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function max(a, b) &#123;</span><br><span class="line">    return a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h3><ul><li><a href="http://blog.cgsdream.org/2015/11/11/recursion-algorithm-analysis/" target="_blank" rel="noopener">一道递归算法题</a></li></ul><h2 id="Q-如何处理函数节流与防抖"><a href="#Q-如何处理函数节流与防抖" class="headerlink" title="Q: 如何处理函数节流与防抖"></a>Q: 如何处理函数节流与防抖</h2><p>函数节流： 指定时间间隔触发一次任务</p><p>函数防抖： 多次任务触发，但是只有任务触发的间隔大于某一个时间段才去执行此任务</p><h3 id="个人思路-2"><a href="#个人思路-2" class="headerlink" title="个人思路"></a>个人思路</h3><p>处理节流： 全局变量flag 当符合条件变更flag 值为TRUE 开始执行任务 任务执行完毕 则flag 为false</p><p>并且在下次任务过来的时候 去判断flag  如果flag 为TRUE了 则return掉 不去执行之后的逻辑</p><p>处理防抖：全局时间点time 当第一次任务</p>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>代码规范</title>
      <link href="/2018/07/31/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2018/07/31/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1659024e86dcdac4?w=1354&amp;h=544&amp;f=png&amp;s=43243" alt="eslint"></p><blockquote><p>项目组内有一套统一的代码规范非常有利与项目维护</p></blockquote><a id="more"></a><h1 id="个人vscode配置"><a href="#个人vscode配置" class="headerlink" title="个人vscode配置"></a>个人vscode配置</h1><ul><li><p>在vscode中安装 eslint 插件</p></li><li><p>code - 首选项-设置置</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"eslint.autoFixOnSave"</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样vscode可以在保存 （command+s）的时候自动修正代码规范</p><p>这里列出几个常用的配置</p><h1 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h1><ul><li><a href="https://eslint.org/docs/rules/quotes" target="_blank" rel="noopener">quotes</a></li></ul><p>引号类型： 单引号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello there'</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="https://eslint.org/docs/rules/no-unused-lets" target="_blank" rel="noopener">no-unused-lets</a></li></ul><p>不能有声明后未被使用的变量或参数</p><ul><li>同一模块有多个导入时一次性写完</li></ul><p><a href="https://eslint.org/docs/rules/no-duplicate-imports" target="_blank" rel="noopener">no-duplicate-imports</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myFunc1 &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br><span class="line"><span class="keyword">import</span> &#123; myFunc2 &#125; <span class="keyword">from</span> <span class="string">'module'</span>          <span class="comment">// ✗ avoid</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; myFunc1, myFunc2 &#125; <span class="keyword">from</span> <span class="string">'module'</span> <span class="comment">// ✓ ok</span></span><br></pre></td></tr></table></figure><h1 id="默认配置项"><a href="#默认配置项" class="headerlink" title="默认配置项"></a>默认配置项</h1><p>项目中eslintrc文件中有配置项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends: standard</span><br></pre></td></tr></table></figure><p>表示已经使用了 <a href="https://github.com/standard/eslint-config-standard" target="_blank" rel="noopener">eslint-config-standard</a> 这个中配置的规则</p><ul><li>使用两个空格进行缩进</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键字后面加空格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123; ... &#125;   <span class="comment">// ✓ ok</span></span><br><span class="line"><span class="keyword">if</span>(condition) &#123; ... &#125;    <span class="comment">// ✗ avoid</span></span><br></pre></td></tr></table></figure><ul><li>函数声明时括号与函数名间加空格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span> (<span class="params">arg</span>) </span>&#123; ... &#125;   <span class="comment">// ✓ ok</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">arg</span>) </span>&#123; ... &#125;    <span class="comment">// ✗ avoid</span></span><br></pre></td></tr></table></figure><ul><li>始终使用 === 替代 ==</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name === <span class="string">'John'</span>)   <span class="comment">// ✓ ok</span></span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">'John'</span>)    <span class="comment">// ✗ avoid</span></span><br></pre></td></tr></table></figure><ul><li>字符串拼接操作符 (Infix operators) 之间要留空格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✓ ok</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">'hello, '</span> + name + <span class="string">'!'</span></span><br><span class="line"><span class="keyword">let</span> msg = <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>!`</span></span><br></pre></td></tr></table></figure><ul><li>逗号后面加空格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✓ ok</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span> (<span class="params">name, options</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li><p>不允许有连续多行空行</p></li><li><p>每个 let 关键字单独声明一个变量</p></li><li><p>始终将逗号置于行末</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'foo'</span></span><br><span class="line">  ,<span class="attr">bar</span>: <span class="string">'bar'</span>   <span class="comment">// ✗ avoid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'foo'</span>,</span><br><span class="line">  bar: <span class="string">'bar'</span>   <span class="comment">// ✓ ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>除非key包含 - 之类的特殊符号，否则一律不添加单引号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="string">'foo'</span>: <span class="string">'foo'</span>,   <span class="comment">// ✗ avoid</span></span><br><span class="line">  bar: <span class="string">'bar'</span>,    <span class="comment">// ✓ ok</span></span><br><span class="line">  <span class="string">'key-2'</span>: <span class="number">2</span>  <span class="comment">// ✓ ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>键值对当中冒号与值之间要留空白</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="string">'key'</span> : <span class="string">'value'</span> &#125;    <span class="comment">// ✗ avoid</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="string">'key'</span> :<span class="string">'value'</span> &#125;     <span class="comment">// ✗ avoid</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="string">'key'</span>:<span class="string">'value'</span> &#125;      <span class="comment">// ✗ avoid</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="string">'key'</span>: <span class="string">'value'</span> &#125;     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><ul><li>不要定义冗余的函数参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a, b, a</span>) </span>&#123;  <span class="comment">// ✗ avoid</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a, b, c</span>) </span>&#123;  <span class="comment">// ✓ ok</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>避免不必要的布尔转换</p></li><li><p>对象属性换行时注意统一代码风格</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jane Doe'</span>, <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  username: <span class="string">'jdoe86'</span>            <span class="comment">// ✗ avoid</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">'Jane Doe'</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">username</span>: <span class="string">'jdoe86'</span> &#125;    <span class="comment">// ✓ ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">'Jane Doe'</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  username: <span class="string">'jdoe86'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码块中避免多余留白</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user) &#123;</span><br><span class="line">                            <span class="comment">// ✗ avoid</span></span><br><span class="line">  <span class="keyword">const</span> name = getName()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (user) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = getName()    <span class="comment">// ✓ ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释首尾留空格</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//comment           // ✗ avoid</span></span><br><span class="line"><span class="comment">// comment          // ✓ ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*comment*/</span>         <span class="comment">// ✗ avoid</span></span><br><span class="line"><span class="comment">/* comment */</span>       <span class="comment">// ✓ ok</span></span><br></pre></td></tr></table></figure><ul><li>检查 NaN 的正确姿势是使用 isNaN()</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (price === <span class="literal">NaN</span>) &#123; &#125;      <span class="comment">// ✗ avoid</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isNaN</span>(price)) &#123; &#125;       <span class="comment">// ✓ ok</span></span><br></pre></td></tr></table></figure><ul><li><p>不要使用分号</p></li><li><p>不建议使用var</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coding </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>认识typescript</title>
      <link href="/2018/07/18/%E8%AE%A4%E8%AF%86typescript/"/>
      <url>/2018/07/18/%E8%AE%A4%E8%AF%86typescript/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/31/165902737ee8f6ea?w=922&amp;h=470&amp;f=png&amp;s=234130" alt="ts"></p><blockquote><p>typescript 概览</p></blockquote><a id="more"></a><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age: number = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yourname: string = <span class="string">'who'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ary: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ary2: <span class="built_in">Array</span>&lt;string&gt; = [<span class="string">'1'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> moreAry: any[] = [<span class="string">''</span>, <span class="number">2</span>, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isUn: <span class="keyword">void</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>可以是 多种类型的一种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">data</span>(<span class="params">arg: string | number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`arg is <span class="subst">$&#123;<span class="keyword">typeof</span> arg === <span class="string">'string'</span> ? <span class="string">'string'</span> : <span class="string">'number'</span>&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data(<span class="number">1</span>), data(<span class="string">'username'</span>))</span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><p>对值所具有的结构进行类型检查</p></blockquote><ul><li>必须包含一个label属性且类型为string</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface args &#123;</span><br><span class="line">  label: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function explainUser(user: args) &#123;</span><br><span class="line">  return user[&apos;label&apos;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">explainUser(&#123;label: &apos;123&apos;&#125;)</span><br></pre></td></tr></table></figure><p>比如编写一个 获取数据的函数 getData</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">url: string, data: object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要传递两个参数 url data</p><p>我们将其调整为 interface 形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface dataType &#123;</span><br><span class="line">  url: string,</span><br><span class="line">  data: object</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">dataValue: dataType</span>) </span>&#123;xxx&#125;</span><br></pre></td></tr></table></figure><ul><li><p>类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以</p></li><li><p>可选属性</p></li></ul><p>添加一个 ? 表示这个属性是可选的 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface dataType &#123;</span><br><span class="line">  url: string,</span><br><span class="line">  data: object,</span><br><span class="line">  uid?: number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>函数类型包含两部分：参数类型和返回值类型</p></blockquote><p>TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它</p><p>返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为void而不能留空</p><ul><li>根据当前环境参数 返回config </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">env: string, number: number</span>): <span class="title">object</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> config[env][number]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可选参数必须跟在必须参数后面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">env: string, number: number, uid?: number</span>) </span>&#123;</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加了一个可选参数 UID, uid 放到必选参数后面</p><ul><li>在所有必须参数后面的带默认初始化的参数都是可选的</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">env: string, number: number, uid = <span class="number">137722</span></span>) </span>&#123;</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的参数UID带有默认参数 所以它是可选的</p><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值 </span><br><span class="line"></span><br><span class="line">值 <span class="keyword">as</span> 类型</span><br></pre></td></tr></table></figure><p>比如我们需要在还没有确定类型的时候读取其值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">classify: string, page: number | string </span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (page.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里肯定会有报错</p><p>所以需要处理为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((&lt;string&gt;page).length )</span><br></pre></td></tr></table></figure><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p>JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。</p><ul><li></li></ul><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。</p><ul><li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li><li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>经常需要去构建promise处理方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = (uid: number): <span class="built_in">Promise</span>&lt;string&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">`<span class="subst">$&#123;uid&#125;</span> is success`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果返回值不确定 可以写为 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = (uid: number): <span class="built_in">Promise</span>&lt;any&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    xxx</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="react中ts的应用"><a href="#react中ts的应用" class="headerlink" title="react中ts的应用"></a>react中ts的应用</h3>]]></content>
      
      
      
        <tags>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安全令牌JWT</title>
      <link href="/2018/07/18/%E5%AE%89%E5%85%A8%E4%BB%A4%E7%89%8CJWT/"/>
      <url>/2018/07/18/%E5%AE%89%E5%85%A8%E4%BB%A4%E7%89%8CJWT/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/7/11/164878066f024a5e?w=788&amp;h=216&amp;f=png&amp;s=32480" alt="JWT"></p><blockquote><p>安全令牌JWT: JSON对象的形式安全传递信息的方法</p></blockquote><a id="more"></a><p>前段时间处理一个抽奖H5，测试过程中想到如果有用户抓到抽奖接口，比如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:xxx/lottery/userinfo</span><br></pre></td></tr></table></figure><p>如果直接访问抽奖接口，可以直接进行抽奖动作。这里就涉及到处理验证用户身份的问题</p><p>之后的解决方式是 判断接口的cookie中是否包含 userInfo 等参数信息</p><p>不过还可以通过另外一种方式来处理– JWT</p><h2 id="什么是JWT-（JSON-WEB-TOKEN）"><a href="#什么是JWT-（JSON-WEB-TOKEN）" class="headerlink" title="什么是JWT （JSON WEB TOKEN）"></a>什么是JWT （JSON WEB TOKEN）</h2><p>JWT是通信双方之间以 JSON对象的形式安全传递信息的方法。</p><p>其实可以理解为使用非对称算法来进行前后端校验。</p><p>JWT 由三部分组成</p><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/164871616dfaf51b?w=352&amp;h=180&amp;f=png&amp;s=12349" alt="head"></p><ul><li><p>typ 声明类型 </p></li><li><p>alg 声明加密的算法 </p></li></ul><p>然后按照此规则将头部信息进行base64编码，构成JWT第一部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><p>payload 就是存放有效信息的地方</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/16487199d8b65066?w=322&amp;h=179&amp;f=png&amp;s=14545" alt="payload"></p><p>payload 中有一些参数字段是建议使用的 （仅列出几个）</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>iat</td><td>jwt的签发时间</td></tr><tr><td>exp</td><td>jwt的过期时间，这个过期时间必须要大于签发时间</td></tr><tr><td>nbf</td><td>定义在什么时间之前，该jwt都是不可用的</td></tr></tbody></table><p>比如来定义一个payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exp&quot;: Math.floor(Date.now() / 1000) + (60 * 60),</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload 会进行base64编码，构成JWT第二部分</p><h3 id="签证"><a href="#签证" class="headerlink" title="签证"></a>签证</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/164872339c1506d0?w=356&amp;h=193&amp;f=png&amp;s=22799" alt="签证"></p><p>可以看到，签证部分是由三个部分组成的</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>base64UrlEncode</td><td>base64加密后的Header</td></tr><tr><td>base64UrlEncode</td><td>base64加密后的payload</td></tr><tr><td>your-256-bit-secret</td><td>自定义的加密secret</td></tr></tbody></table><p>secret 相当于私钥，不可泄漏，如果客户端可以拿到secret，就可以自我签发JWT了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var encodedString = base64UrlEncode(header) + &apos;.&apos; + base64UrlEncode(payload)</span><br><span class="line">var signature = HMACSHA256(encodedString, &apos;secret&apos;)</span><br></pre></td></tr></table></figure><p>signature 是JWT的第三部分</p><p>将以上三部分拼接起来，就是最后的JWT</p><h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="jsonwebtoken"><a href="#jsonwebtoken" class="headerlink" title="jsonwebtoken"></a>jsonwebtoken</h3><p>如果自己在生成jwt,有点复杂。目前已经有很多开发的第三方库来支持JWT。比如 jsonwebtoken</p><p><a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="noopener">jsonwebtoken</a> </p><ul><li><p>sign 用于生成 token</p></li><li><p>verify 用于检验token</p></li></ul><h3 id="koa-jwt"><a href="#koa-jwt" class="headerlink" title="koa-jwt"></a>koa-jwt</h3><p>koa-jwt 用于验证接口中是否包含token信息</p><p>搭建了一个简易的server 来看下效果</p><p><a href="https://github.com/mengxxSELF/koa-jwt" target="_blank" rel="noopener">项目Git地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">app.use(</span><br><span class="line">  jwtKoa(&#123;secret: SECRET&#125;)</span><br><span class="line">  .unless(&#123;</span><br><span class="line">    path: [/\/login/] // 不需要通过jwt验证的请求路径</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">router.get(&apos;/login&apos;, async (ctx) =&gt; &#123;</span><br><span class="line">  let token = jwt.sign(&#123;</span><br><span class="line">    name: &apos;dva&apos;</span><br><span class="line">  &#125;, SECRET)</span><br><span class="line">  console.log(token, &apos;token&apos;)</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(&apos;/try&apos;, async (ctx) =&gt; &#123;</span><br><span class="line">  let token = ctx.header.authorization</span><br><span class="line">  let result = jwt.verify(token, SECRET)</span><br><span class="line">  ctx.body = &#123;</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>/login 拿到token</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#123;&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZHZhIiwiaWF0IjoxNTMxMjgwMDg2fQ.Rh_vAKeytjAL2TbOk-MmXQWFesszjRU3Bzldrx5x17s&quot;&#125;%</span><br></pre></td></tr></table></figure><ul><li>如果不添加token 会被koa-jwt 拦截</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/1648769e313f5e7f?w=701&amp;h=312&amp;f=png&amp;s=28038" alt="wrong"></p><ul><li>添加 token</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/16487702e4d849aa?w=793&amp;h=404&amp;f=png&amp;s=41332" alt="token"></p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/164877a3277653a0?w=919&amp;h=620&amp;f=jpeg&amp;s=67632" alt="工作机制"></p><p>图片来自于文章 <a href="http://lion1ou.win/2017/01/18/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">《前后端分离之JWT用户认证》</a></p><ul><li><p>登录拿到JWT</p></li><li><p>前端发起请求，Header中挂载JWT</p></li></ul><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>由于我搭建的这个项目中有这种需要鉴权的接口比较少，所以并没有使用koa-jwt来处理。只是用了 jsonwebtoken</p><p><a href="https://github.com/mengxxSELF/test-activity" target="_blank" rel="noopener">项目GIT地址</a></p><h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><p>构建两个接口 login , lottery</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/9/1647ed64044740a5?w=637&amp;h=178&amp;f=png&amp;s=27705" alt="server"></p><ul><li>login 用来生成JWT 返回给前端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">token = jwt.sign(&#123;</span><br><span class="line">    name: &apos;who&apos;,</span><br><span class="line">    exp: Math.floor(Date.now() / 1000) + (60 * 60), // 设置 token 过期时间</span><br><span class="line">  &#125;, SECRET)</span><br></pre></td></tr></table></figure><ul><li>lottery 用来验证JWT，验证通过则进行抽奖动作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let token = this.headers.authorization</span><br><span class="line">  // 解码</span><br><span class="line">  let decoded = jwt.verify(token, SECRET)</span><br><span class="line">  // console.log(decoded, &apos;decoded&apos;)</span><br><span class="line">  let &#123;name&#125; = decoded</span><br><span class="line"></span><br><span class="line">  if (name != &apos;who&apos;) &#123;</span><br><span class="line">    code = 403</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>首页点击登录后 经返回的token信息存储起来</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/9/1647edb4bbb51e7e?w=484&amp;h=216&amp;f=png&amp;s=15670" alt="login"></p><p>我这里拿到token之后将其写入了localStorage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.localStorage.setItem(&apos;token&apos;, token)</span><br></pre></td></tr></table></figure><ul><li>进入抽奖页面进行抽奖，每次请求的时候挂载Authorization </li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/7/9/1647edde5ae69505?w=434&amp;h=204&amp;f=png&amp;s=12755" alt="Authorization"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(`/$&#123;APP_NAME&#125;/win`, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    Authorization: token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果传递错误的token 在server端JWT验证的时候就会报错</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/16487356ff9fd540?w=767&amp;h=360&amp;f=png&amp;s=36543" alt="error"></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/1648735fe4613e42?w=468&amp;h=171&amp;f=png&amp;s=37664" alt="error"></p><p><a href="101.200.45.254:9097/activity/lottery" target="_blank" rel="noopener">项目在线地址</a></p><p>总而言之，如果你的接口需要考虑鉴权问题，可以参考下JWT来处理。</p><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><ul><li><p><a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="noopener">jsonwebtoken</a></p></li><li><p><a href="https://jwt.io/" target="_blank" rel="noopener">jwt.io</a></p></li><li><p><a href="https://github.com/mengxxSELF/test-activity" target="_blank" rel="noopener">项目git地址</a> </p></li><li><p><a href="http://lion1ou.win/2017/01/18/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">资料1</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/JSON_Web_Token" target="_blank" rel="noopener">资料2</a> </p></li></ul><h2 id="问题回复"><a href="#问题回复" class="headerlink" title="问题回复"></a>问题回复</h2><p>这篇文章发布之后，很多同学提出了一些问题，这里一一回复。感谢各位的评论。</p><h3 id="问题1：-关于base64处理-Header-和-payload"><a href="#问题1：-关于base64处理-Header-和-payload" class="headerlink" title="问题1： 关于base64处理 Header 和 payload"></a>问题1： 关于base64处理 Header 和 payload</h3><p>其实JWT在处理Header 和 payload 的时候，只是很简单的进行了Base64编码。 如果拿到某一个token的话，是很容易就将其解码出来的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const base64url = require(&apos;base64url&apos;)</span><br><span class="line">let header = &#123;</span><br><span class="line">  &apos;typ&apos;: &apos;JWT&apos;,</span><br><span class="line">  &apos;alg&apos;: &apos;HS256&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let resultH = base64url(JSON.stringify(header))</span><br><span class="line">console.log(resultH, &apos;resultH&apos;)</span><br><span class="line"></span><br><span class="line">let payload = &#123;</span><br><span class="line">  name: &apos;dva&apos;,</span><br><span class="line">  exp: 1531410000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result = base64url(JSON.stringify(payload))</span><br><span class="line">console.log(result, &apos;result&apos;)</span><br><span class="line"></span><br><span class="line">// 解码payload</span><br><span class="line">let isP = &apos;eyJuYW1lIjoiZHZhIiwiZXhwIjoxNTMxNDEwMDAwfQ&apos;</span><br><span class="line">let getP = base64url.decode(isP)</span><br><span class="line">console.log(getP, &apos;getP&apos;)</span><br></pre></td></tr></table></figure><p>所以不建议在payload中存放敏感信息，比如用户手机号，地址信息等</p><h3 id="问题2-JWT怎么做续签更新"><a href="#问题2-JWT怎么做续签更新" class="headerlink" title="问题2 JWT怎么做续签更新"></a>问题2 JWT怎么做续签更新</h3><p>查阅资料后总结，jwt的续签更新目前有以下处理方式，基本的原理就是在某一个时间点，server端发放新的token</p><ul><li>每次客户端发起新的请求过来，server自动更新token，返回最新的token信息给客户端，客户端拿到token后需要再更新token</li></ul><p>比如 在用户点击抽奖，发起请求的时候，server端每次更新一个token（我这里只更新jwt的有效期）</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/164929b24314b32a?w=1090&amp;h=982&amp;f=png&amp;s=192311" alt="token"></p><p>拿到新的token之后将其返回。下次发起抽奖动作的时候，挂载这个最新的token</p><p>但是这种处理方案有缺陷，如果用户两次请求的间隔时间超过了过期时间（比如20分钟），则接口过来的时候 首先会被判断为过期状态，请求终止（之后的代码不被执行，不会被下发新的token了）。用户会被强制退出到登录界面。</p><ul><li>每次请求过来的时候，不去判断有效期 （当然此请求本身携带的token必须在有效期内，我的意思是不像第一种，判断距离过期还有多久） 直接下发新的token</li></ul><h4 id="问题3-处理注销"><a href="#问题3-处理注销" class="headerlink" title="问题3 处理注销"></a>问题3 处理注销</h4><p>可以说token比较重要的问题就是注销token。</p><p>比如我上面第二个jwt的项目，当用户点击退出登录的时候，仅仅在客户端做了token的删除。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/12/1648f150f63cc14b?w=942&amp;h=134&amp;f=png&amp;s=34937" alt="remove"></p><p>但是实际上这个token还是处于有效期内的。如果用户保存了token值，在点击了退出登录之后，实际还可以使用此token值的。可以理解为伪注销。</p><p>传统的方式怎么处理用户的注销行为呢？– 删除数据库记录。当用户注销登录信息的时候，server会变更数据库信息</p><p>但是jwt是没有介入服务器来存储用户状态的。这就比较难处理了。我们希望token能够在用户注销后不可以被继续使用了</p><ul><li><p>设置比较短的token 有效期，每次请求过来的时候，重新下发，不断更新token. </p></li><li><p>使用服务器存储token状态。当用户点击注销，将token置空。</p></li></ul><h4 id="问题4-JWT单点登录（强制退出用户登录-比如修改密码后-希望能让其他客户端登陆的地方全部强制登出）"><a href="#问题4-JWT单点登录（强制退出用户登录-比如修改密码后-希望能让其他客户端登陆的地方全部强制登出）" class="headerlink" title="问题4 JWT单点登录（强制退出用户登录,比如修改密码后,希望能让其他客户端登陆的地方全部强制登出）"></a>问题4 JWT单点登录（强制退出用户登录,比如修改密码后,希望能让其他客户端登陆的地方全部强制登出）</h4><p>可以理解为如何让一个token立即失效（有点像上面的问题3）</p><ul><li>jwt + 数据库（比如 redis）+ 白名单  （这种思路是公司同事提出来的，特别感谢~）</li></ul><p>每一位用户在设备A登录的时候，将UID和token对应关系存放起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myRedis.set(`$&#123;uid&#125;:token`, $&#123;tokenA&#125;)</span><br></pre></td></tr></table></figure><p>用户换设备B登录的时候，将redis中的的token进行更新 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myRedis.set(`$&#123;uid&#125;:token`, $&#123;tokenB&#125;)</span><br></pre></td></tr></table></figure><p>每次请求发起的时候，server端去验证该UID对应的token信息是否是最新的token， 这样 如果携带的不是redis中的token的话，拒绝请求。前端强制退出登录。</p><p>我将这个单点登录的逻辑加入到了项目中。</p><p><a href="http://101.200.45.254:9097/activity/lottery" target="_blank" rel="noopener">登录尝试</a> </p><p>你可以在两台设备使用同一个用户名进行登录，尝试是不是可以将第一台设备的状态登出。</p><p>新增逻辑部分：将用户{name, token} 对应关系存放在文件中，每次发送抽奖请求的时候，判断文件最新的token与接口携带的token是否一致。不一致则反馈前端需要退出登录</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/13/16492f55a5f4485b?w=962&amp;h=472&amp;f=png&amp;s=78702" alt="退出"></p><p>缺点：需要保留每一位用户的 {user, token} 对应关系</p><ul><li>jwt + 数据库（比如 redis）+ 黑名单</li></ul><p>当用户点击退出登录，此token则被放入黑名单（比如存放在redis）。如果有请求此时携带了黑名单中的token，则不予处理</p><p>缺点：长此以往黑名单数据量增长</p><h4 id="问题5-如何防范Replay-Attacks-（重放攻击）"><a href="#问题5-如何防范Replay-Attacks-（重放攻击）" class="headerlink" title="问题5  如何防范Replay Attacks （重放攻击）"></a>问题5  如何防范Replay Attacks （重放攻击）</h4><blockquote><p>重放攻击就是攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程</p></blockquote><p>比如用户的token被获取，那么即使用户登出了系统，其他人还可以利用Token模拟正常请求，而服务器端则无法判断这种情况。</p><p>还是黑名单思路，每次token更新之后，或者用户登出之后，旧的token被放入黑名单。携带此token的请求一律不予处理</p><h4 id="问题6-使用‘每一次发送请求就去更新token的方式’-如果客户端有并发的请求，如何处理"><a href="#问题6-使用‘每一次发送请求就去更新token的方式’-如果客户端有并发的请求，如何处理" class="headerlink" title="问题6 使用‘每一次发送请求就去更新token的方式’ 如果客户端有并发的请求，如何处理"></a>问题6 使用‘每一次发送请求就去更新token的方式’ 如果客户端有并发的请求，如何处理</h4><p>em，这个和上面的问题5有点矛盾，如果使用变化token的情况处理，那么肯定会有当请求并发状态下，第一个请求在处理完毕拿到新的token，后面的请求携带的token就变成了旧的token，请求会失败</p><p>查阅资料后发现，有些人在将token存到黑名单的时候，会同时添加一个“宽限时间” 。当请求中携带了一个黑名单中的过期token，则去判断去“宽限时间”，如果在期宽限之间之内，则予以通过。</p><p>不过我个人没想明白，这种处理方式是不是有问题，既然已经被放入黑名单了，那为什么又来一个“宽限时间”。为什么不直接设置一个长一点的有效时间。</p><p>以上是对各位的一些回答。欢迎留言讨论。</p><h3 id="补充文章"><a href="#补充文章" class="headerlink" title="补充文章"></a>补充文章</h3><ul><li><p><a href="http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt" target="_blank" rel="noopener">JSON Web Token - 在Web应用间安全地传递信息</a></p></li><li><p><a href="https://github.com/bigmeow/JWT/issues/4" target="_blank" rel="noopener">jwt 相关问题</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/22693223" target="_blank" rel="noopener">有关JWT(Json Web Token)如何解决并发问题的思考</a></p></li><li><p><a href="https://juejin.im/entry/59748def518825592c4f9ac0" target="_blank" rel="noopener">不要用 JWT 来做 Web 应用的会话管理</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器三大件的升级</title>
      <link href="/2018/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%89%E5%A4%A7%E4%BB%B6%E7%9A%84%E5%8D%87%E7%BA%A7/"/>
      <url>/2018/07/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%89%E5%A4%A7%E4%BB%B6%E7%9A%84%E5%8D%87%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f153e0de9a42?w=1400&amp;h=664&amp;f=png&amp;s=106656" alt="level"></p><blockquote><p>服务器以及其配置升级记录</p></blockquote><a id="more"></a><h2 id="升级版本为"><a href="#升级版本为" class="headerlink" title="升级版本为"></a>升级版本为</h2><ul><li><p>npm v5.6.0</p></li><li><p>node v8.11.2</p></li><li><p>cnpm v5.2.0</p></li><li><p>pm2 v2.10.2</p></li></ul><h2 id="nvm-安装"><a href="#nvm-安装" class="headerlink" title="nvm 安装"></a>nvm 安装</h2><p><a href="https://www.jianshu.com/p/6249d1d24914" target="_blank" rel="noopener">nvm安装</a></p><h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm i 8.11.2</span><br></pre></td></tr></table></figure><p>以下三个升级请切换到root身份操作</p><h2 id="升级npm"><a href="#升级npm" class="headerlink" title="升级npm"></a>升级npm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g npm@5.6.0</span><br></pre></td></tr></table></figure><h2 id="升级cnpm"><a href="#升级cnpm" class="headerlink" title="升级cnpm"></a>升级cnpm</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g cnpm@5.2.0</span><br></pre></td></tr></table></figure><h2 id="升级pm2"><a href="#升级pm2" class="headerlink" title="升级pm2"></a>升级pm2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g pm2@2.10.2</span><br></pre></td></tr></table></figure><p>pm2升级之后 work身份下需要执行 pm2 update </p><p>升级之后去查看pm2 list</p><p>pm2 show xxx</p><p>需要DELETE 重新启动才可以，直接restart不行</p><h2 id="在服务器创建新的身份"><a href="#在服务器创建新的身份" class="headerlink" title="在服务器创建新的身份"></a>在服务器创建新的身份</h2><p>以root身份登录到服务器之后 创建新的身份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd vbird</span><br></pre></td></tr></table></figure><p>这样就创建了一个新的角色</p><p>但此时尝试使用此身份登录服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh vbird@xxx</span><br></pre></td></tr></table></figure><p>会提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Permission denied, please try again</span><br></pre></td></tr></table></figure><p>是权限错误，并不是密码错误</p><p>这是因为使用 useradd 新郑vbird 账号之后，在默认情况下，账号是暂时被封锁的。也就是无法登录的。</p><p>我们需要给vbird来设置密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd vbird</span><br></pre></td></tr></table></figure><p>然后输入密码就可以了。此密码将会是使用新身份登录服务器的密码。</p><h2 id="修改项目配置信息，以新身份去进行部署"><a href="#修改项目配置信息，以新身份去进行部署" class="headerlink" title="修改项目配置信息，以新身份去进行部署"></a>修改项目配置信息，以新身份去进行部署</h2><h3 id="报错-–-无权限创建文件夹"><a href="#报错-–-无权限创建文件夹" class="headerlink" title="报错 – 无权限创建文件夹"></a>报错 – 无权限创建文件夹</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645f2feb2211d80?w=709&amp;h=356&amp;f=png&amp;s=87920" alt="permission"></p><p>看一下此文件夹的属性</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645f31982228022?w=545&amp;h=116&amp;f=png&amp;s=31351" alt="nature"></p><p>可以看到 releases 这个文件夹的权限属性是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x 4 root root 4096 May 21 21:10 releases</span><br></pre></td></tr></table></figure><p>【文件夹】【可读可写可执行】【可读可执行】【可读可执行】【文件所有者root】【文件所属用户组root】 </p><p>所以现在vbird的权限是 【可读可执行】</p><p>而创建一个文件夹属于 【写】的权限范围</p><p>处理方案： 变更文件夹权限</p><p>登录服务器 进入/home 然后修改work文件夹权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line"></span><br><span class="line">chgroup work work // 变更文件所属组为 work组</span><br><span class="line">chown vbird work // 变更文件所有者为vbird</span><br></pre></td></tr></table></figure><p>看些变更后的权限<br><img src="https://user-gold-cdn.xitu.io/2018/7/3/1645fe8c8931a436?w=395&amp;h=35&amp;f=png&amp;s=11406" alt="work"></p><p>work文件夹内部已经有我之前使用root身份部署的时候创建的项目文件夹，需要全部删除才可以部署成功</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> Linux </tag>
            
            <tag> pm2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划9</title>
      <link href="/2018/07/02/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%929/"/>
      <url>/2018/07/02/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%929/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><ul><li><p>code review</p></li><li><p>国际公播排行榜</p></li><li><p>儿童节</p></li></ul><h2 id="study"><a href="#study" class="headerlink" title="study"></a>study</h2><ul><li><p>linux</p></li><li><p>升级三大件</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器部署</title>
      <link href="/2018/06/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/06/12/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/6/12/163f38cd00ab0e3a?w=776&amp;h=223&amp;f=png&amp;s=29247" alt="banner"></p><blockquote><p>前段时间在公司部署项目的时候，运维同学说了一堆关于服务器的东西，顿时感觉不知所云，云里雾里。。。索性拿这个项目练习一下，简单了解项目部署到服务器的这个流程是怎么处理的</p></blockquote><a id="more"></a><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h3><p>pm2 是启动node进程管理工具</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>···</p><p>pm2 start app.js ： 启动服务，入口文件是app.js</p><p>pm2 list 查看有哪些进程启动</p><p>pm2 show xxx  查看某一个服务的详情</p><p>npm restart  [name or id] ： 重启服务</p><p>pm2 monit ： 对服务进行监控</p><p>···</p><p>一个项目的package.json 文件</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/27/163a1aec86e99008?w=1438&amp;h=450&amp;f=png&amp;s=140802" alt="package.json"></p><p>平时启动服务我们可以使用 node run app.js</p><p>如果借助pm2 来启动服务 就可以输入 pm2 start  app.js</p><p>在命令行输入 pm2 list 可以查看正在运行的项目</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/27/163a1ba30dd25825?w=1512&amp;h=180&amp;f=png&amp;s=87117" alt="pm2 list"></p><h4 id="pm2支持配置文件启动"><a href="#pm2支持配置文件启动" class="headerlink" title="pm2支持配置文件启动"></a>pm2支持配置文件启动</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/27/163a1f1bbad301ee?w=1490&amp;h=656&amp;f=png&amp;s=180997" alt="pm2配置文件"></p><ul><li>script  启动脚本路径</li><li>exec_mode  应用启动模式，支持fork和cluster模式</li><li>instances  应用启动实例个数，仅在cluster模式有效，默认为fork</li></ul><h2 id="fork和cluster模式"><a href="#fork和cluster模式" class="headerlink" title="fork和cluster模式"></a>fork和cluster模式</h2><p>fork为单进程   cluster可以启动多个进程</p><p>在项目中新增一个pm2配置文件 pm2.config.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;mxx-project&quot;,</span><br><span class="line">  &quot;script&quot;: &quot;./index.js&quot;,</span><br><span class="line">  &quot;error_file&quot;: &quot;./logs/err.log&quot;,</span><br><span class="line">  &quot;out_file&quot;: &quot;./logs/out.log&quot;,</span><br><span class="line">  &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm Z&quot;,</span><br><span class="line">  &quot;instances&quot;: 3,</span><br><span class="line">  &quot;merge_logs&quot;: true,</span><br><span class="line">  &quot;exec_mode&quot;: &quot;cluster&quot;,</span><br><span class="line">  &quot;node_args&quot;: &quot;&quot;,</span><br><span class="line">  &quot;ignore_watch&quot;: [&quot;node_modules&quot;],</span><br><span class="line">  &quot;env&quot;: &#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;development&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行输入  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start pm2.config.json</span><br></pre></td></tr></table></figure><p>则会有三个进程被创建</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/27/163a200b8a0985cd?w=1716&amp;h=472&amp;f=png&amp;s=300205" alt="cluster"></p><p>注： 如果你的服务器是多核的 那么很有可能在cluster 模式下 被创建多个进程</p><p>可以查看一下自己的服务器是几核的</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/27/163a208e89e5a090?w=1346&amp;h=72&amp;f=png&amp;s=39928" alt="cluster"></p><h2 id="shipit"><a href="#shipit" class="headerlink" title="shipit"></a>shipit</h2><p>shipit 是自动化的服务器部署工具</p><p>一个简单的shipit配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module.exports = shipit =&gt; &#123;</span><br><span class="line">  require(&apos;shipit-deploy&apos;)(shipit)</span><br><span class="line">  shipit.initConfig(&#123;</span><br><span class="line">    default: &#123;</span><br><span class="line">      workspace: &apos;/tmp/myapp&apos;,</span><br><span class="line">      deployTo: &apos;/var/myapp&apos;,</span><br><span class="line">      repositoryUrl: &apos;你的GitHub地址&apos;,</span><br><span class="line">      ignores: [&apos;.git&apos;, &apos;node_modules&apos;],</span><br><span class="line">      keepReleases: 2,</span><br><span class="line">      deleteOnRollback: false,</span><br><span class="line">      key: &apos;/path/to/key&apos;,</span><br><span class="line">      shallowClone: true,</span><br><span class="line">    &#125;,</span><br><span class="line">    staging: &#123;</span><br><span class="line">      servers: &apos;你的服务器地址&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><p>购买服务器之后 得到IP地址 可以尝试登陆服务器</p><p>一般自己的服务器可以使用root身份登陆操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@ipipip</span><br></pre></td></tr></table></figure><p>由于后面项目要部署到服务器中 建议可以先做ssh-copy-id 建立信任 这样就不用重复输入密码了</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ee455567729da?w=610&amp;h=280&amp;f=png&amp;s=60077" alt="ssh-copy-id"></p><h2 id="在服务器上配置环境"><a href="#在服务器上配置环境" class="headerlink" title="在服务器上配置环境"></a>在服务器上配置环境</h2><p>一般来说 需要安装 npm cnpm node pm2 git nginx</p><ul><li>安装npm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install npm</span><br></pre></td></tr></table></figure><ul><li>安装 cnpm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><ul><li>安装pm2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i pm2</span><br></pre></td></tr></table></figure><ul><li>安装node</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i n</span><br></pre></td></tr></table></figure><ul><li>安装git</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><h2 id="启动一个简易服务"><a href="#启动一个简易服务" class="headerlink" title="启动一个简易服务"></a>启动一个简易服务</h2><p>我们来写一个简单的脚本 在服务器上， 我这里是在 /home/work 目录下新建了一个app.js (依次执行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd home</span><br><span class="line">mkdir work</span><br><span class="line">touch app.js</span><br></pre></td></tr></table></figure><p>在app.js中 写一个最简单的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;)</span><br><span class="line">const port = 3389</span><br><span class="line"></span><br><span class="line">http.createServer((req, res) =&gt; &#123;</span><br><span class="line">  res.end(&apos;Hello word!&apos;)</span><br><span class="line">&#125;).listen(port, () =&gt; &#123;</span><br><span class="line">  console.log(port, &apos;port&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>启动app.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ee650ddf9642c?w=396&amp;h=51&amp;f=png&amp;s=12748" alt="node"></p><p>然后打开浏览器，输入IP+端口号，就能在页面中看到hello word了</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ee5fe7d595200?w=664&amp;h=149&amp;f=png&amp;s=49446" alt="hello word"></p><p>–补充–</p><p>1 这里使用的端口号是 3389 是因为我的服务器中 安全组中已经配置了 3389 这个端口号</p><p>如果你使用的是其余端口 要注意去查看有没有配置安全组</p><p>2 关于启动服务</p><p>如果使用的是node 那么一旦退出服务器，则无法再访问此服务</p><p>可以换成使用pm2 来启动 这样一旦启动 除非报错，将会一直有此进程存在</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163ee65340369a24?w=699&amp;h=98&amp;f=png&amp;s=16714" alt="pm2"></p><h2 id="准备部署"><a href="#准备部署" class="headerlink" title="准备部署"></a>准备部署</h2><ul><li>准备项目</li></ul><p>项目是用koa1 + React</p><p>react的项目地址 <a href="https://github.com/mengxxSELF/Redux-koa" target="_blank" rel="noopener">点我查看GitHub地址</a></p><p>启动的端口号调整到3389</p><ul><li>准备pm2启动文件</li></ul><p>创建pm2文件夹 在其中写一个 production.json 用于启动pm2</p><ul><li>在项目中创建一个 shipit.js 基本配置如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function (shipit) &#123;</span><br><span class="line">  require(&apos;shipit-deploy&apos;)(shipit)</span><br><span class="line">  require(&apos;shipit-cnpm&apos;)(shipit)</span><br><span class="line">  require(&apos;shipit-pm&apos;)(shipit)</span><br><span class="line">  shipit.initConfig(&#123;</span><br><span class="line">    default: &#123;</span><br><span class="line">      workspace: &apos;/tmp/deploy/your-project&apos;,</span><br><span class="line">      deployTo: &apos;/home/work/your-project&apos;,</span><br><span class="line">      repositoryUrl: &apos;https://github.com/youproject.git&apos;,</span><br><span class="line">      ignores: [&apos;.git&apos;, &apos;node_modules&apos;],</span><br><span class="line">      keepReleases: 2,</span><br><span class="line">      deleteOnRollback: false,</span><br><span class="line">      key: &apos;/path/to/key&apos;,</span><br><span class="line">      shallowClone: true,</span><br><span class="line">      cnpm: &#123;</span><br><span class="line">        flags: &apos;--production&apos;,</span><br><span class="line">        local: false,</span><br><span class="line">        npm: &apos;cnpm&apos;,</span><br><span class="line">        remote: true</span><br><span class="line">      &#125;,</span><br><span class="line">      pm: &#123;</span><br><span class="line">        production: &#123;</span><br><span class="line">          path: &apos;/home/work/your-project/current/pm2/production.json&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    production: &#123;</span><br><span class="line">      servers: [&apos;root@你的IP地址&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 pm2 使用的配置文件来启动 所以配置了 pm 参数 会根据这个文件路径来启动pm2</p><ul><li><p>在项目的package.json中 添加两个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;deploy&quot;: &quot;shipit production deploy&quot;,</span><br><span class="line">&quot;rollback&quot;: &quot;shipit production rollback&quot;,</span><br></pre></td></tr></table></figure></li><li><p>将项目push到GitHub中</p></li><li>执行 npm run deploy</li></ul><p>项目部署完毕后，去服务器查看下项目进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 list</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eec4823de9345?w=822&amp;h=138&amp;f=png&amp;s=38275" alt="pm2"></p><p>打开页面 看下效果</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eec1fea607d01?w=877&amp;h=416&amp;f=png&amp;s=216161" alt="server"></p><p>到目前为止，算是部署完毕了</p><h2 id="部署过程出现的问题"><a href="#部署过程出现的问题" class="headerlink" title="部署过程出现的问题"></a>部署过程出现的问题</h2><ul><li>报错1</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eec6a3384c7aa?w=899&amp;h=190&amp;f=png&amp;s=56828" alt="git"></p><p>解决： 服务器上忘记安装git了</p><ul><li>报错2</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eec769f6504f5?w=820&amp;h=203&amp;f=png&amp;s=54513" alt="cnpm"></p><p>这个就很明显了，没有安装 cnpm</p><ul><li>部署成功之后去服务器查看 项目并没有启动</li></ul><p>原来部署完毕是</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eec8d099577ea?w=906&amp;h=152&amp;f=png&amp;s=36711" alt="shipit"></p><p>然后求助一位大神，发现是shipit配置文件中 没写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;shipit-pm&apos;)(shipit)</span><br></pre></td></tr></table></figure><p>[摔桌子！]</p><p>调整文件后重新上线</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eeca943fc474f?w=811&amp;h=256&amp;f=png&amp;s=74416" alt="pm2"></p><p>会启动三个进程</p><h2 id="根据项目端口号配置阿里云"><a href="#根据项目端口号配置阿里云" class="headerlink" title="根据项目端口号配置阿里云"></a>根据项目端口号配置阿里云</h2><p>如果你的项目启动时候端口号并没有在安全组中配置，需要在后台中添加安全组</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eecc8919bd7ca?w=605&amp;h=705&amp;f=png&amp;s=87614" alt="9093"></p><p>在访问页面的时候 还需要输入端口号 3389。非常懒，不想输入端口号</p><p>在安全组中添加默认端口80，将启动文件app.js中端口调整为80。这样就不需要输入端口号了</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eed4a54c6e76b?w=624&amp;h=103&amp;f=png&amp;s=18177" alt="port"></p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eed4c3afa8bd0?w=710&amp;h=249&amp;f=png&amp;s=64349" alt="port"></p><p>那如果不想修改app.js文件怎么办，使用NGINX</p><h2 id="配置NGINX"><a href="#配置NGINX" class="headerlink" title="配置NGINX"></a>配置NGINX</h2><ul><li>安装 nginx</li></ul><p>yum install nginx</p><p>查看NGINX配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>很简单的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  _;</span><br><span class="line">        root         /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将项目入口文件app.js中端口号调整为 9999</p><p>处理Nginx.conf.js</p><p>最后调整为 （比较重要的是server 这里只展示server部分）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       server_name  localhost;</span><br><span class="line"></span><br><span class="line">       location / &#123;</span><br><span class="line">         proxy_pass  http://127.0.0.1:9999/;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>启动Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="Nginx配置出现的问题"><a href="#Nginx配置出现的问题" class="headerlink" title="Nginx配置出现的问题"></a>Nginx配置出现的问题</h2><ul><li>重启Nginx</li></ul><p>在重启Nginx的时候 一直报错</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/11/163eeec21673a93a?w=610&amp;h=40&amp;f=png&amp;s=14927" alt="error"></p><p>查阅文章后处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>搞定~</p><p>欢迎访问 <a href="http://47.104.231.146/" target="_blank" rel="noopener">点我查看项目</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://pm2.keymetrics.io/docs/usage/cluster-mode/" target="_blank" rel="noopener">pm2</a></li><li><a href="https://github.com/jawil/blog/issues/7" target="_blank" rel="noopener">PM2使用技巧</a></li><li><a href="https://www.jianshu.com/p/7b10123c8b88" target="_blank" rel="noopener">pm2进程管理工具使用总结</a></li><li><a href="https://cnodejs.org/topic/584545bd4c17b38d354363af" target="_blank" rel="noopener">使用shipit-deploy实现自动化的多服务器部署</a></li><li><a href="https://www.jianshu.com/p/07843ae6b556" target="_blank" rel="noopener">使用 Shipit 来自动化部署 Node 应用</a></li><li><a href="https://lufficc.com/blog/nginx-for-beginners" target="_blank" rel="noopener">初识 Nginx</a></li><li><a href="https://blog.csdn.net/llnara/article/details/8691049" target="_blank" rel="noopener">重启nginx后丢失nginx.pid，如何重新启动nginx</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> Linux </tag>
            
            <tag> pm2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ssh-copy-id</title>
      <link href="/2018/05/26/ssh-copy-id/"/>
      <url>/2018/05/26/ssh-copy-id/</url>
      
        <content type="html"><![CDATA[<p>如何在本机中进行ssh-copy-id</p><a id="more"></a><p>在Linux中登录服务器可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@xxxxx</span><br></pre></td></tr></table></figure><p>然后会让你输入密码 就可以登录了</p><p>可以通过shh-copy-id实现 无密码登录</p><p>相当于本机电脑与远程服务器之间建立信任关系</p><h2 id="建立信任关系"><a href="#建立信任关系" class="headerlink" title="建立信任关系"></a>建立信任关系</h2><ul><li>1 先查看本机中用户主目录下是否有 .ssh目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /User/xxx/.ssh</span><br><span class="line"></span><br><span class="line">ls -a</span><br></pre></td></tr></table></figure><p>可以看到 id_rsa和id_rsa.pub这两个文件</p><p><img src="/img/SSH/ssh1.png" alt="svg"></p><ul><li>2 将 id_rsa.pub 中内容添加到git中</li></ul><p><img src="/img/SSH/ssh2.png" alt="svg"><br><img src="/img/SSH/ssh3.png" alt="svg"></p><ul><li>3 去执行ssh-copy-id吧</li></ul><p>如果 本机中并没有 那两个文件呢 </p><ul><li>ssh-keygen </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>然后就生成那两个文件了</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000" target="_blank" rel="noopener">远程仓库</a></p>]]></content>
      
      
      <categories>
          
          <category> LINUX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深拷贝与浅拷贝</title>
      <link href="/2018/05/15/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/05/15/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>先来复习一下几种数据类型</p><p>js基本数据类型： number  string undefined null Boolean</p><p>引用数据类型 ： Array Object Regexp Function 等</p><a id="more"></a><p>没有嵌套对象的话,就没必要区分深浅拷贝了。只有在有嵌套的对象时,深拷贝和浅拷贝才有区别</p><p>比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span>  obj1 = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  age: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于age属性是对象 这里拷贝就应该区分深浅拷贝</p><p>最简单实现深拷贝的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  person: [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringfy(a))</span><br><span class="line">b[<span class="string">'person'</span>].push(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a, b);</span><br></pre></td></tr></table></figure><p>但是使用这种方式 有缺点</p><ul><li>拷贝出错</li></ul><p>有一些特殊的对象比如 函数 正则 稀疏数组 在通过这种方式进行拷贝的时候 会出错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  fn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">  isE: <span class="keyword">new</span> Regexp(<span class="string">'d'</span>),</span><br><span class="line">  newAry: <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"><span class="built_in">console</span>.log(b.fn) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.isE) <span class="comment">// &#123;&#125; -- 这里是正则会变为一个空对象</span></span><br><span class="line"><span class="built_in">console</span>.log(b.newAry) <span class="comment">// &#123;&#125; -- 这里是正则会变为一个空对象</span></span><br></pre></td></tr></table></figure><ul><li>会抛弃对象的constructor,所有的构造函数会指向Object</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> () </span>&#123;</span><br><span class="line">  xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> isP = <span class="keyword">new</span> Parent</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  isTest: isP</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">'isTest'</span>].constructor) <span class="comment">// [Function: Parent]</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj[<span class="string">'isTest'</span>].constructor) <span class="comment">// [Function: Object]</span></span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p>Object.assign() 也是属于 浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name: <span class="string">'1'</span>,</span><br><span class="line">  ary: [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a[<span class="string">'ary'</span>].push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b[<span class="string">'ary'</span>]) <span class="comment">// [ 1, 3, 4 ]</span></span><br></pre></td></tr></table></figure><p>可以看到 后面修改了数组 还是会影响b 所以这属于  浅拷贝</p><h2 id="第三方提供的可以进行深拷贝的方法"><a href="#第三方提供的可以进行深拷贝的方法" class="headerlink" title="第三方提供的可以进行深拷贝的方法"></a>第三方提供的可以进行深拷贝的方法</h2><p>$.extend(true, {}, obj)</p><h2 id="loadsh"><a href="#loadsh" class="headerlink" title="loadsh"></a>loadsh</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.cloneDeep(obj)</span><br><span class="line">_.clone(obj,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><h2 id="react-中-immutable-js"><a href="#react-中-immutable-js" class="headerlink" title="react 中 immutable.js"></a>react 中 immutable.js</h2>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack系列之-优化篇</title>
      <link href="/2018/05/08/webpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%BC%98%E5%8C%96%E7%AF%87/"/>
      <url>/2018/05/08/webpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%BC%98%E5%8C%96%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>优化篇将注重提高开发速度，优化项目体验</p><a id="more"></a><h2 id="happypack"><a href="#happypack" class="headerlink" title="happypack"></a>happypack</h2><p>项目构建过程有大量的文件需要解析和处理  涉及到大量的读写操作  而 webpack的运行的单线程的 【在node中运行】也就是webpack要一个一个的处理任务 无法同时处理</p><p>HappyPack 可以帮助webpack 将任务分解到多个子进程去并发执行 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// js 文件的处理 交给 id 为 babel的happypack的实例</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'happypack/loader?id=babel'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 处理 js</span></span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">      id : <span class="string">'babel'</span>,</span><br><span class="line">      loaders : [<span class="string">'babel-loader?cacheDirectory'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h2><h2 id="scope-hoisting"><a href="#scope-hoisting" class="headerlink" title="scope hoisting"></a>scope hoisting</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://taobaofed.org/blog/2016/12/08/happypack-source-code-analysis/" target="_blank" rel="noopener">happypack 原理解析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack系列之-功能篇</title>
      <link href="/2018/05/07/webpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
      <url>/2018/05/07/webpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E5%8A%9F%E8%83%BD%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>功能篇从代码分割和按需加载 两个方面来分析</p><h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><p>为什么使用代码分割？</p><p>我们的项目采用相同的一套技术栈 互相之间有很多相同的代码。如果每一个页面都不做任何处理 直接打包，会造成 1 相同的资源重复加载 很浪费流量 2 页面加载速度慢 用户体验不好</p><a id="more"></a><p>如果将多个页面的公共部分抽取成一个独立的文件 就能优化这些问题。</p><p>用户在访问A页面的时候 已经将代码缓存起来了 那么访问B的时候 有公共代码部分 就会直接读取缓存文件 </p><ul><li>一个规范的项目应该有如下三部分chunk</li></ul><table><thead><tr><th>chunk</th><th>含义</th></tr></thead><tbody><tr><td>vendor.js</td><td>项目使用的技术栈</td></tr><tr><td>common.js</td><td>剔除技术栈之后的  所有页面都依赖的公共代码</td></tr><tr><td>[name].js</td><td>每一个网页各自独立的代码</td></tr></tbody></table><h3 id="commonschunkplugin"><a href="#commonschunkplugin" class="headerlink" title="commonschunkplugin"></a>commonschunkplugin</h3><p>commonschunkplugin 是webpack内置的插件</p><blockquote><p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用</p></blockquote><p>用来处理在多入口下提取公共模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  index: <span class="string">'./index.js'</span>,</span><br><span class="line">  main: <span class="string">'./main.js'</span></span><br><span class="line">&#125;</span><br><span class="line">-- other --</span><br><span class="line"></span><br><span class="line">plugin: &#123;</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">'bundle'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会将 多个入口文件中都引入的公共模块打包到一个独立的文件中，以便在其他的入口和模块中使用</p><p>然而我们的项目全部都是单入口文件 为什么这里还配置了 CommonsChunkPlugin ？ —  因为有vendor</p><p>当我们在入口中加入 vendor 参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  vendor: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>],</span><br><span class="line">  index: <span class="string">'./index.js'</span>,</span><br><span class="line">  main: <span class="string">'./main.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>one.js 是 index 与 mian都引入的文件  在没有加入vendor的时候 文件编译结果为</p><p><img src="/img/webpack5/bundle.png" alt="bundle"></p><p>如果添加 vendor 属性 文件编译之后 会发现 bundle 中提取的公共chunk 将会是空的</p><p>公共组件 one.js  并没有进入 bundle.js 中 而是在两个入口文件中存在着</p><p>所以这就涉及到 公共业务模块与类库或框架分开打包 的问题</p><h4 id="公共业务模块与类库或框架分开打包"><a href="#公共业务模块与类库或框架分开打包" class="headerlink" title="公共业务模块与类库或框架分开打包"></a>公共业务模块与类库或框架分开打包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'react'</span>],</span><br><span class="line">    index: <span class="string">'./index.js'</span>,</span><br><span class="line">    main: <span class="string">'./main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  -- --</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: [<span class="string">'bundle'</span>, <span class="string">'vendor'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/webpack5/commonChunk.png" alt="commonsCunkPlugin"></p><p>但是这里有一个问题 如果项目中有 非 vendor 中的文件发生了重新编译  vendor 的文件也会被重新编译<br><a href="https://github.com/webpack/webpack/issues/1315" target="_blank" rel="noopener">issure</a></p><p><img src="/img/webpack-code/vendor.png" alt="vendor"></p><p>可以看到虽然两次打包的结果大小相同 但是vender还是被处理了新的哈希值</p><h4 id="vendor-哈希值一直变动问题"><a href="#vendor-哈希值一直变动问题" class="headerlink" title="vendor 哈希值一直变动问题"></a>vendor 哈希值一直变动问题</h4><h5 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h5><p>为了最小化生成的文件大小，webpack使用标识符而不是模块名称，在编译期间生成标识符，并映射到块文件名，然后放入一个名为chunk manifest的JS对象中。重点就在于！！当我们使用CommonsChunkPlugin分离代码时，被分离出来的代码（比如React库，被打包为vendor），会默认被移动到entry中最后一个入口进行打包（第一个入口是index.js。重要的是，chunk manifest将随着这些被分离出来的代码共同打包！！！</p><p>由于我们更改源代码后，不但会更新app的hash值，还会生成新的映射，然后新的映射又会和资源代码一同打包，又由于chunkhash是根据内容生成hash的，那么加入了新的映射对象chunk manifest的资源代码被打包后，hash自然也会发生改变。这反过来，产生的新hash将使长效缓存失效。</p><p>那么接下来我们需要做的就是把 manifest分离出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: [<span class="string">'vendor'</span>, <span class="string">'manifest'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>添加一个entry中未用到的名称 就可以manifest分离出来了 这样每次文件变动的时候  manifest.js 会发生变动 而 vendor 不会再发生变动</p><h5 id="NamedChunksPlugin"><a href="#NamedChunksPlugin" class="headerlink" title="NamedChunksPlugin"></a>NamedChunksPlugin</h5><p>根据文件内容进行打包</p><h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>单页面应用中，如果所有一次性加载所有功能对应的代码，可能会导致网页加载缓慢，交互卡顿的现象。</p><p>处理方案： 最好用户需要什么功能 就加载对应的代码【按需加载】</p><h3 id="require-ensure"><a href="#require-ensure" class="headerlink" title="require.ensure"></a>require.ensure</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">require</span>.ensure([dependencies], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>(‘./a.js)</span><br><span class="line">&#125;, chunkname)</span><br></pre></td></tr></table></figure><p>require.ensure 引入但是不执行   要在函数里面载 require一次才执行</p><h3 id="动态加载-import"><a href="#动态加载-import" class="headerlink" title="动态加载 import"></a>动态加载 import</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lan === <span class="string">'en'</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackchunkname: m1 */</span> <span class="string">'./module1.js'</span> )</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackchunkname: m2 */</span> <span class="string">'./module2.js'</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态加载 一旦加载进来就会被执行</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://sebastianblade.com/using-webpack-to-achieve-long-term-cache/#id" target="_blank" rel="noopener">什么是持久化缓存？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书笔记-linux私房菜</title>
      <link href="/2018/05/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-linux%E7%A7%81%E6%88%BF%E8%8F%9C/"/>
      <url>/2018/05/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-linux%E7%A7%81%E6%88%BF%E8%8F%9C/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/30/16589ca3f1ed8032?w=1334&amp;h=738&amp;f=png&amp;s=272222" alt="linux"></p><blockquote><p>《Linux私房菜》阅读笔记整理</p></blockquote><a id="more"></a><h2 id="chapter-0"><a href="#chapter-0" class="headerlink" title="chapter 0"></a>chapter 0</h2><p>计算机的五大单元 - 输入 输出 CPU内部的控制单元和算数逻辑单元 内存</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p> central processing unit</p><p> 主要作用，管理和运算 （算数逻辑单元，控制单元） - 前者负责程序运算和逻辑判断 后者负责协调各个组件与各个单元之间的工作</p><p> CPU的重点在与 运算和判断，这些数据来自于内存. 内存则从输入单元传输进来，CPU处理完毕之后先传递给内存，再从内存传输到输出单元</p><p>目前主流的CPU是双核以上，原本的单核是指仅有一个运算单元，多核是指在一个CPU壳子里装了多个运算内核</p><h4 id="CPU-的性能对比"><a href="#CPU-的性能对比" class="headerlink" title="CPU 的性能对比"></a>CPU 的性能对比</h4><p>1 内部的微指令集</p><p>2 CPU的频率 – 每秒CPU的工作次数  这个数值越高 代表单位时间内可以做更多的事情</p><p>比如某款CPU频率 3GHZ 则其每秒可进行 3 x 10的9次方 工作</p><h4 id="外频-倍频"><a href="#外频-倍频" class="headerlink" title="外频 倍频"></a>外频 倍频</h4><p>为了加速计算速度，CPU开发商就在CPU内部加上一个加速功能</p><p>外频 ： CPU与外部组件进行数据传输，运算的频率</p><p>倍频： CPU内部用来加速性能的一个倍数</p><p>两者相乘才是CPU的频率</p><ul><li>超频 – 有人喜欢将CPU的倍频或者外频通过主板的设定更改为较高频率，但因为CPU的倍频一般在出厂的时候会被确定无法更改，所以一般修改的是外频</li></ul><p>比如 3GHZ的CPU设置为超频 可以将外频 333HZ 调整到 400 MHZ 这样主板各个组件运行频率增高 CPU可以到达 3.6GHZ  但是可能造成死机</p><h3 id="软件程序运行"><a href="#软件程序运行" class="headerlink" title="软件程序运行"></a>软件程序运行</h3><p>设计出一种人类能看懂的语言，然后创造一种“编译器”来将人类写的程序语言转换为机器语言，常见的编译器语言，c c++</p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>一组程序，用来管理计算机所有活动以及驱动系统中所有硬件</p><p>让CPU开始判断逻辑与运算数值，让内存开始加载数据</p><p>以上就是操作系统的内核</p><p>硬件由内核管理，那想要去开发软件，就需要去参考这个内核的先关功能，因此操作系统提供了一组开发接口出来</p><p>1 操作系统的内核是参考硬件规格写的，所以同一个操作系统不能在不同的硬件架构下运行</p><p>2 应用程序的开发是参考操作系统提供的开发接口，所以该应用程序只能在该操作系统中运行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 直接操作一个硬件设施</span></span><br><span class="line">音箱 -- 请播放音乐 “黑白格”</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用内核</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span> (<span class="params">music</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="string">'音箱'</span></span><br><span class="line">  target.播放音乐(music)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，window的软件不能再Linux中运行</p><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核主要在于管理硬件，提供合理的资源分配，比如CPU资源 内存使用资源等</p><ul><li>程序管理</li></ul><p>多任务环境 — 一部计算机可能同时有很多工作在等待CPU运算处理，内核需要控制这些工作，让CPU做有效分配</p><p>良好的CPU调度机制（CPU先让那个工作开始运行），可以加快整体系统性能</p><ul><li>内存管理</li></ul><p>控制系统的内存</p><p>系统所有的程序代码和数据都必须要先放在内存里</p><ul><li>文件系统管理</li></ul><p>比如数据输入输出 I/O</p><p>如果内核不认识某个文件系统，则无法使用此格式的文件</p><ul><li>设备驱动</li></ul><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>CPU读取的数据都来自与内存，不管是软件程序还是数据，都要先读入内存才可以被使用</p><p>个人计算机的内存为</p><p>内存容量也很重要，因为数据要先存入内存中</p><p>一般内存越大 系统越快，因为不用释放内存内部数据</p><h5 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h5><p>存储数据，实际的数据是写在具有磁性物质的盘片上</p><h4 id="linux-vs-unix"><a href="#linux-vs-unix" class="headerlink" title="linux vs unix"></a>linux vs unix</h4><h2 id="chapter-1"><a href="#chapter-1" class="headerlink" title="chapter 1"></a>chapter 1</h2><p>什么是Linux</p><blockquote><p>linux 就是一套操作系统</p></blockquote><p>计算机由一堆硬件设备组成，操作系统用户管理控制这些硬件资源（内核）</p><p>不止如此，为了程序员可以更好的开发软件，操作系统还提供了一组系统调用接口</p><p>Linux 提供了一个完整的操作系统中，最底层的硬件控制和资源管理的完整架构，这个是沿用Unix而来的，相当稳定且强大</p><h3 id="Linux-distributions"><a href="#Linux-distributions" class="headerlink" title="Linux distributions"></a>Linux distributions</h3><p>linux 是操作系统最底层的内核以及其提供的内核管理工具，任何都可以获取源码并执行这个内核程序</p><p>随着Linux使用者逐渐增多，可以在Linux上运行的软件也越来越多，Linux + 各种软件 就可以是一个相当完整的操作系统</p><p>为了让用户可以接触到Linux，有人将 Linux 与可运行的软件集成起来，加上 一个可以让用户以光盘或者网络直接安装或者管理Linux系统，我们称这一整套 可完全安装的系统为 Linux distribution — 可完全安装套件</p><ul><li>常见的几个 Linux distribution  </li></ul><p>red hat - 红帽子</p><p>ubuntu – 无班图</p><p>centos</p><ul><li><p>Linux distribution 使用的都是 <a href="http://www.kernel.org" target="_blank" rel="noopener">www.kernel.org</a> 中提供的Linux内核，各家使用的软件大同小异，最大的差别在于软件的安装模式</p></li><li><p>查看当前是什么  distribution</p></li></ul><figure class="highlight ls"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="chapter-3"><a href="#chapter-3" class="headerlink" title="chapter 3"></a>chapter 3</h2><p>每一个组件或者设备在Linux下都是一个文件</p><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>主要有 盘片 机械手臂 主轴马达组成</p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>最简单的分区：  区分根目录 \ 与内存交换空间 swap 即可</p><p>稍微麻烦一点：将一些读写频繁的重要目录，与根目录独立出来，比如 /, /usr, /var 等</p><h2 id="chapter4"><a href="#chapter4" class="headerlink" title="chapter4"></a>chapter4</h2><p>###</p><p>内存交换空间是指？</p><p>当有数据被存放在物理内存中，但是这些数据不是常被CPU所取用，那么这些不常被使用的程序将会被丢到硬盘的swap交换空间中，而将速度较快的物理内存空间释放出来给真正需要的程序使用</p><p>所以如果系统不忙，内存又打，就不需要swap了</p><h2 id="chapter-5"><a href="#chapter-5" class="headerlink" title="chapter 5"></a>chapter 5</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="命令的格式"><a href="#命令的格式" class="headerlink" title="命令的格式"></a>命令的格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commond [option]</span><br></pre></td></tr></table></figure><ul><li><p>区分大小写</p></li><li><p>按下enter之后开始执行命令</p></li></ul><hr><h4 id="一些简单的命令"><a href="#一些简单的命令" class="headerlink" title="一些简单的命令"></a>一些简单的命令</h4><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>date</td><td>获取日期</td></tr><tr><td>cal</td><td>获取日历</td></tr><tr><td>bc</td><td>进入计算器模式</td></tr></tbody></table><ul><li>cal</li></ul><p>只是输入 cal 是展示当前月份的日历</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cal <span class="comment">// 当前月份</span></span><br><span class="line">cal <span class="number">2018</span> <span class="comment">// 2018的所有月</span></span><br><span class="line">cal <span class="number">8</span> <span class="number">2018</span> <span class="comment">// 2018 8月</span></span><br></pre></td></tr></table></figure><ul><li>bc 进入计算器模式</li></ul><p>输入 quit 然后回车 可以自动退出计算器模式</p><hr><h4 id="重要的按键"><a href="#重要的按键" class="headerlink" title="重要的按键"></a>重要的按键</h4><ul><li><p>tab 命令补齐 和 文件名补齐</p></li><li><p>ctr + c 终止当前命令</p></li></ul><h3 id="Linux在线求助-man-page"><a href="#Linux在线求助-man-page" class="headerlink" title="Linux在线求助 man page"></a>Linux在线求助 man page</h3><p>比如想查看关于date 命令的一些信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man date</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f146c34330a1?w=515&amp;h=144&amp;f=png&amp;s=18426" alt="man date"></p><p> 看下第一行这里是个 DATE(1)</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f161b38441d0?w=707&amp;h=106&amp;f=png&amp;s=8792" alt="1"></p><p>这里的数字含义是 （这里列几个常见的）</p><table><thead><tr><th>数字</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>用户在shell环境中可操作的命令或者更可执行的文件</td></tr><tr><td>4</td><td>设备文件</td></tr><tr><td>5</td><td>配置文件或者是某些文件的格式</td></tr><tr><td>8</td><td>系统管理员可用的管理命令</td></tr></tbody></table><h3 id="Linux在线求助-info-page"><a href="#Linux在线求助-info-page" class="headerlink" title="Linux在线求助 info page"></a>Linux在线求助 info page</h3><p>另外一种在线求助命令 info page</p><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p>关机 shutdown</p><p>数据同步写入硬盘 sync</p><p>重启 reboot halt poweroff</p><p>数据在计算机中运行的模式: 所有的数据都得要被读入内存后才能够被CPU所处理，但是数据又常常需要由内存写回硬盘当中(例如储存的动作)。 由于硬盘的速度太慢(相对于内存来说)，如果常常让数据在内存与硬盘中来回写入/读出，系统的效能就不会太好</p><p>因此在Linux系统中，为了加快数据的读取速度，所以在默认的情况中， 某些已经加载内存中的数据将不会直接被写回硬盘，而是先缓存在内存当中，如此一来， 如果一个数据被你重复的改写，那么由于他尚未被写入硬盘中，因此可以直接由内存当中读取出来， 在速度上一定是快上相当多的！</p><p>不过，如此一来也造成些许的困扰，那就是万一你的系统因为某些特殊情况造成不正常关机 (例如停电或者是不小心踢到power)时，由于数据尚未被写入硬盘当中，会造成数据不正常啦！ 那要怎么办呢？这个时候就需要sync这个命令来进行数据的写入动作啦！ 直接在文字接口下输入sync，那么在内存中尚未被升级的数据，就会被写入硬盘中！所以，这个命令在系统关机或重新启动之前，最好多运行几次</p><p>目前的 shutdown/reboot/halt 等等命令均已经在关机前进行了 sync 命令</p><h2 id="chapter-6"><a href="#chapter-6" class="headerlink" title="chapter 6"></a>chapter 6</h2><blockquote><p>文件权限与目录配置</p></blockquote><h3 id="三种身份"><a href="#三种身份" class="headerlink" title="三种身份"></a>三种身份</h3><p>文件所有者、用户组、其他人</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/30/1658a0820fcda606?w=588&amp;h=357&amp;f=png&amp;s=105147" alt="身份"></p><p>系统中所有的帐号与一般身份使用者，以及root的相关信息， 都是记录在/etc/passwd文件中，每个人的密码则是记录在/etc/shadow文件中，此外，所有的组群名称记录在/etc/group文件中</p><ul><li>用户</li></ul><blockquote><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统</p></blockquote><ul><li>用户组</li></ul><blockquote><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建</p></blockquote><h3 id="ls-al-查看当前目录下文件的信息"><a href="#ls-al-查看当前目录下文件的信息" class="headerlink" title="ls -al 查看当前目录下文件的信息"></a>ls -al 查看当前目录下文件的信息</h3><p>ls 显示文件的文件名和相关属性</p><p>al 列出文件详细的权限的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--   <span class="number">1</span> zhengzaijiazai  staff       <span class="number">66</span>  <span class="number">4</span> <span class="number">25</span> <span class="number">10</span>:<span class="number">21</span> .gitignore</span><br><span class="line">drwxr-xr-x   <span class="number">2</span> zhengzaijiazai  staff       <span class="number">68</span>  <span class="number">4</span> <span class="number">25</span> <span class="number">11</span>:<span class="number">32</span> dist</span><br></pre></td></tr></table></figure><ul><li>drwxr-xr-x  </li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/30/1658a3f94f0bb84a?w=1326&amp;h=528&amp;f=png&amp;s=113676" alt="rwx"></p><p>d rwx r-x r-x</p><p>按照 1 3 3 3 的格式进行拆分</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>第一个字符 代表这个是目录 文件 或者 链接文件等</td></tr><tr><td>rwx</td><td>文件所有者的权限</td></tr><tr><td>r-x</td><td>文件同用户组的权限</td></tr><tr><td>r-x</td><td>其他非本用户的权限</td></tr></tbody></table><p>r （read）可读 w （write） 可写 x （execute）可执行</p><h3 id="文件权限的意义"><a href="#文件权限的意义" class="headerlink" title="文件权限的意义"></a>文件权限的意义</h3><h4 id="对于文件"><a href="#对于文件" class="headerlink" title="对于文件"></a>对于文件</h4><p>r 代表是否能查看文件的内容<br>w 代表能否对文件的内容进行操作，但是不能删除文件<br>x 代表能否被系统执行</p><h4 id="对于目录"><a href="#对于目录" class="headerlink" title="对于目录"></a>对于目录</h4><p>目录的主要内容是记录文件名列表</p><p>r 表示可以读取目录结构列表</p><p>w 表示具有更改目录列表的权限</p><table><thead><tr><th>w权限对于文件的含义</th></tr></thead><tbody><tr><td>创建新的文件与目录</td></tr><tr><td>删除文件和目录（不管文件权限）</td></tr><tr><td>将已存在的文件与目录重命名</td></tr><tr><td>移动文件，目录位置</td></tr></tbody></table><p>总而言之，目录的w权限与该目录下的文件名变动有关系</p><p>x 表示用户能否进入目录  比如cd 进入此目录</p><hr><h4 id="test-time"><a href="#test-time" class="headerlink" title="test time"></a>test time</h4><p>有一个目录权限为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr--r-- 3 root root .......</span><br></pre></td></tr></table></figure><p>当前系统账号为 userA  userA不属于root组 那么 userA 对于这个账户有什么权限， 能切换到此目录中吗</p><ul><li>answer</li></ul><p>userA 具有 读的权限</p><p>而进行目录切换是需要X的权限 所以不可以切换到此目录</p><hr><h3 id="修改文件的属性、权限"><a href="#修改文件的属性、权限" class="headerlink" title="修改文件的属性、权限"></a>修改文件的属性、权限</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>chgrp xxx filename</td><td>改变文件所属用户组</td></tr><tr><td>chown xxx filename</td><td>改变文件所有者</td></tr><tr><td>chmod xxx filename</td><td>改变文件的权限</td></tr></tbody></table><h4 id="chgrp-change-group"><a href="#chgrp-change-group" class="headerlink" title="chgrp  (change group)"></a>chgrp  (change group)</h4><p>要改的那个组必须在 /etc/group 中存在 否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp read.md groupB</span><br></pre></td></tr></table></figure><h4 id="chown-change-owner"><a href="#chown-change-owner" class="headerlink" title="chown (change owner)"></a>chown (change owner)</h4><p>要改的那个用户必须在 /etc/passwd 中有记录 否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown read.md userB</span><br></pre></td></tr></table></figure><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><h4 id="chmod-改变权限"><a href="#chmod-改变权限" class="headerlink" title="chmod 改变权限"></a>chmod 改变权限</h4><ul><li>使用分数</li></ul><p>使用分数也可以代表权限</p><table><thead><tr><th>命令</th><th>分数</th></tr></thead><tbody><tr><td>r</td><td>4</td></tr><tr><td>w</td><td>2</td></tr><tr><td>x</td><td>1</td></tr></tbody></table><p>rwx 7<br>rw- 6<br>r-x 5</p><ul><li>使用符号类型</li></ul><p>有三种身份，就用 u g o 代表三种身份的权限</p><table><thead><tr><th>身份</th><th>字符</th></tr></thead><tbody><tr><td>用户</td><td>u</td></tr><tr><td>用户组</td><td>g</td></tr><tr><td>其他人</td><td>o</td></tr><tr><td>所有身份</td><td>a</td></tr></tbody></table><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>增加</td></tr><tr><td>-</td><td>减去</td></tr><tr><td>=</td><td>设置</td></tr></tbody></table><p>比如 需要设置一个文件的权限为 -rwxr-xr-x</p><p>则u 为rwx  g/o 为 r-x</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,go=rx readme.md</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是给每一身份增加 w 权限</span></span><br><span class="line">chmod a+w read.md</span><br></pre></td></tr></table></figure><h3 id="文件种类"><a href="#文件种类" class="headerlink" title="文件种类"></a>文件种类</h3><p>任何设备都是文件</p><p>使用 ls -l 中第一个字符就是文件种类</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>普通文件文件</p><p>ls -al 所显示出来的属性方面，第一个字符为 [ - ]，例如 [-rwxrwxrwx ]。另外，依照文件的内容，又大略可以分为：纯文本 二进制文件  数据格式文件</p></li><li><p>目录</p></li><li><p>链接文件</p></li></ul><p>比如： 快捷方式</p><ul><li>设备与设备文件</li></ul><h4 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h4><p>与 window中的有很大不同</p><p>在Windows底下， 能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ] 即代表这个文件可以被执行</p><p>通常我们还是会以适当的扩展名来表示该文件是什么种类的。底下有数种常用的扩展名：</p><p>1  .sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh ；</p><p>2 .Z, .tar, .zip ： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名</p><p>3 .html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件</p><p>基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行</p><p>例如虽然有一个文件为可执行文件， 如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时， 那么ls就变成不能执行</p><h3 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h3><h4 id="标准-FHS"><a href="#标准-FHS" class="headerlink" title="标准 FHS"></a>标准 FHS</h4><p>为什么每套Linux distributions他们的配置文件啊、执行文件啊、每个目录内放置的咚咚啊，其实都差不多？ 原来是有一套标准依据的</p><p>Linux来开发产品或distributions的社群/公司与个人实在太多了，如果每一个人都按照自己的标准去配置文件目录，可能有管理上的困扰</p><p>FHS 用于规范每个特定目录下应该要放置什么数据</p><p>FHS针对目录树定义了三个目录下应该放置什么数据</p><table><thead><tr><th>目录</th><th>含义</th></tr></thead><tbody><tr><td>/ (root 根目录)</td><td>与开机系统有关系</td></tr><tr><td>/usr</td><td>与软件的安装、执行有关系</td></tr><tr><td>/var</td><td>与系统运作过程有关系</td></tr></tbody></table><p>usr （UNIX Software Resource）Unix操作系统软件资源</p><p>FHS 定义（/）根目录下需要有以下目录</p><table><thead><tr><th>目录</th><th>文件内容</th></tr></thead><tbody><tr><td>/bin</td><td>执行文件，在/bin 下的命令 可以被root和一般账号使用,比如 cat cp等</td></tr><tr><td>/etc</td><td>系统主要配置文件，例如账号密码文件，何种服务的启示文件</td></tr><tr><td>/tmp</td><td>正在执行的程序放置文件的地方 FHS建议在开机时将 /tmp下的数据删除</td></tr></tbody></table><p>/usr </p><p>是系统默认的软件安装目录</p><p>下面比较常见的目录</p><table><thead><tr><th>目录</th><th>文件内容</th></tr></thead><tbody><tr><td>/bin</td><td>用户可使用的命令</td></tr></tbody></table><p>/var </p><p>在系统安装之后，会慢慢占用硬盘容量</p><hr><p>Q: 请问在 /bin 与 /usr/bin 有什么不同</p><p>A:</p><p>/bin是系统的一些指令</p><p>bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等</p><p>/usr/bin　是你在后期安装的一些软件的运行脚本</p><p>主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome<em>、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb</em>、wget等</p><hr><h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><ul><li>绝对路径</li></ul><p>由根目录开始写起的文件名或者目录</p><ul><li>相对路径</li></ul><p>相对于当前路径</p><p>~ 代表当前用户的家目录  或者 使用cd 回车 也可以进入</p><p>/ 代表根目录</p><h2 id="chapter-7-目录相关"><a href="#chapter-7-目录相关" class="headerlink" title="chapter 7  目录相关"></a>chapter 7  目录相关</h2><h3 id="特殊的目录"><a href="#特殊的目录" class="headerlink" title="特殊的目录"></a>特殊的目录</h3><table><thead><tr><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>本层目录</td></tr><tr><td>..</td><td>上一层目录</td></tr><tr><td>-</td><td>前一个工作目录</td></tr></tbody></table><hr><p>Q: 请问在Linux的根目录，有没有上层目录 （..） 的存在</p><p>A:</p><p>用普通用户身份看下</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658ee9594bd648f?w=958&amp;h=138&amp;f=png&amp;s=26969" alt="dir"></p><p>用root身份看一下</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658ef5c2c9cb3be?w=780&amp;h=78&amp;f=png&amp;s=17684" alt="dir"></p><hr><h3 id="操作文件与目录"><a href="#操作文件与目录" class="headerlink" title="操作文件与目录"></a>操作文件与目录</h3><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换目录 change directory</td></tr><tr><td>pwd</td><td>显示当前目录</td></tr><tr><td>mkdir</td><td>创建新目录</td></tr><tr><td>rmdir</td><td>删除空目录</td></tr><tr><td>cp</td><td>复制</td></tr><tr><td>mv</td><td>移动</td><td>重命名文件与目录</td></tr></tbody></table><ul><li>创建目录 mkdir</li></ul><p>mkdir 只能一层一层的创建目录， 如何一次性创建多层目录 – 借助 -p 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p webpack/w1-code/dist</span><br></pre></td></tr></table></figure><ul><li>删除目录</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir config</span><br></pre></td></tr></table></figure><p>只能删除一个空目录</p><p>如果要强制删除一个非空目录及它下面的全部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r node_modules</span><br></pre></td></tr></table></figure><ul><li>查看目录</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a <span class="comment">// 显示全部，连同隐藏的文件</span></span><br></pre></td></tr></table></figure><ul><li>mv</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将某一个文件移动到文件夹中</span></span><br><span class="line">mv mian.js newdir</span><br><span class="line"><span class="comment">// 重命名文件夹</span></span><br><span class="line">mv oldDir newdir</span><br></pre></td></tr></table></figure><ul><li>cp 复制</li></ul><p>复制文件需要有 r (可读) 权限</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制index 文件到 当前位置</span></span><br><span class="line">cp ./config/index.js .</span><br></pre></td></tr></table></figure><p>默认条件中，cp的源文件与目的文件权限不同，目的文件的所有者是命令操作者本身</p><h3 id="查阅文件内容"><a href="#查阅文件内容" class="headerlink" title="查阅文件内容"></a>查阅文件内容</h3><h4 id="file-查询文件类型"><a href="#file-查询文件类型" class="headerlink" title="file 查询文件类型"></a>file 查询文件类型</h4><p>判断文件是二进制文件？数据文件?</p><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>查询命令所在的文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which ifconfig</span><br></pre></td></tr></table></figure><p>which 默认查找的是 PATH 内的目录</p><h4 id="cat-（Concatenate-连续）"><a href="#cat-（Concatenate-连续）" class="headerlink" title="cat （Concatenate 连续）"></a>cat （Concatenate 连续）</h4><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cat</td><td>查看内容</td></tr><tr><td>cat -n</td><td>查看内容 显示行号</td></tr><tr><td>cat -b</td><td>查看内容 显示行号 【空白部分不算行号】</td></tr></tbody></table><h4 id="nl-添加行号打印"><a href="#nl-添加行号打印" class="headerlink" title="nl 添加行号打印"></a>nl 添加行号打印</h4><p>nl 可以将输出的内容自动加上行号  默认结果与cat -n有点类似</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f1e27abf323e?w=854&amp;h=306&amp;f=png&amp;s=61247" alt="nl"></p><ul><li>nl [-bnw] filename</li></ul><table><thead><tr><th>-b 命令</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>空行也添加行号</td></tr><tr><td>t</td><td>空行不添加行号</td></tr></tbody></table><table><thead><tr><th>-n 命令</th><th>含义</th></tr></thead><tbody><tr><td>ln</td><td>行号在左侧显示</td></tr><tr><td>rn</td><td>行号在右侧显示 不加0</td></tr><tr><td>rz</td><td>行号在右侧显示 加0</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl index.js</span><br><span class="line"></span><br><span class="line">nl -b a index.js 空行也添加行号</span><br></pre></td></tr></table></figure><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>前面提到的nl  cat 是一次性将所有内容展示到命令行 more 则是 有翻页功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more index.js</span><br></pre></td></tr></table></figure><table><thead><tr><th>-n 命令</th><th>含义</th></tr></thead><tbody><tr><td>空格</td><td>向下翻一页</td></tr><tr><td>enter 或者 向下键</td><td>向下滚动一行</td></tr><tr><td>q</td><td>退出显示</td></tr></tbody></table><ul><li>查找功能</li></ul><p>按下 / 然后输入 要查找的字符  [但是没有发现有任何高亮提示]</p><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>less 的用法要比more  增加了向上翻页功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less index.js</span><br></pre></td></tr></table></figure><ul><li>查找功能</li></ul><p>按下 / 然后输入 要查找的字符  [向下查询]<br>按下 ? 然后输入 要查找的字符  [向上查询]</p><h4 id="选择数据-head-tail"><a href="#选择数据-head-tail" class="headerlink" title="选择数据 head tail"></a>选择数据 head tail</h4><ul><li>head 从前面开始展示</li></ul><p>选取数据展示几行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [-n number] filename</span><br></pre></td></tr></table></figure><p>number 表示展示几行 默认展示前10行</p><ul><li>tail 从后面开始展示</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [-n number] filename</span><br></pre></td></tr></table></figure><p>number 表示展示几行 默认展示最后10行</p><hr><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f2e5f6b5a8f0?w=1426&amp;h=186&amp;f=png&amp;s=151283" alt="think"></p><p>获取第 100 到 120 行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename | head -n <span class="number">120</span> | tail -n +<span class="number">100</span></span><br></pre></td></tr></table></figure><p>从 100 行开始 显示 50行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat filename | tail -n +<span class="number">100</span> | head -n <span class="number">50</span></span><br></pre></td></tr></table></figure><p>tail -n +100：从100行开始显示，显示100行以后的</p><hr><h3 id="文件的权限预设-umask"><a href="#文件的权限预设-umask" class="headerlink" title="文件的权限预设 umask"></a>文件的权限预设 umask</h3><p>当新建一个文件时，它的默认权限和umask有关系</p><blockquote><p>umask是用来指定当前用户在新建目录或文件时的权限预设值，具体来说，umask值只是一个掩码，它从创建文件时的默认权限中掩去对应位置的权限</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f30a89f6b22e?w=321&amp;h=83&amp;f=png&amp;s=12509" alt="umask"></p><p>0022 以数字形式表示权限</p><p>可以看到这里有四组权限，第一组是特殊权限使用的，我们平时只需要后面三个就可以了</p><p>u=rwx 以符号类型表示权限</p><p>在默认权限的属性，文件和目录是不同的</p><ul><li><p>用户创建一般文件，则默认取消可执行权限，即666（rw-rw-rw-）</p></li><li><p>用户创建目录文件，由于x与是否可以进入此目录有关，因此默认开放所有权限，即777（rwxrwxrwx）</p></li></ul><hr><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f2e5f6b5a8f0?w=1426&amp;h=186&amp;f=png&amp;s=151283" alt="think"></p><p>Q: 假设用户的umask是 003 则当其新建一个文件或者文件夹 的权限是什么</p><p>A： 也就是去掉的权限是 other的 写 w 与 x</p><p>文件 rw-rw-r–</p><p>文件夹 rwxrxwr–</p><hr><p>设置 umask</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask <span class="number">002</span></span><br></pre></td></tr></table></figure><h3 id="查询文件-find"><a href="#查询文件-find" class="headerlink" title="查询文件 find"></a>查询文件 find</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [指定路径] [指定条件] [指定动作]</span><br></pre></td></tr></table></figure><p>默认会查找当前目录及子目录，把查找结果输出到屏幕上</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f4e9701a19b7?w=341&amp;h=50&amp;f=png&amp;s=10808" alt="find"></p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>关于文件的三个时间参数</p><p>modification time (mtime)： 当该文件的『内容数据』变更时，就会升级这个时间！内容数据指的是文件的内容，而不是文件的属性或权限</p><p>status time (ctime)：当该文件的『状态 (status)』改变时，就会升级这个时间，举例来说，像是权限与属性被更改了，都会升级这个时间</p><p>access time (atime)：当『该文件的内容被取用』时，就会升级这个读取时间 (access)。举例来说，我们使用 cat 去读取 /etc/man.config ， 就会升级该文件的 atime</p><p>在默认的情况下，ls 显示出来的是该文件的 mtime ，也就是这个文件的内容上次被更动的时间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l —time=ctime test.conf</span><br></pre></td></tr></table></figure><h3 id="权限和文件的关系"><a href="#权限和文件的关系" class="headerlink" title="权限和文件的关系"></a>权限和文件的关系</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f57d1bb390a5?w=1276&amp;h=346&amp;f=png&amp;s=57060" alt="important]"></p><ul><li>用户能进入某目录成为可工作目录的基本权限是什么</li></ul><table><thead><tr><th>条件</th><th>内容</th></tr></thead><tbody><tr><td>可使用命令</td><td>cd等切换工作目录</td></tr><tr><td>目录所需权限</td><td>x 要有可执行的权限</td></tr></tbody></table><ul><li>用户在某一个目录可以读取一个文件的基本权限是什么</li></ul><table><thead><tr><th>条件</th><th>内容</th></tr></thead><tbody><tr><td>可使用命令</td><td>cat more less tail head 等</td></tr><tr><td>目录所需权限</td><td>x 要有可执行的权限</td></tr><tr><td>文件所需权限</td><td>r 要有可读的权限</td></tr></tbody></table><ul><li>让用户修改一个文件的权限是什么</li></ul><table><thead><tr><th>条件</th><th>内容</th></tr></thead><tbody><tr><td>可使用命令</td><td>vi vim 等</td></tr><tr><td>目录所需权限</td><td>x 要有可执行的权限</td></tr><tr><td>文件所需权限</td><td>r w 要有可读可写的权限</td></tr></tbody></table><ul><li>让用户新建一个文件的基本权限是什么</li></ul><table><thead><tr><th>条件</th><th>内容</th></tr></thead><tbody><tr><td>可使用命令</td><td>touch 等</td></tr><tr><td>目录所需权限</td><td>w x 要有可读可执行的权限</td></tr></tbody></table><h3 id="PATH"><a href="#PATH" class="headerlink" title="$PATH"></a>$PATH</h3><p>为什么在任何地方都可以执行 ls 这个命令呢 – 环境变量 PATH</p><p>系统会依照PATH的设置去每个定义PATH的目录下查询文件名为ls的可执行文件，如果在PATH定义的目录中含有多个文件名为ls的可执行文件，那么先查询的同名命令则先被执行</p><p>1 ls 是一个可执行文件<br>2 根源在 /bin/ls （也就是执行ls 与执行 /bin/ls 是同样的效果）<br>3 问题变为，为什么随时可以执行 /bin/ls 这个文件<br>4 系统按照 PATH 的设置每一个 path的定义目录下 查询名为ls的可执行文件<br>5 先找到的被执行</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/1/16593717f9ab1cd9?w=1358&amp;h=90&amp;f=png&amp;s=60417" alt="PATH"></p><p>不同身份的 默认的path 不同，默认能够随意运行的命令也不同(如root与vbird)</p><p>PATH是可以修改的</p><h2 id="chapter-8-磁盘和文件管理"><a href="#chapter-8-磁盘和文件管理" class="headerlink" title="chapter 8 磁盘和文件管理"></a>chapter 8 磁盘和文件管理</h2><p><img src="https://user-gold-cdn.xitu.io/2018/9/17/165e76acad896d76?w=712&amp;h=249&amp;f=png&amp;s=85751" alt="inode"></p><h3 id="EXT2"><a href="#EXT2" class="headerlink" title="EXT2"></a>EXT2</h3><p>Linux最传统的磁盘文件系统(filesystem)使用的是EXT2</p><p>磁盘分区指的是告诉操作系统 这个磁盘在此分割槽可以存取的区域是由 A 磁柱到 B 磁柱之间的区块</p><p>如此一来操作系统就能够知道他可以在所指定的区块内进行文件数据的读/写/搜寻等动作了。 也就是说，磁盘分区意即指定分割槽的启始与结束磁柱</p><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>磁盘在做分区之后还需要格式化，这是因为每种操作系统所配置的文件属性/权限并不相同， 为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的文件系统格式</p><ul><li>文件系统的运行</li></ul><p>这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外， 通常含有非常多的属性</p><p>例如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中</p><p>另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>inode</td><td>记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码</td></tr><tr><td>block</td><td>实际记录文件的内容，若文件太大时，会占用多个 block</td></tr><tr><td>superblock</td><td>记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等</td></tr></tbody></table><p><img src="http://cn.linux.vbird.org/linux_basic/0230filesystem_files/filesystem-1.jpg" alt="block"></p><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>inode 的内容在记录文件的权限与相关属性，至于 block 区块则是在记录文件的实际内容</p><p>而文件系统一开始就将 inode 与 block 规划好了，除非重新格式化，否则 inode 与 block 固定后就不再变动</p><p>Ext2 文件系统在格式化的时候基本上是区分为多个区块群组 (block group) 的，每个区块群组都有独立的 inode/block/superblock 系统</p><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>data block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已。在格式化时 block 的大小就固定了</p><p>1 原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)<br>2 每个 block 内最多只能够放置一个文件的数据<br>3 承上，如果文件大于 block 的大小，则一个文件会占用多个 block 数量<br>4 承上，若文件小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)</p><hr><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f2e5f6b5a8f0?w=1426&amp;h=186&amp;f=png&amp;s=151283" alt="think"></p><p>Q: 假设你的Ext2文件系统使用 4KB de  block ，而该文件系统中有 10000 个小文件，每个文件大小均为 50 bytes， 请问此时你的磁盘浪费多少容量？</p><p>A:</p><p>4kb = 4 * 1024 bytes = 4096 bytes</p><p>所以每一个会浪费 4096 - 50 bytes</p><p>所以公共会是 4046 * 10000 bytes = 38.585666 = 38.6MB</p><hr><h4 id="与目录树的关系"><a href="#与目录树的关系" class="headerlink" title="与目录树的关系"></a>与目录树的关系</h4><ul><li>文件目录</li></ul><p>当我们在 Linux 下的 ext2 文件系统创建一个目录时， ext2 会分配一个 inode 与至少一块 block 给该目录</p><p>其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码</p><p>而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据</p><ul><li>文件</li></ul><p>当我们在 Linux 下的 ext2 创建一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件</p><p>例如：假设我的一个 block 为 4 Kbytes ，而我要创建一个 100 KBytes 的文件，那么 linux 将分配一个 inode 与 25 个 block 来储存该文件</p><p>inode 本身并不记录文件名，文件名的记录是在目录的 block 当中。 因此在第六章文件与目录的权限说明中， 我们才会提到『新增/删除/更名文件名与目录的 w 权限有关』</p><p>因为文件名是记录在目录的 block 当中， 因此当我们要读取某个文件时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码， 最终才会读到正确的文件的 block 内的数据</p><h3 id="文件系统的操作"><a href="#文件系统的操作" class="headerlink" title="文件系统的操作"></a>文件系统的操作</h3><p>所有的数据都得要加载到内存后 CPU 才能够对该数据进行处理</p><p>想一想，如果你常常编辑一个好大的文件， 在编辑的过程中又频繁的要系统来写入到磁盘中，由于磁盘写入的速度要比内存慢很多， 因此你会常常耗在等待硬盘的写入/读取上</p><p>为了解决这个效率的问题, Linux 使用的方式是透过一个称为异步处理 (asynchronously) 的方式</p><p>当系统加载一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被配置为干净(clean)的。 但如果内存中的文件数据被更改过了(例如你用 nano 去编辑过这个文件)，此时该内存中的数据会被配置为脏的 (Dirty)。此时所有的动作都还在内存中运行，并没有写入到磁盘中！ 系统会不定时的将内存中配置为『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性</p><p>由于内存的速度要比硬盘快的多，因此如果能够将常用的文件放置到内存当中，这样就会大大提升系统性能</p><ul><li>Linux 系统上面文件系统与内存有非常大的关系:</li></ul><p>1 系统会将常用的文件数据放置到主存储器的缓冲区，以加速文件系统的读/写<br>2 承上，因此 Linux 的物理内存最后都会被用光！这是正常的情况！可加速系统效能<br>3 你可以手动使用 sync 来强迫内存中配置为 Dirty 的文件回写到磁盘中<br>4 若正常关机时，关机命令会主动呼叫 sync 来将内存的数据回写入磁盘内<br>5 不正常关机(如跳电、死机或其他不明原因)，由于数据尚未回写到磁盘内， 因此重新启动后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁(非磁盘损毁)</p><h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>文件系统与目录树的结合操作称之为挂载 挂载点一定是目录 这样才能使用文件系统</p><h4 id="磁盘和目录容量"><a href="#磁盘和目录容量" class="headerlink" title="磁盘和目录容量"></a>磁盘和目录容量</h4><p>磁盘的整体数据是在 superblock 区块中，但是每个各别文件的容量则在 inode 当中记载的</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>df</td><td>列出文件系统的整体磁盘使用量</td></tr><tr><td>du</td><td>评估文件系统的磁盘使用量(常用在推估目录所占容量)</td></tr></tbody></table><ul><li>df</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/9/18/165ec529561059b3?w=475&amp;h=361&amp;f=png&amp;s=62665" alt="df"></p><p>由于 df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在 Superblock 内的信息， 所以这个命令显示结果的速度非常的快速</p><ul><li>du</li></ul><p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据</p><p>在默认的情况下，容量的输出是以 KB 来设计的， 如果你想要知道目录占了多少 MB ，那么就使用 -m 这个参数即可</p><h3 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h3><h4 id="hard-id-link"><a href="#hard-id-link" class="headerlink" title="hard id_link"></a>hard id_link</h4><p>新建一个文件名 链接到 某个inode 号码</p><h4 id="symbolic-link"><a href="#symbolic-link" class="headerlink" title="symbolic link"></a>symbolic link</h4><p>Symbolic link 就是在创建一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的文件名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ln [-sf] 源文件 目标文件</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不添加参数就是 hard link</span></span><br><span class="line"><span class="comment">// 添加参数 -s 就是 symbolic link</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// f 如果目标文件存在 则先删除后再创建</span></span><br></pre></td></tr></table></figure><h2 id="chapter-10-vim-编辑器"><a href="#chapter-10-vim-编辑器" class="headerlink" title="chapter 10 vim 编辑器"></a>chapter 10 vim 编辑器</h2><p>vi 文本编辑器 vim 程序开发工具</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f72e1d3e2908?w=862&amp;h=324&amp;f=png&amp;s=402401" alt="vim"></p><h3 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h3><p>vi 共分为三种模式，分别是『一般模式』、『编辑模式』与『指令列命令模式』</p><h4 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h4><p>以 vi 打开一个档案就直接进入一般模式了(这是默认的模式)</p><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><p>一般模式当中, 按下『i, I, o, O, a, A, r, R』等任何一个字母之后会进入编辑模式</p><h4 id="指令列命令模式"><a href="#指令列命令模式" class="headerlink" title="指令列命令模式"></a>指令列命令模式</h4><p>一般模式当中，输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一行</p><h2 id="chapter-11-bash"><a href="#chapter-11-bash" class="headerlink" title="chapter 11 bash"></a>chapter 11 bash</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f8db11cf2756?w=768&amp;h=324&amp;f=png&amp;s=12918" alt="Bash"></p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>需要计算机输出音乐,这个过程需要什么支持呢</p><p>1 硬件</p><p>需要你的硬件有声卡芯片</p><p>2 内核管理</p><p>需要操作系统的内核可以支持这个芯片组 还有芯片的驱动程序</p><p>3 应用程序</p><p>需要用户输入播放声音的指令</p><p>以上三点是一个简单的输出声音的步骤。就是用户需要输出一个命令，硬件才会执行这个命令来工作。而硬件如何知道你所执行的命令呢，那就是内核的控制工作了</p><p>我们需要通过shell将输入的命令与内核进行通信，这样内核就可以控制硬件来工作</p><p>操作系统是一组软件，这组软件在控制硬件与管理系统的活动监测。如果这组软件能被用户随意操作会导致系统崩溃。</p><p>所以不能让用户随意去使用。因此产生了一种在操作系统上的应用程序-&gt;shell</p><p>其实shell的功能只是提供用户操作系统的一个接口，因此这个shell需要可以调用其他软件。</p><blockquote><p>简而言之，只要能够操作应用程序的接口，都叫做shell</p></blockquote><h4 id="Linux的shell"><a href="#Linux的shell" class="headerlink" title="Linux的shell"></a>Linux的shell</h4><p>Linux有多种shell， 可以看下 /etc/shells</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658ffa0924d5b58?w=300&amp;h=125&amp;f=png&amp;s=6575" alt="shell"></p><p>各家的shell功能差不多，但是在某些语法执行方面不同。</p><p>Linux默认使用的是 bash</p><p>为什么我们系统上合法的 shell 要写入 /etc/shells 这个文件啊？ 这是因为系统某些服务在运行过程中，会去检查使用者能够使用的 shells ，而这些 shell 的查询就是藉由 /etc/shells 这个文件</p><p>我这个使用者什么时候可以取得 shell 来工作呢？还有， 我这个使用者默认会取得哪一个 shell ?</p><p>当我登陆的时候，系统就会给我一个 shell 让我来工作了。 而这个登陆取得的 shell 就记录在 /etc/passwd 这个文件内</p><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><p>bash 的几个优点</p><p>1 命令记忆功能</p><p>『上下键』可以追溯命令</p><p>~/.bash_history 记录的是前一次登陆以前所运行过的命令， 而至于这一次登陆所运行的命令都被缓存在内存中，当你成功的注销系统后，该命令记忆才会记录到 .bash_history 当中</p><p>2 命令与文件补全功能</p><p>tab 键</p><p>3 命名别名设置功能</p><p>查询  alias</p><p>设置  alias lm=‘ls -al’</p><p>4 作业控制，前台，后台控制</p><p>5 程序脚本</p><p>当登录到Linux后，会依据/etc/passwd 文件的设置来给一个shell（默认bash） 然后就可以依据上面的命令操作 shell</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>内部命令：由 bash 内置的命令</p><p>外部命令：来字外部的命令，非 bash 内置</p><p>查询一个命令是外部的还是bash内置的呢？ – type</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659e21ed11eb80b?w=236&amp;h=81&amp;f=png&amp;s=6984" alt="type"></p><p>可以看到 cd 这个命令是bash的内置命令</p><h3 id="shell-的变量功能"><a href="#shell-的变量功能" class="headerlink" title="shell 的变量功能"></a>shell 的变量功能</h3><p>Linux是多用户，多任务的环境，每个人在登录之后都会有一个bash。</p><p>显示当前使用的shell，可以输入：</p><p>echo $SHELL</p><ul><li>影响bash环境变量的操作</li></ul><p>那么由于在 Linux System 下面，所有的线程都是需要一个运行码， 『真正以 shell 来跟 Linux 沟通，是在正确的登陆 Linux 之后』这个时候你就有一个 bash 的运行程序，也才可以真正的经由 bash 来跟系统沟通</p><p>而在进入 shell 之前，也正如同上面提到的，由于系统需要一些变量来提供他数据的存取 (或者是一些环境的配置参数值， 例如是否要显示彩色等等的) ，所以就有一些所谓的『环境变量』 需要来读入系统中了！这些环境变量例如 PATH、HOME、MAIL、SHELL 等等</p><h4 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h4><p>变量在显示的时候，前面必须带着 $ 符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">echo $&#123;PATH&#125;</span><br><span class="line">cd $work</span><br></pre></td></tr></table></figure><h4 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">workdir=&apos;workapce/mxx&apos;</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量的设置规则</th></tr></thead><tbody><tr><td>变量名称只能是字母与数字，但开头不能为数字</td></tr><tr><td>双引号内的特殊字符可以保留原特性，比如$ 可正确读取字符串中的变量，单引号则不会</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;my name is $USER&quot;</span><br><span class="line">echo $name</span><br><span class="line">// mu name is tom</span><br><span class="line">&lt;!-- 如果是单引号 --&gt;</span><br><span class="line">name=&apos;my name is $USER&apos;</span><br><span class="line">echo $name</span><br><span class="line">// mu name is $USER</span><br></pre></td></tr></table></figure><h4 id="取消变量"><a href="#取消变量" class="headerlink" title="取消变量"></a>取消变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset workdir</span><br></pre></td></tr></table></figure><hr><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f2e5f6b5a8f0?w=1426&amp;h=186&amp;f=png&amp;s=151283" alt="think"></p><p>Q: 设置一个 变量代表 工作目录</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659e2a8b36c7672?w=690&amp;h=224&amp;f=png&amp;s=45268" alt="dir"><br><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659e36070deee98?w=742&amp;h=162&amp;f=png&amp;s=32175" alt="dir"></p><hr><p>在父进程中定义的变量是无法在子进程中使用的，比如你定义了这个变量，然后再重新发开一个进程，是读不到这个变量的</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659e38665af0146?w=742&amp;h=162&amp;f=png&amp;s=32175" alt="dir"></p><p>不过通过export将此变量设置为环境变量就可以使用了</p><p>比如，定义变量 TRYPATH=/HOME/EORK</p><p>写一个脚本</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $TRYPATH, <span class="number">123</span></span><br></pre></td></tr></table></figure><p>然后在当前进程中执行 sh test.sh</p><p>控制台无输出</p><p>如果 export TRYPATH=/HOME/EORK</p><p>就有信息输出了</p><h3 id="环境变量的功能"><a href="#环境变量的功能" class="headerlink" title="环境变量的功能"></a>环境变量的功能</h3><p>查询当前有哪些环境变量，可以使用两个命令 env export</p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>查询到目前shell环境下所有的环境变量</p><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>shell不只是有环境变量，还有各种自定义的变量</p><p>set查询所有的变量</p><h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>环境变量和自定义变量两者的差异在于 是否可以被子进程使用</p><p>子进程会继承父级进程的环境变量，不会继承父进程的自定义变量</p><p>export 可以将自定义变量转为环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export</span><br><span class="line"></span><br><span class="line">// export WORKDIR=$WORKDIR:workspace/blued-shopping/blued-shop</span><br></pre></td></tr></table></figure><p>可以看到目前所有的环境变量</p><h4 id="父进程？子进程？"><a href="#父进程？子进程？" class="headerlink" title="父进程？子进程？"></a>父进程？子进程？</h4><p>当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，被称为 PID 的就是。 接下来你在这个 bash 底下所下达的任何命令都是由这个 bash 所衍生出来的，那些被下达的命令就被称为子程序了。</p><ul><li>为什么子进程可以使用环境变量</li></ul><p>1 当创建一个shell时候，操作系统会分配一个记忆块给shell使用，此内存的变量可以给子进程使用</p><p>2 在父进程使用了 export ，就可以将自定义的变量写到上面的那个记忆块中</p><p>3 当加载另一个shell的时候（启动子进程，要离开父进程了）子shell可以将父shell的那个记忆块导入自己的环境变量块中</p><h4 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h4><p>Linux 主机里面同时登陆了十个人，这十个人不知怎么搞的， 同时开启了 100 个文件，每个文件的大小约 10MBytes ，</p><p>请问一下， 我的 Linux 主机的内存要有多大才够？ 10<em>100</em>10 = 10000 MBytes = 10GBytes … 内存占用量很大，所以可以限制这个大小</p><p>bash 可以限制用户的某些系统资源，比如文件打开数量，可用的CPU时间，可用内存总量等 ，这些通过 ulimit 进行设置</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659ea541a4d735c?w=375&amp;h=300&amp;f=png&amp;s=42143" alt="ulimit"></p><table><thead><tr><th>参数解析</th><th>含义</th></tr></thead><tbody><tr><td>unlimited</td><td>无限制</td></tr><tr><td>0</td><td>无限制</td></tr></tbody></table><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>查看历史命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history</span><br><span class="line">history 10</span><br><span class="line">history -w // 写入 ~./bash_history</span><br></pre></td></tr></table></figure><p>历史命令的读取与记录是这样的：</p><p>以 bash 登陆 Linux 主机之后，系统会主动的由家目录的 ~/.bash_history 读取以前曾经下过的命令，那么 ~/.bash_history 会记录几笔数据呢？这就与你 bash 的 HISTFILESIZE 这个变量配置值有关了！</p><p>假设我这次登陆主机后，共下达过 100 次命令，『等我注销时， 系统就会将 101~1100 这总共 1000 笔历史命令升级到 ~/.bash_history 当中。』 也就是说，历史命令在我注销时，会将最近的 HISTFILESIZE 笔记录到我的纪录文件当中啦！</p><p>当然，也可以用 history -w 强制立刻写入的！那为何用『升级』两个字呢？ 因为 ~/.bash_history 记录的笔数永远都是 HISTFILESIZE 那么多，旧的信息会被主动的拿掉！ 仅保留最新的！</p><h3 id="bash的操作环境"><a href="#bash的操作环境" class="headerlink" title="bash的操作环境"></a>bash的操作环境</h3><h4 id="路径和命令的查找顺序"><a href="#路径和命令的查找顺序" class="headerlink" title="路径和命令的查找顺序"></a>路径和命令的查找顺序</h4><p>在我们系统中存在多个名字相同的名字，那么 bash shell 究竟使用的是哪个命令呢？其遵循的顺序如下</p><p>1．以相对/绝对路径来执行命令<br>2．由 alias 找到命令来执行<br>3．由 bash 内置命令来执行<br>4．通过$PATH 的顺序找到的第一个命令来执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# alias echo=&apos;echo -n&apos;</span><br><span class="line">[root@localhost ~]# type -a echo</span><br><span class="line">echo is aliased to `echo -n&apos;</span><br><span class="line">echo is a shell builtin</span><br><span class="line">echo is /bin/echo</span><br></pre></td></tr></table></figure><p>可以看到先找alias在内置命令 最后PATH</p><h4 id="bash的登录信息"><a href="#bash的登录信息" class="headerlink" title="bash的登录信息"></a>bash的登录信息</h4><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659e6e8b3f200db?w=418&amp;h=123&amp;f=png&amp;s=20531" alt=""></p><p>这些都可以进行配置的</p><h3 id="shell-的配置文件"><a href="#shell-的配置文件" class="headerlink" title="shell 的配置文件"></a>shell 的配置文件</h3><p>怎么我们什么动作都没有进行，但是一进入 bash 就取得一堆有用的变量了？</p><p>这是因为系统有一些环境配置文件案的存在，让 bash 在启动时直接读取这些配置文件，以规划好 bash 的操作环境</p><p>这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。</p><p>我们前几个小节谈到的命令别名啦、自定义的变量啦，在你注销 bash 后就会失效，所以你想要保留你的配置， 就得要将这些配置写入配置文件才行。</p><ul><li>Bash 配置文件</li></ul><p>以 login shell 方式</p><p>1 /etc/profile  系统最主要的shell配置文件，每次login，bash都要读取 /etc/profile文件</p><p>PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录；<br>MAIL：依据账号配置好使用者的 mailbox 到 /var/spool/mail/账号名；<br>USER：根据用户的账号配置此一变量内容；<br>HOSTNAME：依据主机的 hostname 命令决定此一变量内容；<br>HISTSIZE：历史命令记录数</p><p>2 个人配置文件</p><p>bash 在读完了整体环境配置的 /etc/profile 以及其他配置文件后，接下来则是会读取使用者的个人配置文件</p><p>其实 bash 的 login shell 配置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。 如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思</p><p>在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：</p><p>~/.bash_profile<br>~/.bash_login<br>~/.profile</p><p>~/.bash_profile  是个人的bash配置文件，存在每位用户的$HOME</p><p>~/.bash_login  用户登陆时 bash会读取这个文件。通常把登陆就要执行的指令放在这</p><p>以 non-login shell 方式</p><p> ~/.bashrc  每次打开shell，shell都会读取的文件。每次打开shell,执行一次</p><p>其余的配置文件为</p><p>4 ~/.bash_logout 是退出系统时ｂａｓｈ在退出时执行的</p><p>5 ～/.bash_history  是历史功能的记录文件</p><h3 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h3><blockquote><p>数据流重定向 就是把某些要出现在屏幕上的数据传输到其他地方</p></blockquote><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>输入数据流：以写文件为例，从键盘输入的字符就输入数据流</p><p>输出数据流：以读文件为例，将文件内容显示到屏幕上，显示的内容就是输出字符流</p><p>输出数据流又可分为：标准输出 标准错误输出</p><p>标准输入 &lt; 或者 &lt;&lt;</p><p>标准输出 &gt; 或者 &gt;&gt;</p><p>标准错误输出 2&gt; 或者 2&gt;&gt; </p><p>（ 一个&lt; 表示覆盖  二个&lt;&lt; 表示进行追加 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo config.js &gt; copy.js</span><br></pre></td></tr></table></figure><p>本应该出现在屏幕上的所有的config的信息 会被 导入到copy.js文件</p><p>这个copy文件的创建方式为</p><p>1 该文件若不存在，系统会自动的将他创建起来</p><p>2 当这个文件存在的时候，那么系统就会先将这个文件内容清空，然后再将数据写入</p><p>也就是若以 &gt; 输出到一个已存在的文件中，那个文件就会被覆盖掉</p><p>如果不想被覆盖，而是继续追加信息，使用 &gt;&gt;</p><h4 id="命令行中的判断-amp-amp"><a href="#命令行中的判断-amp-amp" class="headerlink" title="命令行中的判断 &amp;&amp; ||"></a>命令行中的判断 &amp;&amp; ||</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls tmp/info &amp;&amp; touch tmp/info/a</span><br></pre></td></tr></table></figure><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>bash 命令运行的时候有输出的数据会出现！ 那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来配置？</p><ul><li><p>grep</p></li><li><p>uniq 去重</p></li><li><p>wc 统计</p></li></ul><h2 id="chapter-13-shell-script"><a href="#chapter-13-shell-script" class="headerlink" title="chapter 13 shell script"></a>chapter 13 shell script</h2><p>就是在 shell 上运行的 script 脚本</p><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>以 #!/bin/bash 开头 用以声明文件内语法使用bash语法</p><ul><li>条件判断</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式 ]; then</span><br><span class="line">当条件判断式成立时，可以进行的命令工作内容；</span><br><span class="line">fi   &lt;==将 <span class="keyword">if</span> 反过来写，就成为 fi 啦！结束 <span class="keyword">if</span> 之意！</span><br></pre></td></tr></table></figure><h3 id="如何运行"><a href="#如何运行" class="headerlink" title="如何运行"></a>如何运行</h3><p>sh base.sh<br>bash base.sh<br>/bin/bash base.sh<br>/bin/sh base.sh</p><p>source x.sh</p><p>source 可以回传变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义变量 export 到全局</span></span><br><span class="line"><span class="keyword">export</span> TRYPATH=<span class="string">'trypath'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 test.sh 内容为  </span></span><br><span class="line"><span class="comment">// echo $TRYPATH</span></span><br><span class="line"><span class="comment">// TRYPATH='changepath'</span></span><br><span class="line">sh test.sh  <span class="comment">// -&gt; trypath</span></span><br><span class="line"></span><br><span class="line">echo $TRYPATH <span class="comment">// -&gt; trypath</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用source执行</span></span><br><span class="line"></span><br><span class="line">source test.sh <span class="comment">// trypath</span></span><br><span class="line"></span><br><span class="line">echo $TRYPATH <span class="comment">// -&gt; changepath</span></span><br></pre></td></tr></table></figure><p>也就是 source 可以修改父进程的变量</p><h2 id="chapter-14-账号管理与权限设置"><a href="#chapter-14-账号管理与权限设置" class="headerlink" title="chapter 14 账号管理与权限设置"></a>chapter 14 账号管理与权限设置</h2><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659ed35bebab442?w=1390&amp;h=642&amp;f=png&amp;s=520147" alt="Jurisdiction"></p><h3 id="账号与用户组"><a href="#账号与用户组" class="headerlink" title="账号与用户组"></a>账号与用户组</h3><p>登陆 Linux 主机的时候，输入的是我们的账号, ID 与账号的对应就在 /etc/passwd 当中</p><p>每个登陆的使用者至少都会取得两个 ID ，一个是使用者 ID (User ID ，简称 UID)、一个是群组 ID (Group ID ，简称 GID)</p><ul><li>文件如何判别他的拥有者与群组</li></ul><p>每一个文件都会有所谓的拥有者 ID 与拥有群组 ID ，当我们有要显示文件属性的需求时，系统会依据 /etc/passwd 与 /etc/group 的内容， 找到 UID / GID 对应的账号与组名再显示出来</p><ul><li>在输入账号和密码登录shell时候 系统会发生什么</li></ul><p>1 先找寻 /etc/passwd 里面是否有你输入的账号</p><p>如果没有则跳出，如果有的话则将该账号对应的 UID 与 GID (在 /etc/group 中) 读出来，另外，该账号的主文件夹与 shell 配置也一并读出</p><p>2 再来则是核对密码表啦！</p><p>这时 Linux 会进入 /etc/shadow 里面找出对应的账号与 UID，然后核对一下你刚刚输入的密码与里头的密码是否相符</p><p>3 如果一切都 OK 的话，就进入 Shell 控管的阶段</p><h4 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h4><p>每一行都代表一个账号，有几行就代表有几个账号在你的系统中</p><p>按照 : 分为 7个部分</p><p>[用户名]：[密码]：[UID]：[GID]：[身份描述]：[主目录]：[登录shell]</p><h4 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h4><p>我们知道很多程序的运行都与权限有关，而权限与 UID/GID 有关！因此各程序当然需要读取 /etc/passwd 来了解不同账号的权限。 因此 /etc/passwd 的权限需配置为 -rw-r–r– 这样的情况， 虽然早期的密码也有加密过，但却放置到 /etc/passwd 的第二个字段上！这样一来很容易被有心人士所窃取的， 加密过的密码也能够透过暴力破解法去 try and error (试误) 找出来</p><p>因为这样的关系，所以后来发展出将密码移动到 /etc/shadow 这个文件分隔开来的技术</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">testuser:!!:<span class="number">17854</span>:<span class="number">0</span>:<span class="number">99999</span>:<span class="number">7</span>:::</span><br></pre></td></tr></table></figure><p>[账号名称] [密码] [最近更动密码的日期] [密码不可被更动的天数] [密码需要重新变更的天数] [密码需要变更期限前的警告天数] [密码过期后的账号宽限时间(密码失效日)] [账号失效日期] [保留]</p><ul><li>[密码] </li></ul><p>经过编码的密码 (加密)  只会看到有一些特殊符号的字母</p><ul><li>[最近更动密码的日期] </li></ul><p>是以 1970 年 1 月 1 日作为 1 而累加的日期，1971 年 1 月 1 日则为 366</p><h4 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h4><p>记录GID 和用户组组名对应</p><p>这个文件每一行代表一个群组</p><p>它总共分四个部分：[组名]：[密码域]：[GID]：[组员列表]</p><p>看下这三者的关系</p><p><img src="http://cn.linux.vbird.org/linux_basic/0410accountmanager_files/id_link.gif" alt="relation"></p><h3 id="有效用户组-effective-group-与初始用户组-initial-group"><a href="#有效用户组-effective-group-与初始用户组-initial-group" class="headerlink" title="有效用户组(effective group)与初始用户组(initial group)"></a>有效用户组(effective group)与初始用户组(initial group)</h3><p>每个使用者在他的 /etc/passwd 里面的第四栏有所谓的 GID，就是『初始群组 (initial group) 』。也就是说，当用户一登陆系统，立刻就拥有这个群组的相关权限</p><p>但是一个用户可以被加入到多个用户组去，比如 USERA 可以同时属于 group1 （初始用户组） 与 group2 （手动添加）</p><p>那么当这个用户在新建一个文件的时候，新文件所属组是哪一个</p><p>这个取决于当时的有效用户组</p><p>查询当前用户所属的用户组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groups</span><br></pre></td></tr></table></figure><p>第一个输出的群组即为 有效用户组 (effective group) 了</p><p>以这个用户身份去新建一个文件，则文件的用户组就是这个 有效用户组</p><h4 id="有效群组的切换"><a href="#有效群组的切换" class="headerlink" title="有效群组的切换"></a>有效群组的切换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp newGrooup</span><br></pre></td></tr></table></figure><p>但是使用newgrp 是有限制的，那就是你想要切换的群组必须是你已经有支持的群组，也就是说，只要我的用户有支持的群组就是能够切换成为有效群组</p><h3 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h3><h4 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 新增一个用户</span><br><span class="line">usersadd newName</span><br><span class="line"></span><br><span class="line">// 删除一个用户</span><br><span class="line">userdel newName</span><br></pre></td></tr></table></figure><p>CentOS 系统主要会帮我们处理几个项目</p><p>1 在 /etc/passwd 里面创建一行与账号相关的数据，包括创建 UID/GID/家目录等</p><p>2 在 /etc/shadow 里面将此账号的密码相关参数填入，但是尚未有密码</p><p>3 在 /etc/group 里面加入一个与账号名称一模一样的组名</p><p>4 在 /home 底下创建一个与账号同名的目录作为用户家目录，且权限为 700</p><p>此时在 /etc/shadow 内仅会有密码参数而不会有加密过的密码数据，因此还需要使用『 passwd 账号 』来给予密码才算是完成了用户创建的流程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd g1</span><br></pre></td></tr></table></figure><p>为何『 useradd vbird1 』会主动在 /home/vbird1 创建起用户的家目录？家目录内有什么数据且来自哪里？为何默认使用的是 /bin/bash 这个 shell ？为何密码字段已经都规范好了 (0:99999:7 那一串)？ —- 取决于 useradd 所使用的参考文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> useradd -D</span><br><span class="line"><span class="comment">// GROUP=100&lt;==默认的群组</span></span><br><span class="line"><span class="comment">// HOME=/home&lt;==默认的家目录所在目录</span></span><br><span class="line"><span class="comment">// INACTIVE=-1&lt;==密码失效日，在 shadow 内的第 7 栏</span></span><br><span class="line"><span class="comment">// EXPIRE=&lt;==账号失效日，在 shadow 内的第 8 栏</span></span><br><span class="line"><span class="comment">// SHELL=/bin/bash&lt;==默认的 shell</span></span><br><span class="line"><span class="comment">// SKEL=/etc/skel&lt;==用户家目录的内容数据参考目录</span></span><br><span class="line"><span class="comment">// CREATE_MAIL_SPOOL=yes   &lt;==是否主动帮使用者创建邮件信箱(mailbox)</span></span><br></pre></td></tr></table></figure><h4 id="用户组相关"><a href="#用户组相关" class="headerlink" title="用户组相关"></a>用户组相关</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 新增一个用户组</span><br><span class="line">groupadd newName</span><br><span class="line"></span><br><span class="line">// 删除一个用户组  r 表示连同用户主文件夹一起删除</span><br><span class="line">groupdel -r newName </span><br><span class="line"></span><br><span class="line">// 将用户加入到组和从组中删除</span><br><span class="line">gpasswd –a 用户名  组名        //添加用户</span><br><span class="line">gpasswd –d 用户名  组名        //删除用户</span><br><span class="line"></span><br><span class="line">//  查看用户属于某组</span><br><span class="line">#groups  用户名</span><br><span class="line">// 新建用户加入某组</span><br><span class="line">useradd –g  某组名  用户</span><br></pre></td></tr></table></figure><h4 id="用户组管理员设置"><a href="#用户组管理员设置" class="headerlink" title="用户组管理员设置"></a>用户组管理员设置</h4><p>将 g3 设置为 girls 组的管理员， 管理员可以控制 那些账号可以 移入 移除 用户组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpasswd -A g3 girls</span><br></pre></td></tr></table></figure><h4 id="设置用户密码"><a href="#设置用户密码" class="headerlink" title="设置用户密码"></a>设置用户密码</h4><p>当忘记了密码怎么办</p><ul><li>普通用户</li></ul><p>root管理员处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd usertest</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/16787b65967aa54d?w=367&amp;h=110&amp;f=png&amp;s=22874" alt="passwd"></p><ul><li>root 忘记密码</li></ul><p>安全模式？？ 太复杂了</p><ul><li>关于处理密码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">123456</span> | passwd --stdin testuser2</span><br></pre></td></tr></table></figure><p>直接变更密码，不需要重复确认</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/16787b8b783213a2?w=1114&amp;h=168&amp;f=png&amp;s=51514" alt="pwd"></p><ul><li>关闭/打开 某一个用户密码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用户密码失效</span></span><br><span class="line">passwd -S xxx</span><br><span class="line"><span class="comment">// 使用户密码解锁</span></span><br><span class="line">passwd -u xxx</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/16787bb6695e0ed3?w=503&amp;h=131&amp;f=png&amp;s=29909" alt="lock"></p><h4 id="用户的身份切换"><a href="#用户的身份切换" class="headerlink" title="用户的身份切换"></a>用户的身份切换</h4><ul><li>su</li></ul><p>su 需要新用户的密码  （如果原来的是root 切换到哪一个都不需要密码 ）</p><p>原本的变量不会改变, 比如PATH变量 mail 变量 还会是之前用户的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 - 可以处理这个问题</span></span><br><span class="line">su -</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/11/1679bfeeef36a86c?w=1692&amp;h=508&amp;f=png&amp;s=136483" alt="su"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>退出 第二个 用户状态 恢复到原始用户环境</p><ul><li>sudo</li></ul><p>sudo 切换需要自己的密码，有时候还不需要</p><p>sudo 可以让你以其他用户的身份运行命令 (通常是使用 root 的身份来运行命令), 只有在 /etc/sudoers 中的用户 才可以执行此命令</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/11/1679c07f4deaaf6f?w=902&amp;h=476&amp;f=png&amp;s=92811" alt=""></p><p>将用户添加到 /etc/sudoers  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>添加角色</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/11/1679c18b6d5ae400?w=388&amp;h=83&amp;f=png&amp;s=7979" alt="visudo"></p><h4 id="用户功能"><a href="#用户功能" class="headerlink" title="用户功能"></a>用户功能</h4><ul><li>id</li></ul><p>查询某人或者自己的uid/gid等信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">// uid=1006(g1) gid=1007(girls) 组=1007(girls)</span><br><span class="line">id g2</span><br><span class="line">// uid=1007(g2) gid=1007(girls) 组=1007(girls)</span><br></pre></td></tr></table></figure><ul><li>w / who</li></ul><p>当前谁登陆在系统上</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/11/1679c0e754e625d7?w=1114&amp;h=358&amp;f=png&amp;s=95220" alt="w"></p><h2 id="chapter16-例行性工作-crontab"><a href="#chapter16-例行性工作-crontab" class="headerlink" title="chapter16 例行性工作 crontab"></a>chapter16 例行性工作 crontab</h2><p><img src="https://user-gold-cdn.xitu.io/2018/9/7/165b3709072e4592?w=1362&amp;h=508&amp;f=png&amp;s=240174" alt="crontab"></p><h3 id="什么是例行性工作？"><a href="#什么是例行性工作？" class="headerlink" title="什么是例行性工作？"></a>什么是例行性工作？</h3><p>可以理解为node中的定时任务（node-schedule）</p><p>有两种任务性质，周期性，一次性</p><p>周期性: 比如每天要睡觉</p><p>一次性: 比如偶尔会捡到钱</p><p>at 命令用于处理 一次性 的工作</p><p>crontab 命令用于处理周期性的工作，循环工作</p><h4 id="Linux常见的例行性工作调度"><a href="#Linux常见的例行性工作调度" class="headerlink" title="Linux常见的例行性工作调度"></a>Linux常见的例行性工作调度</h4><ul><li><p>日志文件的轮替</p></li><li><p>临时文件的删除</p></li></ul><p>某些软件在运行中会产生一些缓存文件，但是当这个软件关闭时，这些缓存文件可能并不会主动的被移除。</p><p>系统透过例行性工作排程运行名为 tmpwatch 的命令来删除这些缓存文件</p><h4 id="at-一次性的工作调度"><a href="#at-一次性的工作调度" class="headerlink" title="at 一次性的工作调度"></a>at 一次性的工作调度</h4><p>atd 用于负责处理 这些一次的工作，但是并非所有的 Linux distributions 都默认会把他打开的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/atd restart</span><br></pre></td></tr></table></figure><p>使用 at 这个命令来产生所要运行的工作，并将这个工作以文字档的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与运行了</p><h5 id="etc-at-allow-与-etc-at-deny"><a href="#etc-at-allow-与-etc-at-deny" class="headerlink" title="/etc/at.allow 与 /etc/at.deny"></a>/etc/at.allow 与 /etc/at.deny</h5><p>这两个文件限制了谁有权利去调用 at</p><p>1 /etc/at.allow</p><p>写在这个文件中的使用者才能使用 at ，没有在这个文件中的使用者则不能使用 at (即使没有写在 at.deny 当中)</p><p>2 如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个文件 凡是被写入的都不能使用at了（没有被写的就可以使用）</p><p>3 如果两个文件都不存在，那么只有 root 可以使用 at 这个命令</p><ul><li>查询当前机器中有多少 at 的工作调度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atq</span><br></pre></td></tr></table></figure><ul><li>删除某一个工作调度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atrm [jobnumber]</span><br></pre></td></tr></table></figure><h5 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h5><p>batch 就是另一种 at, 但是batch会在 CPU 工作负载 低于 0.8 的时候，才进行你所下达的工作任务</p><ul><li>CPU 工作负载</li></ul><p>如果某一个程序他需要一直使用 CPU 的运算功能，那么此时 CPU 的使用率可能到达 100% 但是 CPU 的工作负载则是趋近1，因为 CPU 仅负责一个工作</p><p>如果同时运行2个这样的程序 CPU 的使用率还是 100% ，但是工作负载则变成 2</p><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><h4 id="用户的设置"><a href="#用户的设置" class="headerlink" title="用户的设置"></a>用户的设置</h4><p>crontab 用来处理周期性的工作，为了安全考虑，可以限制哪些身份是可以使用 crontab</p><ul><li><p>/etc/cron.allow</p></li><li><p>/etc/cron.deny</p></li></ul><p>当使用者使用 crontab 这个命令来创建工作排程之后，该项工作就会被纪录到 /var/spool/cron/ 里面, 而且是以帐号来作为判别</p><p>比如 dmtsai 使用 crontab 后， 他的工作会被记录到 /var/spool/cron/dmtsai 里头去</p><p>默认情况下，只要用户没有被放入 /etc/cron.deny 就可以直接执行 crontab -e 去编辑自己的例行性命令了</p><p>时间位置是五个数字 <em> </em> <em> </em> * 分别代表 分钟 小时 日期 月份 周几</p><p>编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>我们写一个每一分钟输出当前时间的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * echo $(date) &gt; /tmp/test.txt</span><br></pre></td></tr></table></figure><p>查看当前用的 crontab 工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/systemctl start crond.service</span><br></pre></td></tr></table></figure><h4 id="系统层级的crontab"><a href="#系统层级的crontab" class="headerlink" title="系统层级的crontab"></a>系统层级的crontab</h4><p>crontab -e 是对于用户的，如果是系统的例行性任务，就需要另外处理了</p><p>需要编辑 /etc/crontab 这个文件了</p><blockquote><p>cron 这个服务的最低侦测限制是『分钟』，所以『 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容 』，因此，只要编辑完 /etc/crontab 这个文件，并且将他储存之后，那么 cron 的配置就自动运行</p></blockquote><p>手动重启crond服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/crond restart</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/11/165c8296cbe4ea40?w=401&amp;h=124&amp;f=png&amp;s=16752" alt="/etc/crontab"></p><ul><li>MAILTO</li></ul><p>当 /etc/crontab 这个文件中的例行性工作的命令发生错误时，或者是该工作的运行结果有 STDOUT/STDERR 时，会将错误信息或者是萤幕显示的信息传给谁(默认是由系统直接寄发一封 mail 给 root)</p><ul><li>PATH</li></ul><p>命令路径</p><h4 id="anacron-唤醒停机期间的工作任务"><a href="#anacron-唤醒停机期间的工作任务" class="headerlink" title="anacron 唤醒停机期间的工作任务"></a>anacron 唤醒停机期间的工作任务</h4><p>anacron 并不能指定何时运行某项任务， 而是以天为单位或者是在启动后立刻进行 anacron 的动作，他会去侦测停机期间应该进行但是并没有进行的 crontab 任务，并将该任务运行一遍后，anacron 就会自动停止了</p><p>anacron 会以一天、七天、一个月为期去侦测系统未进行的 crontab 任务</p><p>anacron 运行的时间通常有两个，一个是系统启动期间运行，一个是写入 crontab 的排程中。 这样才能够在特定时间分析系统未进行的 crontab 工作</p><h2 id="chapter17-程序管理"><a href="#chapter17-程序管理" class="headerlink" title="chapter17 程序管理"></a>chapter17 程序管理</h2><h3 id="17-1-进程-程序"><a href="#17-1-进程-程序" class="headerlink" title="17.1 进程 程序"></a>17.1 进程 程序</h3><p>触发任何一个事件时，系统都会将其定义为一个进程，并给与此进程一个ID，为PID. 同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限配置</p><p>程序一般是放置在实体磁碟中，然后透过使用者的运行来触发。触发后会加载到内存中成为一个个体，那就是进程。 为了操作系统可管理这个程序，因此程序有给予运行者的权限/属性等参数，并包括程序所需要的命令码与数据或文件数据等， 最后再给予一个 PID 。系统就是透过这个 PID 来判断该 process 是否具有权限进行工作</p><p><img src="http://cn.linux.vbird.org/linux_basic/0440processcontrol_files/process_1.gif" alt="内存"></p><ul><li>程序</li></ul><p>系统需要启动的那个二进制的文件</p><blockquote><p>通常为二进制程序放置在存储媒介中，以物理文件形式存在</p></blockquote><ul><li>进程</li></ul><p>程序触发之后，被加载到内存中成为一个个体，这就是进程</p><blockquote><p>程序被触发后，执行者的权限与属性，程序的程序代码与所需数据会被加载到内存，操作系统会给与这个内存单元一个标识符PID</p></blockquote><h4 id="子程序与父程序"><a href="#子程序与父程序" class="headerlink" title="子程序与父程序"></a>子程序与父程序</h4><p><img src="http://cn.linux.vbird.org/linux_basic/0440processcontrol_files/ppid.gif" alt="进程"></p><p>程序彼此之间是有相关性的。以上面的图示来看，连续运行两个 bash 后，第二个 bash 的父程序就是前一个 bash</p><h3 id="常驻进程"><a href="#常驻进程" class="headerlink" title="常驻进程"></a>常驻进程</h3><p>某些命令产生的进程很快就会被终止，比如ls显示文件 touch 创建文件等。但是有些进程会一直在执行，比如系统每一分钟会去扫描  /etc/crontab 来进行工作调度， 是 crond 这个程序所管理的，他启动后就在后台一直持续不断的运行。 这个就是一直存在内存中的进程</p><p>常驻在内存当中的程序通常都是负责一些系统所提供的功能以服务使用者各项任务，因此这些常驻程序就会被我们称为：服务 (daemon)。系统的服务非常的多， 不过主要大致分成系统本身所需要的服务，例如刚刚提到的 crond 及 atd</p><p>网络服务会启动一个可以负责网络监听的端口 (port) ，以提供外部用户端 (client) 的连线要求</p><h3 id="Linux-的多人多工环境"><a href="#Linux-的多人多工环境" class="headerlink" title="Linux 的多人多工环境"></a>Linux 的多人多工环境</h3><p>Q: 为什么 Linux 这么多用户，但是却每个用户都可以拥有自己的环境？</p><p>其实在 Linux 下运行一个命令时，系统会将相关的权限、属性、程序码与数据等均加载内存， 并给予这个单元一个程序识别码 (PID)，最终该命令可以进行的任务则与这个 PID 的权限有关</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 文件目录</span></span><br><span class="line"><span class="keyword">const</span> dir = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一些内存</span></span><br><span class="line"><span class="keyword">const</span> Memory = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linux1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用户1登录的环境</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crontab</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pm2</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linux2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 用户2 登录的环境</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crontab</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pm2</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多任务行为</li></ul><p>Linux 可以让CPU在各个工作进行切换，也就是说，每一个工作仅仅占用CPU几个命令次数，所以CPU每秒能够在各个进程之间进行切换</p><p>目前的 CPU 速度可高达几个 GHz。 这代表 CPU 每秒钟可以运行 109 这么多次命令。Linux 可以让 CPU 在各个工作间进行切换， 也就是说，其实每个工作都仅占去 CPU 的几个命令次数，所以 CPU 每秒就能够在各个程序之间进行切换</p><ul><li>特殊的程序管理行为</li></ul><p>Linux可以在任何时候， 将某个被困住的程序杀掉，然后再重新运行该程序而不用重新启动</p><ul><li>bash 环境下的工作管理 (job control)</li></ul><p>登陆 bash 之后， 就是取得一个名为 bash 的 PID 了，而在这个环境底下所运行的其他命令， 就几乎都是子进程了</p><p>在这个单一的 bash 界面下，可以处理多个工作</p><h4 id="工作管理-job-control"><a href="#工作管理-job-control" class="headerlink" title="工作管理 job control"></a>工作管理 job control</h4><blockquote><p>当登录系统取得 bash shell 之后，在单一终端机界面下同时进行多个工作的行为管理</p></blockquote><p>可以出现提示字节让你操作的环境就称为前景 (foreground)，其他工作就可以让你放入背景 (background) 去暂停或运行</p><ul><li>直接将命令丢到后台中『运行』的 &amp;</li></ul><p>比如启动一个项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/12/165cd78cbdeb26dd?w=925&amp;h=161&amp;f=png&amp;s=134306" alt="run"></p><p>这个就是一直在前台启动，我们可以将这个放在后台处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node index.js &amp;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/12/165cd7af1f951138?w=587&amp;h=203&amp;f=png&amp;s=127645" alt="&amp;"></p><p>添加的这个 &amp; 会将命令放到后台处理，此时bash会输出一个 工作号码  1  和 PID 90328</p><ul><li>查询目前在后台的工作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/9/12/165cd7f57a61c69b?w=544&amp;h=183&amp;f=png&amp;s=123945" alt="jobs"></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>l</td><td>除了列出 job number 与命令串之外，同时列出 PID 的号码</td></tr><tr><td>r</td><td>仅列出正在背景 run 的工作</td></tr><tr><td>s</td><td>仅列出正在背景当中暂停 (stop) 的工作</td></tr></tbody></table><p>可以看到有一个 + - 号展示</p><ul><li>代表最近被放到背景的工作号码 - 代表最近最后第二个被放置到背景中的工作号码 而超过最后第三个以后的工作，就不会有 +/- 符号存在了</li></ul><ul><li>后台工作拿到前台处理 fg (foreground)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fg // 默认将 + 的工作取出来</span><br><span class="line">fg- // 取出来 - 的工作</span><br><span class="line">fg %工作号码 // 取出来这个工作号码的对应工作</span><br></pre></td></tr></table></figure><ul><li>管理工作 kill</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/9/12/165cd89354ae48c4?w=611&amp;h=236&amp;f=png&amp;s=162088" alt="kill"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -signal %jobnumber</span><br></pre></td></tr></table></figure><table><thead><tr><th>signal参数</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>重新读取一次参数的配置档 (类似 reload)</td></tr><tr><td>2</td><td>代表与由键盘输入 [ctrl]-c 同样的动作</td></tr><tr><td>9</td><td>立刻强制删除一个工作</td></tr><tr><td>15</td><td>以正常的程序方式终止一项工作。与 -9 是不一样的</td></tr></tbody></table><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>为什么需要进程管理</p><p>1 Linux 系统是个很忙碌的系统，那么当整个系统资源快要被使用光时， 您是否能够找出最耗系统的那个程序，然后删除该程序，让系统恢复正常呢</p><p>2 此外，如果由於某个程序写的不好，导致产生一个有问题的程序在内存当中，您又该如何找出他，然后将他移除呢？</p><p>3 如果同时有五六项工作在您的系统当中运行，但其中有一项工作才是最重要的， 该如何让那一项重要的工作被最优先运行呢</p><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><ul><li>ps</li></ul><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>ps -l</td><td>查询只和自己bash相关的进程</td></tr><tr><td>ps aux</td><td>当前内存所有进程</td></tr></tbody></table><p>ps 是静态的结果输出 是某一个时间点的进程状态</p><ul><li>top</li></ul><p>top 可以监测整个系统的进程工作状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [-d 数字] | top [-bnp]</span><br></pre></td></tr></table></figure><p>-d 后面可以接秒数，默认是 5 秒, 表示每次更新进程资源的时间</p><p>在 top 运行过程当中可以使用的按键命令</p><p>? ：显示在 top 当中可以输入的按键命令<br>P ：以 CPU 的使用资源排序显示<br>M ：以 Memory 内存 的使用资源排序显示 (默认)<br>N ：以 PID 来排序<br>T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序<br>k ：给予某个 PID 一个讯号  (signal)<br>r ：给予某个 PID 重新制订一个 nice 值<br>q ：离开 top 软件的按键</p><hr><p><img src="https://user-gold-cdn.xitu.io/2018/8/31/1658f2e5f6b5a8f0?w=1426&amp;h=186&amp;f=png&amp;s=151283" alt="think"></p><p>如何查找最消耗CPU的进程</p><p>使用 top 然后 按P</p><hr><h4 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h4><p>其实是透过给予该程序一个信号 (signal) 去告知该程序如何操作</p><p>查询所有的可用的singal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br></pre></td></tr></table></figure><p>常用的一些 信号</p><table><thead><tr><th>数值</th><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>启动被终止的程序，可让该 PID 重新读取自己的配置档，类似重新启动</td></tr></tbody></table><ul><li>killall -singal 命令名称</li></ul><p>根据进程名称删除此进程</p><p>比如我们通过 node index.js &amp; 启动这个服务到后台</p><p>那么删除就可以是 killall -9 node</p><p>要删除某个程序，我们可以使用 PID 或者是启动该程序的命令名称，</p><p>而如果要删除某个服务呢？呵呵！最简单的方法就是利用 killall ， 因为他可以将系统当中所有以某个命令名称启动的程序全部删除。</p><h4 id="进程的优先级"><a href="#进程的优先级" class="headerlink" title="进程的优先级"></a>进程的优先级</h4><p>Linux 给予程序一个所谓的『优先运行序 (priority, PRI)』， 这个 PRI 值越低代表越优先的意思</p><p>之前我们查看一个进程 ps -l</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/13/165d2aa8d40081d0?w=604&amp;h=83&amp;f=png&amp;s=23720" alt="ps -l"></p><p>可以看到 PRI 这个参数</p><p>PRI 是内核动态调整的，使用者无权去干涉 PRI</p><p>想要调整程序的优先运行序时，就得要透过 Nice 值了！Nice 值就是上表的 NI</p><p>一般来说， PRI 与 NI 的相关性如下：</p><p>PRI(new) = PRI(old) + nice</p><p>但是，如果原本的 PRI 是 50 ，并不是我们给予一个 nice = 5 ，就会让 PRI 变成 55 。</p><p>因为 PRI 是系统『动态』决定的，所以，虽然 nice 值是可以影响 PRI ，不过， 最终的 PRI 仍是要经过系统分析后才会决定的。</p><p>另外， nice 值是有正负的，而既然 PRI 越小越早被运行， 所以，当 nice 值为负值时，那么该程序就会降低 PRI 值，亦即会变的较优先被处理</p><ul><li>nice</li></ul><p>新执行的命令处理nice</p><p>nice [-n 数字] command</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nice -n <span class="number">5</span> vi</span><br></pre></td></tr></table></figure><p>数字范围在 -20 - 19</p><ul><li>renice</li></ul><p>已经存在的进程nice重新调整</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><h3 id="查看系统资源"><a href="#查看系统资源" class="headerlink" title="查看系统资源"></a>查看系统资源</h3><h4 id="free-查看内存占用"><a href="#free-查看内存占用" class="headerlink" title="free 查看内存占用"></a>free 查看内存占用</h4><p>free [-b|-k|-m|-g] [-t]</p><p>选项与参数</p><p>-b  ：直接输入 free 时，显示的单位是 Kbytes，我们可以使用 b(bytes), m(Mbytes) k(Kbytes), 及 g(Gbytes) 来显示单位</p><p>-t  ：在输出的最终结果，显示实体内存与 swap 的总量</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/13/165d2b249145fcba?w=710&amp;h=345&amp;f=png&amp;s=180715" alt="free"></p><p>Mem 那一行显示的是实体内存的量， Swap 则是虚拟内存的量。 total 是总量， used 是已被使用的量， free 则是剩余可用的量。 后面的 shared/buffers/cached 则是在已被使用的量当中，用来作为缓冲及缓存的量。</p><p>Linux 测试用主机是很平凡的，根本没有什么工作， 但是实体内存是几乎被用光</p><p>不过，至少有 132MB 用在缓冲记忆 (buffers) 工作， 287MB 则用在缓存 (cached) 工作，也就是说，系统是『很有效率的将所有的内存用光』， 目的是为了让系统的存取效能加速</p><p>很多朋友都会问到这个问题『我的系统明明很轻松，为何内存会被用光光？』被用光是正常的！而需要注意的反而是 swap 的量</p><p>一般来说， swap 最好不要被使用，尤其 swap 最好不要被使用超过 20% 以上， 如果您发现 swap 的用量超过 20% ，那么，最好还是买实体内存</p><p>系统会使用到 swap ， 绝对是因为实体内存不足了才会这样做的</p><p><strong> Linux 系统为了要加速系统效能，所以会将最常使用到的或者是最近使用到的文件数据缓存 (cache) 下来， 这样未来系统要使用该文件时，就直接由内存中搜寻取出，而不需要重新读取硬盘，速度上面当然就加快了！ 因此，实体内存被用光是正常的</strong></p><h4 id="uname：查阅系统与核心相关资讯"><a href="#uname：查阅系统与核心相关资讯" class="headerlink" title="uname：查阅系统与核心相关资讯"></a>uname：查阅系统与核心相关资讯</h4><h4 id="uptime：观察系统启动时间与工作负载"><a href="#uptime：观察系统启动时间与工作负载" class="headerlink" title="uptime：观察系统启动时间与工作负载"></a>uptime：观察系统启动时间与工作负载</h4><h4 id="netstart"><a href="#netstart" class="headerlink" title="netstart"></a>netstart</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstart -tlnp</span><br></pre></td></tr></table></figure><h3 id="特殊文件和程序"><a href="#特殊文件和程序" class="headerlink" title="特殊文件和程序"></a>特殊文件和程序</h3><h2 id="chapter-18-系统服务"><a href="#chapter-18-系统服务" class="headerlink" title="chapter 18 系统服务"></a>chapter 18 系统服务</h2><p><img src="https://pic3.zhimg.com/v2-3c1bb7184feaa309677bbbba684b44e8_1200x500.jpg" alt="service"></p><p>系统为了某些功能必须要提供一些服务 (不论是系统本身还是网络方面)，这个服务就称为 service</p><p>但是 service 的总是需要程序的运行吧！达成这个 service 的程序我们就称呼他为 daemon</p><p>举例来说，达成循环型例行性工作排程服务 (service) 的程序为 crond 这个 daemon</p><h2 id="chapter23-软件安装"><a href="#chapter23-软件安装" class="headerlink" title="chapter23 软件安装"></a>chapter23 软件安装</h2><p>Linux 开发商先在固定的硬件平台与操作系统平台上面将需要安装或升级的软件编译好， 然后将这个软件的所有相关文件打包成为一个特殊格式的文件，在这个软件文件内还包含了预先侦测系统与相依软件的脚本， 并提供记载该软件提供的所有文件资讯等。最终将这个软件文件发布。</p><p>用户端取得这个文件后，只要透过特定的命令来安装， 那么该软件文件就会依照内部的脚本来侦测相依的前驱软件是否存在，若安装的环境符合需求，那就会开始安装， 安装完成后还会将该软件的资讯写入软件管理机制中，以达成未来可以进行升级、移除等动作</p><p>目前Linux常用的两大安装方式为 dpkg rpm</p><p>不论 dpkg/rpm 这些机制或多或少都会有软件属性相依的问题，那该如何解决呢？</p><p>其实前面不是谈到过每个软件文件都有提供相依属性的检查吗？那么如果我们将相依属性的数据做成列表， 等到实际软件安装时，若发生有相依属性的软件状况时，管理机制自动去取得其依赖来同时安装， 就解决了属性相依的问题</p><p>目前新的 Linux 开发商都有提供这样的『线上升级』机制，透过这个机制， 原版光盘就只有第一次安装时需要用到而已，其他时候只要有网络，你就能够取得原本开发商所提供的任何软件了</p><p>CentOS 系统嘛！所以说：使用的软件管理机制为 RPM 机制，而用来作为线上升级的方式则为 yum</p><h3 id="rpm"><a href="#rpm" class="headerlink" title="rpm"></a>rpm</h3><p>RPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，现在包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。  </p><p>最大的特点就是将你要安装的软件先编译过， 并且打包成为 RPM 机制的包装文件，透过包装好的软件里头默认的数据库记录， 记录这个软件要安装的时候必须具备的相依属性软件，当安装在你的 Linux 主机时， RPM 会先依照软件里头的数据查询 Linux 主机的相依属性软件是否满足， 若满足则予以安装，若不满足则不予安装。那么安装的时候就将该软件的资讯整个写入 RPM 的数据库中，以便未来的查询、验证与反安装！这样一来的优点是：</p><p>由於已经编译完成并且打包完毕，所以软件传输与安装上很方便 (不需要再重新编译)；<br>由於软件的资讯都已经记录在 Linux 主机的数据库上，很方便查询、升级与反安装</p><p>缺点</p><p>由於 RPM 文件是已经包装好的数据，也就是说， 里面的数据已经都『编译完成』了！所以，该软件文件几乎只能安装在原本默认的硬件与操作系统版本中。 也就是说，你的主机系统环境必须要与当初创建这个软件文件的主机环境相同才行</p><p>有的时候相同 distribution 的不同版本之间也无法互通，例如 CentOS 4.x 的 RPM 文件就无法直接套用在 CentOS 5.x ！因此，这样可以发现这些软件管理机制的问题是：</p><p>软件文件安装的环境必须与打包时的环境需求一致或相当；<br>需要满足软件的相依属性需求；<br>反安装时需要特别小心，最底层的软件不可先移除，否则可能造成整个系统的问题！</p><h4 id="RPM-相关操作"><a href="#RPM-相关操作" class="headerlink" title="RPM 相关操作"></a>RPM 相关操作</h4><ul><li>查询rpm包</li></ul><p>（1）查询系统中安装的所有rpm包　#rpm –qa<br>（2）查询软件包是否安装　　#rpm –q 软件包名称<br>（3）查询软件包信息　　　#rpm –qi 软件包名称<br>（4）查询软件包中的文件　#rpm –ql 软件包名称<br>（5）查询系统中文件所属的软件包#rpm –qf 文件全路径名<br>（6）查询rpm包文件中的信息#rpm –qp rpm包文件全路径</p><ul><li>安装rpm包</li></ul><p>rpm –ivh rpm包全路径文件名</p><ul><li>删除rpm包</li></ul><p>rpm –e rpm包名称</p><ul><li>升级rpm包</li></ul><p>rpm –U rpm软件包全路径名</p><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p>基本的网络配置</p><p>1、主机名<br>2、ip地址<br>3、网关地址<br>4、DNS服务器地址</p><p>DNS</p><p>DNS客户配置文件 /etc/resolv.conf 该文件中指定系统所使用的DNS服务器的IP地址</p><p>网络相关命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示当前系统的主机名称</span></span><br><span class="line">hostname</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置系统主机名</span></span><br><span class="line">hostname 主机名称</span><br></pre></td></tr></table></figure><p>ping</p><p>Ping [–c 发出的报文数 ]目的主机地址<br>Ping命令通过向被测试的目的主机地址发送ICMP报文并收取回应报文，来测试当前主机到目的主机的网络连接状态</p><p>nslookup<br>用于使用系统设定的DNS服务器解析域名，用该命令可以测试NDS服务器是否工作正常<br>Nslookup命令有交互方式查询和命令行方式查询</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nslookup</span><br><span class="line">#nslookup 主机域名 | ip地址</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nslookup</span><br><span class="line">www.webmxx.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack系列之-原理篇</title>
      <link href="/2018/05/02/webpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E5%8E%9F%E7%90%86%E7%AF%87/"/>
      <url>/2018/05/02/webpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E5%8E%9F%E7%90%86%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>本系列将会从原理、开发、优化、对比四个方面给大家介绍webpack的工作流程。【默认是以webpack v3为例子】</p><a id="more"></a><h2 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h2><h3 id="CommonJS-规范"><a href="#CommonJS-规范" class="headerlink" title="CommonJS 规范"></a>CommonJS 规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 模块引入</span><br><span class="line">let moduleA = require(&apos;./a.js)</span><br><span class="line"></span><br><span class="line">// 模块导出</span><br><span class="line">module.exports = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="es6规范"><a href="#es6规范" class="headerlink" title="es6规范"></a>es6规范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 模块引入</span><br><span class="line"></span><br><span class="line">let &#123;moduleA&#125; from &apos;./a.js&apos;</span><br><span class="line"></span><br><span class="line">// 模块导出</span><br><span class="line"></span><br><span class="line">export default () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="黑盒体验"><a href="#黑盒体验" class="headerlink" title="黑盒体验"></a>黑盒体验</h2><p>我们可以把webpack看做一个黑盒，只要会用就可以。先来体验一次很简单的webpack打包过程</p><p><img src="/img/webpack-code/box.png" alt="webpack"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'index.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动编译，在命令行输入 node_modules/.bin/webpack 就可看到一次打包过程</p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w6/code/webpack/webpack1/COPY/index1.js" target="_blank" rel="noopener">查看打包结果</a></p><h3 id="关于如何启动webpack"><a href="#关于如何启动webpack" class="headerlink" title="关于如何启动webpack"></a>关于如何启动webpack</h3><p>如果是全局安装了webpack，可以在命令行直接输入 webpack</p><p>如果只是项目文件夹安装，需要输入 node_modules/.bin/webpack</p><ul><li>npx</li></ul><p>在 npmV5版本 会赠送一个npx</p><p>npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装</p><p>所以也可以通过npx执行webpack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><h2 id="require方法"><a href="#require方法" class="headerlink" title="require方法"></a>require方法</h2><p>实现一个require方法</p><p>common.js的规范中 引入一个模块需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let getA = require(&apos;./a&apos;)</span><br></pre></td></tr></table></figure><p>自己写一个require方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">// 查找module</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myReq</span> (<span class="params">myModule</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取文件信息</span></span><br><span class="line">  <span class="keyword">let</span> cont = fs.readFileSync(myModule, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="comment">/* function (exports, require, module, __filename, __dirname) &#123;</span></span><br><span class="line"><span class="comment">    moduel.exports = &#123;a: 'apple'&#125;</span></span><br><span class="line"><span class="comment">    return moduel.exports</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line">  <span class="keyword">let</span> nodeFn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'exports'</span>, <span class="string">'require'</span>, <span class="string">'module'</span>, <span class="string">'__filename'</span>, <span class="string">'__dirname'</span>, cont + <span class="string">'return module.exports'</span>)</span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodeFn(<span class="built_in">module</span>.exports, myReq, <span class="built_in">module</span>, __filename, __dirname)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let getA = require('./a')</span></span><br><span class="line"><span class="keyword">let</span> getA = myReq(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(getA, <span class="string">'getA'</span>)</span><br></pre></td></tr></table></figure><p>思路：读取文件内容，根据node的封装规范，传入几个必须的参数即可。</p><ul><li>删减 webpack 编译后的文件</li></ul><p>把刚刚打包之后的 dist/index.js 删减掉一些不用的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myRequire</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">exports: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, myRequire);</span><br><span class="line">        <span class="comment">// call 用于让  modules[moduleId] 函数执行 执行的是传入后面的参数</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> myRequire(<span class="comment">/* 下面的第一个函数参数 */</span>);</span><br><span class="line">&#125;)</span><br><span class="line">([</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'123'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w6/code/webpack/webpack1/COPY/index1_simple.js" target="_blank" rel="noopener">在线查看</a></p><p>可以看出来， webpack打包生成之后的文件内容就和编译的require方法类似。这就是为什么打包之后的js文件可直接在浏览器中运行的原因</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><h3 id="常见名词解释"><a href="#常见名词解释" class="headerlink" title="常见名词解释"></a>常见名词解释</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>entry</td><td>项目入口</td></tr><tr><td>module</td><td>开发中每一个文件都可以看做module</td></tr><tr><td>chunk</td><td>代码块</td></tr><tr><td>loader</td><td>模块转化器</td></tr><tr><td>plugin</td><td>扩展插件 自定义webpack打包过程</td></tr><tr><td>bundle</td><td>最终打包完成的文件</td></tr></tbody></table><h3 id="打包流程"><a href="#打包流程" class="headerlink" title="打包流程"></a>打包流程</h3><p>webpack的运行流程是一个串行的过程，从启动到结束，会依次执行以下流程</p><ul><li>参数初始化</li></ul><p>从配置文件 【webpack.config.js】和 shell 语句中读取与合并参数</p><ul><li>开始编译</li></ul><p>初始化一个compiler对象 加载所有插件 执行对象的run方法开始编译</p><ul><li>确定入口文件</li></ul><p>根据配置文件找到项目所有的入口文件</p><ul><li>编译模块</li></ul><p>从入口开始 调用配置的loader对模块进行编译 【有一个递归寻找依赖模块的流程】</p><p>模块编译完成后 得到模块被转化后的最后内容以及他们之间的依赖关系</p><ul><li>资源输出</li></ul><p>根据入口文件和模块之间的依赖关系 组成chunk文件 【一个chunk可能包含多个模块】每一个chunk将会被转化成一个单独的文件加入输出列表中</p><ul><li>输出</li></ul><p>根据配置的输出参数 【路径和文件名】将输出内容写入文件系统</p><p><strong> 在以上的过程 WP会在特定的时间点广播特定的事件 插件在监听到感兴趣的事件后会执行特定的逻辑 </strong></p><h4 id="简化流程"><a href="#简化流程" class="headerlink" title="简化流程"></a>简化流程</h4><p>其实以上流程可以简化为三个阶段</p><p><img src="/img/webpack-code/process.png" alt="webpack"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="核心库-tapable"><a href="#核心库-tapable" class="headerlink" title="核心库 tapable"></a>核心库 tapable</h3><p>在node中有一个事件发射器 EventEmitter ，可以进行事件监听与发射。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    event.emit(<span class="string">'some_event'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>webpack核心库 <a href="https://github.com/webpack/tapable" target="_blank" rel="noopener">tapable</a> 的原理和 EventEmitter 类似，通过事件的注册和监听，触发各个编译周期中的函数方法.<br>Tapable 还允许你通过回调函数的参数，访问事件的“触发者(emittee)”或“提供者(producer)”</p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w6/code/simple-webpack/tapable.js" target="_blank" rel="noopener">查看在线代码</a></p><h3 id="核心对象-compiler"><a href="#核心对象-compiler" class="headerlink" title="核心对象 compiler"></a>核心对象 compiler</h3><p>compiler 继承自 tapable 可以进行事件的广播和监听</p><p>compiler 进行事件的广播和监听的方式为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 广播事件  params 为附带参数</span></span><br><span class="line">compiler.apply(<span class="string">'event-name'</span>, params)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 名为 event-name 的事件</span></span><br><span class="line">compiler.plugin(<span class="string">'event-name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w10-webpack-code/webpack/lib/Compiler.js" target="_blank" rel="noopener">查看177行代码</a></p><p>webpack 在初始化的时候 会将 compiler对象传入到plugin中 可以使用它来访问 webpack 的主环境</p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w10-webpack-code/webpack/lib/webpack.js" target="_blank" rel="noopener">查看45行代码</a></p><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。</p><h3 id="核心对象-compilation"><a href="#核心对象-compilation" class="headerlink" title="核心对象 compilation"></a>核心对象 compilation</h3><p>webpack系列之-原理篇<br>compilation 继承自 tapable 可以进行事件的广播和监听</p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w10-webpack-code/webpack/lib/Compilation.js" target="_blank" rel="noopener">查看57行代码</a></p><p>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。</p><p>一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息</p><h3 id="打包模板"><a href="#打包模板" class="headerlink" title="打包模板"></a>打包模板</h3><p>webpack打包的每一个chunk都是根据模板而生成的。webpack内部提供了很多模板文件。</p><p><img src="/img/webpack-code/template.png" alt="webpack"><br><img src="/img/webpack-code/template2.png" alt="webpack"></p><p>当webpack分析完所有的Module并准备输出chunk的时候 会分析每一个chunk找对其所对应的template 从而生成最后我们看到的文件格式</p><h3 id="plugin-实现机制"><a href="#plugin-实现机制" class="headerlink" title="plugin 实现机制"></a>plugin 实现机制</h3><h4 id="作用原理"><a href="#作用原理" class="headerlink" title="作用原理"></a>作用原理</h4><p>在webpack的编译流程，每一个阶段都会广播不同的事件，比如 run, done 等事件。plugin会监听到这些事件，一旦事件发生，就会执行注册好的函数方法</p><h4 id="plugin分析"><a href="#plugin分析" class="headerlink" title="plugin分析"></a>plugin分析</h4><p>每一个plugin都是 一个具有 apply 属性的 JavaScript 对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MPlugin &#123;</span><br><span class="line">  // 这里获取用户为插件传入的配置参数</span><br><span class="line">  constructor (options) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  // webpack 会调用 MPlugin 实例的apply方法 为插件实例传入 compiler 对象</span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    compiler.plugin(&apos;compilation&apos;, function (compilation) &#123;</span><br><span class="line">      // 回调函数中 传入了 compilation 对象</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在webpack初始化的阶段  会往plugin中传递compiler对象</p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w10-webpack-code/webpack/lib/webpack.js" target="_blank" rel="noopener">查看45行代码</a></p><h4 id="编写plugin"><a href="#编写plugin" class="headerlink" title="编写plugin"></a>编写plugin</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StartWp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options</span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123;name&#125; = <span class="keyword">this</span>.options</span><br><span class="line">        <span class="comment">// 监听事件 这是异步的 所以要执行cb  不然会卡到这里不动了</span></span><br><span class="line">        compiler.plugin(<span class="string">'run'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation, cb</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'run'</span>, name)</span><br><span class="line">            <span class="comment">// 每一次重新编译的时候又会触发</span></span><br><span class="line">            <span class="comment">// compilation.plugin('')</span></span><br><span class="line">            cb();</span><br><span class="line">        &#125;)</span><br><span class="line">        compiler.plugin(<span class="string">'done'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'done'</span>, name)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = StartWp</span><br></pre></td></tr></table></figure><ul><li><p>传递给插件的compiler和compilation是相同的 也就是某一个插件有修改对象的话会影响后面的插件的使用</p></li><li><p>有的事件是异步的，所以在使用的时候，要执行 cb() 去通知webpack 本次事件监听结束了 要往下继续执行否则会卡到这里</p></li></ul><p>如何使用此插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> StartWp(&#123;</span><br><span class="line">    name: <span class="string">'v3 - plugin '</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="自己来写一个简易版本的webpack打包器"><a href="#自己来写一个简易版本的webpack打包器" class="headerlink" title="自己来写一个简易版本的webpack打包器"></a>自己来写一个简易版本的webpack打包器</h2><p>实现原理: 根据打包的模板格式 读取文件信息并输入到指定的位置</p><ul><li><p>借助ejs </p></li><li><p>将简化的webpack打包结果拿出来作为 字符串模板</p></li></ul><h3 id="最简易的webpack"><a href="#最简易的webpack" class="headerlink" title="最简易的webpack"></a>最简易的webpack</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line"><span class="keyword">let</span> input = <span class="string">'./index.js'</span></span><br><span class="line"><span class="comment">// 输出地址</span></span><br><span class="line"><span class="keyword">let</span> output = <span class="string">'./dist/index.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getIntry = fs.readFileSync(input, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> template = <span class="string">`(function(modules) &#123; </span></span><br><span class="line"><span class="string">function __webpack_require__(moduleId) &#123;</span></span><br><span class="line"><span class="string">var module = &#123;</span></span><br><span class="line"><span class="string">exports: &#123;&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span></span><br><span class="line"><span class="string">return module.exports;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">return __webpack_require__(0);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">([</span></span><br><span class="line"><span class="string">  (function(module, exports) &#123;</span></span><br><span class="line"><span class="string">    &lt;%- getIntry %&gt;</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">])`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = ejs.render(template, &#123;</span><br><span class="line">  getIntry</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果输出到 dist </span></span><br><span class="line">fs.writeFileSync(output, result)</span><br></pre></td></tr></table></figure><p>在命令行执行一次 node webpack.0.1.0.js</p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w11-myWebpack/COPY/index.0.1.0.js" target="_blank" rel="noopener">执行之后的编译结果</a></p><p>可以看到在dist目录有index.js生成 将其引入 html页面</p><p><img src="/img/webpack-code/myw.png" alt="myWebpack"></p><p>这样就完成了一个非常非常简单的webpack</p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w11-myWebpack/webpack.0.1.0.js" target="_blank" rel="noopener">在线查看简单的webpack</a></p><h3 id="加入-require-处理"><a href="#加入-require-处理" class="headerlink" title="加入 require 处理"></a>加入 require 处理</h3><p>如果入口文件中 有使用到 require  则需要将其替换为webpack提供的 <strong>webpack_require</strong> </p><p>先看一下如果有使用 require 之后的打包之后的结果</p><p>bundle.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line"> exports: &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> __webpack_require__(<span class="number">0</span>);</span><br><span class="line"> &#125;)</span><br><span class="line"> ([</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">  __webpack_require__(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'index.js'</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w6/code/webpack/webpack1/COPY/bundle_require.js" target="_blank" rel="noopener">查看在线代码</a></p><p>我们使用这个模板来重新编写一个简易的webpack</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口文件</span></span><br><span class="line"><span class="keyword">let</span> input = <span class="string">'./index.js'</span></span><br><span class="line"><span class="comment">// 输出地址</span></span><br><span class="line"><span class="keyword">let</span> output = <span class="string">'./dist/index.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">'ejs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getIntry = fs.readFileSync(input, <span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将getIntry 中的 require 进行处理</span></span><br><span class="line"><span class="comment">// require('./a.js')</span></span><br><span class="line"><span class="keyword">const</span> contAry = []</span><br><span class="line"><span class="keyword">let</span> dealIntry = getIntry.replace(<span class="regexp">/(require)\(['"](.+?)['"]\)/g</span>, ($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// console.log($1, $2, $3, $4)</span></span><br><span class="line"><span class="comment">// let filePath = path.join(__resolve, $2)</span></span><br><span class="line"><span class="keyword">let</span> cont = fs.readFileSync($<span class="number">3</span>, <span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment">// console.log(cont)</span></span><br><span class="line">contAry.push(cont)</span><br><span class="line"><span class="keyword">return</span> $<span class="number">2</span> = <span class="string">`__webpack_require__(<span class="subst">$&#123;contAry.length&#125;</span>)`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(contAry)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> template = <span class="string">`(function(modules) &#123;</span></span><br><span class="line"><span class="string"> function __webpack_require__(moduleId) &#123;</span></span><br><span class="line"><span class="string"> var module = &#123;</span></span><br><span class="line"><span class="string"> exports: &#123;&#125;</span></span><br><span class="line"><span class="string"> &#125;;</span></span><br><span class="line"><span class="string"> modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span></span><br><span class="line"><span class="string"> return module.exports;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> return __webpack_require__(0);</span></span><br><span class="line"><span class="string"> &#125;)</span></span><br><span class="line"><span class="string"> ([</span></span><br><span class="line"><span class="string">  (function(module, exports, __webpack_require__) &#123;</span></span><br><span class="line"><span class="string">  &lt;%- dealIntry %&gt;</span></span><br><span class="line"><span class="string">  &#125;),</span></span><br><span class="line"><span class="string">&lt;% for(var i=0;i &lt; contAry.length; i++)&#123; %&gt;</span></span><br><span class="line"><span class="string">(function(module, exports) &#123;</span></span><br><span class="line"><span class="string">    &lt;%- contAry[i] %&gt;</span></span><br><span class="line"><span class="string">  &#125;),</span></span><br><span class="line"><span class="string">  &lt;%&#125;%&gt;</span></span><br><span class="line"><span class="string">])`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = ejs.render(template, &#123;</span><br><span class="line">  dealIntry,</span><br><span class="line">contAry</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将结果输出到 dist</span></span><br><span class="line">fs.writeFileSync(output, result)</span><br></pre></td></tr></table></figure><p>在命令行执行一次 node webpack.1.0.0.js</p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w11-myWebpack/COPY/index.1.0.0.js" target="_blank" rel="noopener">执行之后的编译结果</a></p><p><img src="/img/webpack-code/wp.png" alt="myWebpack"></p><p><a href="https://github.com/mengxxSELF/webpackTest/blob/master/w11-myWebpack/webpack.1.0.0.js" target="_blank" rel="noopener">在线查看加入require功能的webpack</a></p><h2 id="源码篇提问"><a href="#源码篇提问" class="headerlink" title="源码篇提问"></a>源码篇提问</h2><ul><li>在自己构建的plugin中 是否可以进行事件广播</li></ul><p>可以。只要能拿到 compiler或者compilation对象 就可以广播事件，为其他插件监听使用</p>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>异步流程处理</title>
      <link href="/2018/03/17/%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%A4%84%E7%90%86/"/>
      <url>/2018/03/17/%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>promise 可以说是很常用的异步处理方法</p><p>比如我们使用promise封装一个canvas截图的方法</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clip (resolve, reject) &#123;</span><br><span class="line">    // 截屏 获取图片url</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">      html2canvas(document.getElementById(&apos;view&apos;), &#123;</span><br><span class="line">        canvas: canvas,</span><br><span class="line">        onrendered: (canvas) =&gt; &#123;</span><br><span class="line">          let getImg = canvas.toDataURL(&apos;image/png&apos;)</span><br><span class="line">          resolve(getImg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实现一个简单的promise</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function Promise (executor) &#123;</span><br><span class="line">  let self = this</span><br><span class="line">  self.status = &apos;pending&apos;</span><br><span class="line">  self.success // 成功的原因</span><br><span class="line">  self.failure // 失败的原因</span><br><span class="line"></span><br><span class="line">  // 事件池</span><br><span class="line">  self.resolvePool = []</span><br><span class="line">  self.rejectPool = []</span><br><span class="line"></span><br><span class="line">  function resolve (data) &#123;</span><br><span class="line">    if (self.status == &apos;rejected&apos;) return</span><br><span class="line">    self.status = &apos;resolved&apos;</span><br><span class="line">    self.success = data</span><br><span class="line">    // 执行队列</span><br><span class="line">    self.resolvePool.forEach(function (cb)&#123;</span><br><span class="line">      cb(self.success)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  function reject (data) &#123;</span><br><span class="line">    if (self.status == &apos;resolved&apos;) return</span><br><span class="line">    self.status = &apos;rejected&apos;</span><br><span class="line">    self.failure = data</span><br><span class="line">    // 执行队列</span><br><span class="line">    self.rejectPool.forEach(function (cb)&#123;</span><br><span class="line">      cb(self.failure)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // new一个实例就会立即执行这个promise</span><br><span class="line">  executor(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// then</span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRejected)  &#123;</span><br><span class="line">  let self = this</span><br><span class="line">  let promiseStatus = self.status</span><br><span class="line">  if (promiseStatus == &apos;resolved&apos;) &#123;</span><br><span class="line">    onFulfilled(self.success)</span><br><span class="line">  &#125;</span><br><span class="line">  if (promiseStatus == &apos;rejected&apos;) &#123;</span><br><span class="line">    onRejected(self.failure)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 很有可能此时状态为 pending</span><br><span class="line">  if (promiseStatus == &apos;pending&apos;) &#123;</span><br><span class="line">    // 放入事件池中等待执行</span><br><span class="line">    self.resolvePool.push(function () &#123;</span><br><span class="line">      onFulfilled(self.success)</span><br><span class="line">    &#125;)</span><br><span class="line">    self.rejectPool.push(function () &#123;</span><br><span class="line">      onRejected(self.failure)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let target = beIteraor(&#123;name: &apos;mxx&apos;, address: &apos;beijing&apos;&#125;) </span><br><span class="line"></span><br><span class="line">target.next()</span><br><span class="line">target.next()</span><br></pre></td></tr></table></figure><p>Iterator 是一个迭代器对象 每次从集合中取出一项 并且跟踪当前序列所在位置 </p><p>通过使用next方法 返回一个包含value和done两个属性的对象 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;value: 当前对象成员, done: Boolean&#125;</span><br></pre></td></tr></table></figure><p>Iterator 简易实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let target = beIteraor([&apos;mxx&apos;, &apos;beijing&apos;])</span><br><span class="line"></span><br><span class="line">let a = target.next() </span><br><span class="line">let b = target.next()</span><br><span class="line">let c = target.next()</span><br><span class="line"></span><br><span class="line">// &#123; value: &apos;mxx&apos;, done: false &#125; &#123; value: &apos;beijing&apos;, done: false &#125; &#123; value: &apos;undefined&apos;, done: true &#125;</span><br><span class="line"></span><br><span class="line">// 返回一个具有next方法的对象</span><br><span class="line">function beIteraor(ary) &#123;</span><br><span class="line">  let index = 0</span><br><span class="line">  let len = ary.length</span><br><span class="line">  return &#123;</span><br><span class="line">    next: function () &#123;</span><br><span class="line">      // 调用next方法  返回 &#123;value, done&#125; 并且指针移动位置</span><br><span class="line">      let done =  ~~index == ~~len</span><br><span class="line">      // 如果指针位置移动到末尾 则返回undefined 否则返回当前位置成员</span><br><span class="line">      let value =  done ? &apos;undefined&apos; : ary[index]</span><br><span class="line">      index++</span><br><span class="line">      return &#123;value, done&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h2><ul><li>generator 函数生成一个迭代器 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 函数 注： 这里的read函数直接返回文件中内容 --&gt;</span><br><span class="line">function * getCont () &#123;</span><br><span class="line">  let name = yield &apos;youchangjing&apos;</span><br><span class="line">  let address = yield &apos;beijing&apos;</span><br><span class="line">  return name + address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 如何执行 --&gt;</span><br><span class="line"></span><br><span class="line">let getC = getCont()</span><br><span class="line">getC.next() // &#123;value: &apos;youchangjing&apos;, done: false&#125;</span><br><span class="line">getC.next() // &#123;value: &apos;beijing&apos; , done: false&#125;</span><br><span class="line">getC.next() // &#123;value: undefined , done: true&#125;</span><br></pre></td></tr></table></figure><p>可以看到 generator 函数调用和普通函数一样 fn() 即可 但是函数并不会执行 只有当调用next方法 才能执行到第一个状态</p><p>generator 是分段执行的 yield表示暂停执行 next方法恢复函数执行</p><p>目前来说 浏览器对 generator 支持情况还是很不错的</p><p><img src="/img/async/generator.png" alt="generator"></p><h3 id="co"><a href="#co" class="headerlink" title="co"></a>co</h3><p>如果 yield 后面是一个 promise 函数 可以配合co 库来使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!-- read函数  -- 封装的一个简易的promise --&gt;</span><br><span class="line">function read(dir) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    fs.readFile(dir, &apos;utf-8&apos;, (err, cont) =&gt; &#123;</span><br><span class="line">      if (err) reject(err)</span><br><span class="line">      resolve(cont)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- generator --&gt;</span><br><span class="line"></span><br><span class="line">function * getCont () &#123;</span><br><span class="line">  let name = yield read(&apos;name.js&apos;)</span><br><span class="line">  let address = yield read(&apos;address.js&apos;)</span><br><span class="line">  return name + address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配合co库 --&gt;</span><br><span class="line"></span><br><span class="line">co(getCont()).then(function (cont) &#123;</span><br><span class="line">  console.log(cont) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简单的CO实现原理</p><ul><li><p>co 的参数是一个迭代器</p></li><li><p>co 返回的是promise  返回的promise 接受 generator 函数的 value</p></li><li><p>co 内部可以使 generator 函数 一直执行到 done 为TRUE</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function co(iterator) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    function next(cont) &#123;</span><br><span class="line">      let &#123;value, done&#125; = iterator.next(cont)</span><br><span class="line">      &lt;!-- value 也是一个promise  --&gt;</span><br><span class="line">      if (done) &#123;</span><br><span class="line">        &lt;!-- 如果 done 为TRUE 则将value 传入 resolve --&gt;</span><br><span class="line">        resolve(value)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &lt;!-- done 为FALSE 则执行其then 方法 用于获取其data传递给 next --&gt;</span><br><span class="line">        value.then(function (data) &#123;</span><br><span class="line">          next(data) </span><br><span class="line">          &lt;!-- next 递归 --&gt;</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h2><p>async await 可以看做 co + generator  的语法糖</p><p>虽然co库可以帮我们自行处理generator 但是又要使用yield 又要封装promise 也是有点麻烦 所以转向 ES7 中的 async await</p><p>目前 async await 在Bable, Node 7+ 中被支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function getCont() &#123;</span><br><span class="line">  let people = await read(&apos;./file.js&apos;)</span><br><span class="line">  let who = await read(&apos;./who.js&apos;)</span><br><span class="line">  return people + who</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getCont().then((data) =&gt; console.log(data))</span><br></pre></td></tr></table></figure><ul><li>async 返回 promise</li></ul><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await 顾名思义 等待。那他在等待什么呢。 这个取决于await 后面跟着的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">await &apos;mxx&apos;</span><br><span class="line">&lt;!-- 等待非promise --&gt;</span><br><span class="line"></span><br><span class="line">await IamPromise()</span><br><span class="line">&lt;!-- 等待 promise --&gt;</span><br></pre></td></tr></table></figure><p>如果 await 等待的不是一个 promise  那么await表达式的运算结果就是 它等到的东西 （其实await会将其转为一个立即resolve的promise对象）</p><p>如果 await 等待的是promise 那么他会阻塞后面的代码 等着Promise 对象 resolve 然后得到其值作为 await表达式的运算结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getRank () &#123;</span><br><span class="line">  return 12345</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getType () &#123;</span><br><span class="line">  let name = await read(&apos;who.js&apos;)</span><br><span class="line">  &lt;!-- read为promise --&gt;</span><br><span class="line">  console.log(name)</span><br><span class="line">  let rank = await getRank()</span><br><span class="line">  &lt;!-- getRank 为普通函数  --&gt;</span><br><span class="line">  console.log(rank)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果我们在普通函数中使用await会被阻塞吗</li></ul><p>好吧~~  直接报错了</p><h3 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h3><p>async 中有两种错误处理方式</p><p>1 可以在 async 函数中 使用try catch  </p><p>async 中对try catch方法做了处理 使其可以捕获异步的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">async function () &#123;</span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 在then中进行错误捕获</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getCont().then().catch((e) =&gt; console.log(e))</span><br></pre></td></tr></table></figure><p>如果async函数中使用了try catch 那么后面的then方法将会进入成功态 【相当于promise返回的是 undefined 】</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><p><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener">bluebird</a></p></li><li><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">promise A+</a></p></li><li><p><a href="http://es6.ruanyifeng.com/#docs/iterator" target="_blank" rel="noopener">Tterator</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async</a></p></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">await</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack-7编译原理</title>
      <link href="/2018/02/03/webpack-7%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/2018/02/03/webpack-7%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在webpack的构建流程中，功能通过发布订阅事件来触发各个插件的执行， </p>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>API文档工具</title>
      <link href="/2018/01/27/API%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/01/27/API%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>有点项目是和同事一起开发的 前后端分离的时候 比较需要注意的就是API文档 今天找了一份API文档生成工具</p><a id="more"></a><h3 id="apidoc"><a href="#apidoc" class="headerlink" title="apidoc"></a>apidoc</h3><p><a href="http://apidocjs.com/" target="_blank" rel="noopener">官网</a></p><p><a href="http://apidoc.tools/" target="_blank" rel="noopener">CN官网</a></p><p>使用注意点</p><h4 id="在package-json中添加相应参数"><a href="#在package-json中添加相应参数" class="headerlink" title="在package.json中添加相应参数"></a>在package.json中添加相应参数</h4><p>  “description”: “apiDoc basic example”,<br>  “apidoc”: {<br>    “title”: “Custom apiDoc browser title”,<br>    “url” : “<a href="https://api.github.com/v1&quot;" target="_blank" rel="noopener">https://api.github.com/v1&quot;</a> // 这个是你的项目URL路径<br>  }</p><h4 id="代码中注释的书写格式"><a href="#代码中注释的书写格式" class="headerlink" title="代码中注释的书写格式"></a>代码中注释的书写格式</h4><p>api.doc是根据特定的代码书写格式来生成API文档的</p><p>注意在js中注释是这种格式的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @api &#123;get&#125; /user/:id Request User information</span></span><br><span class="line"><span class="comment"> * @apiName GetUser</span></span><br><span class="line"><span class="comment"> * @apiGroup User</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @apiParam &#123;Number&#125; id Users unique ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @apiSuccess &#123;String&#125; firstname Firstname of the User.</span></span><br><span class="line"><span class="comment"> * @apiSuccess &#123;String&#125; lastname  Lastname of the User.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>@apiSampleRequest <a href="http://localhost:8000/getLyric?queen" target="_blank" rel="noopener">http://localhost:8000/getLyric?queen</a>  这个将会在页面嵌入一个类似nodemon发送请求 的功能 非常棒</li></ul><h4 id="文档生成命令"><a href="#文档生成命令" class="headerlink" title="文档生成命令"></a>文档生成命令</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apidoc -f <span class="string">'index.js'</span> -i routes/   -o apidoc/</span><br></pre></td></tr></table></figure><p><img src="/img/api/apidoc.png" alt="apiDoc"></p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>无法开启文档更新监控功能 每一次修改需要重新执行命令</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
            <tag> apidoc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>发送请求的第三方插件</title>
      <link href="/2018/01/21/%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/01/21/%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p><a href="https://www.npmjs.com/package/request" target="_blank" rel="noopener">request npm</a></p><h3 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h3><p><a href="https://github.com/node-modules/urllib" target="_blank" rel="noopener">urllib github</a></p><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios 可同时应用与前端与server端</p><p><a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">Axios 中文说明</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>webpack-6配置问题</title>
      <link href="/2018/01/21/webpack-6%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2018/01/21/webpack-6%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="大问题"><a href="#大问题" class="headerlink" title="大问题"></a>大问题</h3><h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><p>1 入口文件与引入的静态文件不在一个目录怎么办</p><p>2 入口文件不是index.js</p><h3 id="小参数问题"><a href="#小参数问题" class="headerlink" title="小参数问题"></a>小参数问题</h3>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划8</title>
      <link href="/2018/01/21/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%928/"/>
      <url>/2018/01/21/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%928/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><ul><li><p>抽奖活动优化程序 准备上线</p></li><li><p>三期娃娃机需求测试反馈</p></li></ul><h2 id="life"><a href="#life" class="headerlink" title="life"></a>life</h2><ul><li><p>运营活动提出来</p></li><li><p>加入window.onError错误事件捕获</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划7</title>
      <link href="/2018/01/14/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%927/"/>
      <url>/2018/01/14/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%927/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><ul><li><p>H5接入微信支付功能</p></li><li><p>腊八节提测</p></li><li><p>娃娃机排行榜转为redis处理</p></li></ul><h2 id="life"><a href="#life" class="headerlink" title="life"></a>life</h2><ul><li><p>运营活动提出来</p></li><li><p>加入window.onError错误事件捕获</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何进行项目调试</title>
      <link href="/2018/01/06/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95/"/>
      <url>/2018/01/06/%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>由于我们处理的项目主要是适配移动端 所以如何进行页面调试 是一个很重要的问题 以下方式为Mac 未尝试window系统如何使用</p><h2 id="页面调试"><a href="#页面调试" class="headerlink" title="页面调试"></a>页面调试</h2><ul><li>iphone &amp;&amp; safari</li></ul><p>将你的手机用数据线连接到Mac中 打开Safari浏览器 选择开发选项 可以看待自己的移动设备名称</p><p><img src="/img/debug/safari.png" alt="safari"></p><p>你的移动设备需要在端外浏览器中打开页面才可以进行调试  比如查看控制台的log信息等</p><a id="more"></a><ul><li>Android &amp;&amp; Chrome</li></ul><p>移动设备要开启开发者选项</p><p>同样通过数据线将移动设备与Mac连接 然后在Chrome中打开控制台 点击右侧三个按钮</p><p><img src="/img/debug/chrome.png" alt="safari"></p><p>出现以上部分 点击remote devices 就可以看到你的移动设备页面了</p><p><img src="/img/debug/chrome2.png" alt="safari"></p><p>参见文章<a href="http://www.css88.com/doc/chrome-devtools/remote-debugging/" target="_blank" rel="noopener">远程调试Android设备</a></p><h2 id="抓取接口信息-Charles"><a href="#抓取接口信息-Charles" class="headerlink" title="抓取接口信息 Charles"></a>抓取接口信息 Charles</h2><h3 id="抓取PC端接口"><a href="#抓取PC端接口" class="headerlink" title="抓取PC端接口"></a>抓取PC端接口</h3><p>当打开Charles的代理 会发现 所有的网络请求 都会出现在左侧列表</p><p>参考文章<a href="https://www.jianshu.com/p/fdd7c681929c" target="_blank" rel="noopener">Charles使用</a></p><h3 id="抓取移动设备"><a href="#抓取移动设备" class="headerlink" title="抓取移动设备"></a>抓取移动设备</h3><p>使移动设备与PC端设备处于同一局域网的网络</p><ul><li>Charles</li></ul><p>打开Charles的代理设置：Proxy-&gt;Proxy Settings，设置一下端口号，默认的是8888，这个只要不和其他程序的冲突即可,并且勾选Enable transparent HTTP proxying</p><p><img src="/img/debug/charles.png" alt="safari"></p><ul><li>处理移动设备</li></ul><p>在WiFi管理的地方</p><p><img src="/img/debug/Charles.jpg" alt="Charles"></p><p>点击代理 选择手动 然后输入Charles的信息 主机就是电脑IP</p><p><img src="/img/debug/Charles2.png" alt="Charles"></p><p>当出现这个提示框的时候 提示是否允许这么做</p><p><img src="/img/debug/allow.png" alt="Charles"></p><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="chrome-链接设备出现空白页面"><a href="#chrome-链接设备出现空白页面" class="headerlink" title="chrome 链接设备出现空白页面"></a>chrome 链接设备出现空白页面</h3><p>参见文章 <a href="https://segmentfault.com/a/1190000007785694" target="_blank" rel="noopener">使用chrome remote debug时打开inspect时出现一片空白</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hi,2018</title>
      <link href="/2018/01/01/hi-2018/"/>
      <url>/2018/01/01/hi-2018/</url>
      
        <content type="html"><![CDATA[<p>早上并没有睡到自然醒，客厅里爱如潮水的歌声作为2018年的旋律不断刺激耳朵，心情happy。</p><p>hi，2018。再见，2017。</p><a id="more"></a><h3 id="新公司"><a href="#新公司" class="headerlink" title="新公司"></a>新公司</h3><p>其实入职公司的过程真的是机缘巧合，记得当时和同学说，刚刚接到电话要我去面试。然后是在百度搜了一下BLUED，emmm..    就感觉很酷。就像二次元与三次元的重叠。</p><p>那天关上浏览器的时候，画面停留的是一场在国外的婚礼上两个人交换戒指的场面，然后我对我同学说，好想去这个公司啊。公司文化一定很好。</p><p>特别奇妙的是，面试的时候发现公司的发源地原来是在秦皇岛，嗯~ 好酷~</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>书到用时方恨少。这是在工作里最大的体会。</p><p>工作里遇到很多大神级别人物，感觉他们很厉害。 在面对问题时候的解决方式，对待工作的态度，如何平衡工作和生活，很多很多地方需要学习。</p><p>年底的时候，开始逐渐承担项目组的一些工作，有压力~  目前还在适应阶段，有一点紧张。 在不断摸索如何平稳走过这个过渡期。</p><h3 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h3><p>从16年开始写博客 从CDSN 到 使用云空间 然后迁移的GitHub.io 最大的变化是在不断提升每一篇博客的质量 从最开始的比较多的记录性文章 到现在大多数的实践性文章 也算是一个小提高吧</p><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><p>接连两三次在地铁里出现心跳加速 呼吸困难的情况之后，(这里真的是字面意思，不是形容见到桌面那种感觉) 我去健身房报名了。感谢遇到负责的教练，不断督促我去锻炼。</p><p>目前的体重保持在96，我希望可以变胖一丢丢，长一点肌肉。</p><p>关于二次元，感觉17年在这个里面投入的时间精力有点多，不只是物质上的付出，还有精神上的。（现在想想，为了桌面熬夜到两点真的是不可理喻）</p><p>关于感情 emm~  参不透</p><h3 id="2018年-目标"><a href="#2018年-目标" class="headerlink" title="2018年 目标"></a>2018年 目标</h3><p>1 GitHub 中followers变为两位数</p><p>2 搞懂webpack！！！</p><p>3 搞一个服务器给自己的网站</p><p>4 关于习惯的养成  </p><p>  开始有意识的创建周计划 方便处理工作以及生活安排</p><p>5 个人博客的阅读笔记部分目前比重不多 要注意多多看技术文章 在这个方面努力一点  </p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> love </tag>
            
            <tag> 告别 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webapck-5</title>
      <link href="/2017/12/30/webpack-5/"/>
      <url>/2017/12/30/webpack-5/</url>
      
        <content type="html"><![CDATA[<h3 id="hash-与-chunkhash"><a href="#hash-与-chunkhash" class="headerlink" title="hash 与 chunkhash"></a>hash 与 chunkhash</h3><p>hash 指打包文件的hash值</p><p>chunkhash：每个chunk的hash值，你可以理解为版本号或则md5值，主要是保证每个文件的唯一性。</p><p>测试中发现</p><p>hash 有的时候代码不变动 保存的时候 也会新增 index.hash文件</p><p>chunkhash 只有当变动代码的时候 才会新生成文件</p><a id="more"></a><p><strong> 并且如果配置的是多个入口 这时候选择 chunkhash 比较合理 </strong> 也就是输出的时候 会有两个js文件</p><p>两个入口文件会生成两个js编译脚本，如果配置中使用的是 hash  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./index.js'</span>,</span><br><span class="line">    main: <span class="string">'./main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在public中查看打包完后会生成两个hash值文件 然后现在对其中的一个文件进行修改，（这里开启了watch模式） 可以直接看到 没有改动的那个js文件 也被重新编译了</p><p><img src="/img/webpack5/hash.png" alt="hash"></p><p>而且会发现 index 和 Main 后面的hash是一样的</p><p>如果我们这里使用的是 chunkhash  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">'[name].[chunkhash:4].js'</span>,</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'public'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当修改其中一个文件的时候 只会对修改的文件进行重新编译</p><p><img src="/img/webpack5/chunkhash.png" alt="chunkhash"></p><p>看官方文档的解释</p><blockquote><p>[hash] is replaced by the hash of the compilation.<br>[chunkhash] is replaced by the hash of the chunk</p></blockquote><p>hash 代表的是compilation的hash值  而 chunkhash 是根据模块内容计算出的hash值</p><h3 id="compilation"><a href="#compilation" class="headerlink" title="compilation"></a>compilation</h3><p>compilation对象代表某个版本的资源对应的编译进程。</p><p>当使用Webpack的development中间件时，每次检测到项目文件有改动就会创建一个compilation，进而能够针对改动生产全新的编译文件。compilation对象包含当前模块资源、待编译文件、有改动的文件和监听依赖的所有信息。</p><p>所以 只要文件有改动，compilation就会被重新创建 从而导致了哈希值变动</p><p>并且hash值是由compilation对象计算所得，而不是具体的项目文件计算所得，因此index 与 main 会具有相同的hash</p><h2 id="chunkFilename-与-CommonsChunkPlugin"><a href="#chunkFilename-与-CommonsChunkPlugin" class="headerlink" title="chunkFilename 与 CommonsChunkPlugin"></a>chunkFilename 与 CommonsChunkPlugin</h2><h3 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h3><p>异步加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'./two.js'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'那花草香'</span>)</span><br><span class="line">&#125;, <span class="string">'tips'</span>);</span><br></pre></td></tr></table></figure><p>当你的js文件中异步加载模块的时候 会把异步的文件编译的 chunkFilename.js 的文件中</p><p>按需加载的文件编译之后</p><p><img src="/img/webpack5/chunkFilename.png" alt="chunkFilename"></p><h2 id="Externals-外部扩展"><a href="#Externals-外部扩展" class="headerlink" title="Externals 外部扩展"></a>Externals 外部扩展</h2><p>项目中 我们使用第三方的库的时候 一般都是用过 import 导入</p><p>如果现在有一个第三方文件 并没有发布在npm中 那么除了在页面中直接通过 script 标签引入 还可以使用 import这种方式</p><p>这时候就需要在webpack中添加external配置项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  external: &#123;</span><br><span class="line">    otherSdk: <span class="string">'game_user'</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖</p></blockquote><p>也就是说 通过externals 配置的文件 将不会被编译到bundle中  而是直接从第三方提供的link链接去获取资源</p><p>还可以将其挂载在window中</p><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.smile = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`hi, <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后随便将其传入到在线网址 那么我们在项目中 如何通过URL的方式 引入这个文件呢</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="http://www.cnblogs.com/ihardcoder/p/5623411.html" target="_blank" rel="noopener">Webpack中hash与chunkhash的区别，以及js与css的hash指纹解耦方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack阅读笔记</title>
      <link href="/2017/12/24/webpack%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/12/24/webpack%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。</p><h2 id="Loader-特性"><a href="#Loader-特性" class="headerlink" title="Loader 特性"></a>Loader 特性</h2><p>loader 支持链式传递。能够对资源使用流水线(pipeline)。<br>一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。</p><a id="more"></a><h2 id="模块解析-Module-Resolution"><a href="#模块解析-Module-Resolution" class="headerlink" title="模块解析(Module Resolution)"></a>模块解析(Module Resolution)</h2><p>enhanced-resolve</p><p>可以解析三种规则 相对路径 绝对路径 模块路径</p><ul><li><p>指向一个文件</p></li><li><p>指向一个文件夹</p></li></ul><p><a href="https://doc.webpack-china.org/concepts/module-resolution/" target="_blank" rel="noopener">解析规则</a></p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>每个文件系统访问都被缓存，以便更快触发对同一文件的多个并行或串行请求。</p><p>在观察模式下，只有修改过的文件会从缓存中摘出。如果关闭观察模式，在每次编译前清理缓存。(Watch 模式默认关闭)</p><h2 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h2><p>webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。</p><p>从这些入口起点开始，webpack 递归地构建一个依赖图，【 这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle 】 - 通常只有一个 - 可由浏览器加载。</p><h2 id="Targets-？"><a href="#Targets-？" class="headerlink" title="Targets ？"></a>Targets ？</h2><p>webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  target: <span class="string">'node'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面例子中，使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。</p><h2 id="runtime-和-manifest"><a href="#runtime-和-manifest" class="headerlink" title="runtime 和 manifest"></a>runtime 和 manifest</h2><ul><li><p>runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。</p></li><li><p>manifest</p></li></ul><p>通过使用 bundle 计算出内容散列(content hash)作为文件名称，这样在内容或文件修改时，浏览器中将通过新的内容散列指向新的文件，从而使缓存无效。一旦你开始这样做，你会立即注意到一些有趣的行为。</p><p>即使表面上某些内容没有修改，计算出的哈希还是会改变。这是因为，runtime 和 manifest 的注入在每次构建都会发生变化</p><p><a href="https://doc.webpack-china.org/guides/output-management#the-manifest" target="_blank" rel="noopener">长效缓存错综复杂之处</a></p><p>你可能会感兴趣，webpack及其插件似乎“知道”应该哪些文件生成。答案是，通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪</p><h2 id="HotModuleReplacementPlugin-hmr"><a href="#HotModuleReplacementPlugin-hmr" class="headerlink" title="HotModuleReplacementPlugin (hmr)"></a>HotModuleReplacementPlugin (hmr)</h2><p>让我们从一些不同的角度观察，以了解 HMR 的工作原理……</p><h3 id="在应用程序中"><a href="#在应用程序中" class="headerlink" title="在应用程序中"></a>在应用程序中</h3><p>通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：</p><p>1 应用程序代码要求 HMR runtime 检查更新。<br>2 HMR runtime（异步）下载更新，然后通知应用程序代码。<br>3 应用程序代码要求 HMR runtime 应用更新。<br>4 HMR runtime（异步）应用更新。</p><p>你可以设置 HMR，[ 以使此进程自动触发更新 ]，或者你可以选择要求在用户交互时进行更新</p><h3 id="在编译器中"><a href="#在编译器中" class="headerlink" title="在编译器中"></a>在编译器中</h3><p>除了普通资源，编译器(compiler)需要发出 “update”，以允许更新之前的版本到新的版本。”update” 由两部分组成：</p><p>1 更新后的 manifest(JSON)<br>2 一个或多个更新后的 chunk (JavaScript)</p><p>manifest 包括新的编译 hash 和所有的待更新 chunk 目录。每个更新 chunk 都含有对应于此 chunk 的全部更新模块（或一个 flag 用于表明此模块要被移除）的代码。</p><p>编译器确保模块 ID 和 chunk ID 在这些构建之间保持一致。通常将这些 ID 存储在内存中（例如，使用 webpack-dev-server 时），但是也可能将它们存储在一个 JSON 文件中。</p><h3 id="在模块中"><a href="#在模块中" class="headerlink" title="在模块中"></a>在模块中</h3><p>HMR 是可选功能，【 只会影响包含 HMR 代码的模块 】。</p><p>举个例子，通过 style-loader 为 style 样式追加补丁。 为了运行追加补丁，style-loader 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。</p><p>类似的，当在一个模块中实现了 HMR 接口，你可以描述出当模块被更新后发生了什么。</p><p>然而在多数情况下，不需要强制在每个模块中写入 HMR 代码。如果一个模块没有 HMR 处理函数，更新就会冒泡。这意味着一个简单的处理函数能够对整个 模块树 ？？？ (complete module tree)进行更新。如果在这个模块树中，一个单独的模块被更新，那么整组依赖模块都会被重新加载。</p><h4 id="在-HMR-Runtime-中-？？？"><a href="#在-HMR-Runtime-中-？？？" class="headerlink" title="在 HMR Runtime 中 ？？？"></a>在 HMR Runtime 中 ？？？</h4><p>对于模块系统的 runtime，附加的代码被发送到 parents 和 children 跟踪模块。在管理方面，runtime 支持两个方法 check 和 apply。</p><p>check 发送 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，待更新 chunk 会和当前加载过的 chunk 进行比较。对每个加载过的 chunk，会下载相对应的待更新 chunk。当所有待更新 chunk 完成下载，就会准备切换到 ready 状态。</p><p>apply 方法将所有被更新模块标记为无效。对于每个无效模块，都需要在模块中有一个更新处理函数，或者在它的父级模块们中有更新处理函数。否则，无效标记冒泡，并也使父级无效。每个冒泡继续直到到达应用程序入口起点，或者到达带有更新处理函数的模块（以最先到达为准）。如果它从入口起点开始冒泡，则此过程失败。</p><p>之后，所有无效模块都被（通过 dispose 处理函数）处理和解除加载。然后更新当前 hash，并且调用所有 “accept” 处理函数。runtime 切换回闲置状态，一切照常继续。</p>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack文章记录</title>
      <link href="/2017/12/24/webpack%E6%96%87%E7%AB%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2017/12/24/webpack%E6%96%87%E7%AB%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ul><li><a href="https://github.com/renaesop/blog/issues/16" target="_blank" rel="noopener">webpack的主要对象</a>  </li></ul><p>没看懂</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><ul><li><a href="https://github.com/webpack/webpack/blob/master/lib/WebpackOptionsApply.js#L70-L185" target="_blank" rel="noopener">WebpackOptionsApply</a></li></ul><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。</p><p>也就是说，对于一种具体编程语言下的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。</p><p><a href="http://www.iteye.com/news/30731" target="_blank" rel="noopener">AST</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书笔记- mysql 必知必会</title>
      <link href="/2017/12/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-mysql%20%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2017/12/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-mysql%20%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CREATE TABLE <span class="string">`ACTIVITY20180529_DAILY`</span> (</span><br><span class="line">  <span class="string">`lid`</span> int(<span class="number">11</span>) NOT NULL COMMENT <span class="string">'这里是相关注释'</span>,</span><br><span class="line">  <span class="string">`day`</span> int(<span class="number">11</span>) NOT NULL,</span><br><span class="line">  <span class="string">`uid`</span> int(<span class="number">11</span>) NOT NULL DEFAULT <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`count`</span> int(<span class="number">11</span>) NOT NULL DEFAULT <span class="string">'0'</span>,</span><br><span class="line">  <span class="string">`time`</span> timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,</span><br><span class="line">  <span class="string">`lan`</span> char(<span class="number">11</span>) NOT NULL DEFAULT <span class="string">'en'</span>,</span><br><span class="line">  PRIMARY KEY (<span class="string">`uid`</span>,<span class="string">`lid`</span>,<span class="string">`day`</span>)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><h2 id="表数据操作"><a href="#表数据操作" class="headerlink" title="表数据操作"></a>表数据操作</h2><h3 id="查询表数据"><a href="#查询表数据" class="headerlink" title="查询表数据"></a>查询表数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT uid FROM TABLEBA</span><br></pre></td></tr></table></figure><ul><li>查询不同行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT uid FROM TABLEBA</span><br></pre></td></tr></table></figure><p>相当于查询每一个不重复的UID</p><p>注意： DISTINCT 关键字应用与后面所有的列</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT uid FROM TABLEBA  LIMIT start, number</span><br></pre></td></tr></table></figure><p>表示从start 查询 number 个 等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT uid FROM TABLEBA  LIMIT start OFFSET number</span><br></pre></td></tr></table></figure><p>如果LIMIT的后面只写一个 则表示取Number 个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT uid FROM TABLEBA  LIMIT number</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">`select id, uid, goods_id as goodsId, live_id from <span class="subst">$&#123;TABLE[<span class="string">'game'</span>]&#125;</span> where uid = <span class="subst">$&#123;uid&#125;</span> order by datetime desc limit <span class="subst">$&#123;number&#125;</span>`</span></span><br></pre></td></tr></table></figure><p>表示选取number 个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">`select id, uid, goods_id, live_id from <span class="subst">$&#123;TABLE[<span class="string">'game'</span>]&#125;</span> where uid = <span class="subst">$&#123;uid&#125;</span> order by datetime desc limit <span class="subst">$&#123;start&#125;</span>, 20`</span></span><br></pre></td></tr></table></figure><p>这里的limit m, n</p><p>表示从m 开始 选取n 个</p><h3 id="排序-order-by"><a href="#排序-order-by" class="headerlink" title="排序 order by"></a>排序 order by</h3><p>查询的结果按照某列排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid <span class="keyword">from</span> tablea order by count</span><br></pre></td></tr></table></figure><ul><li>按照多列排序</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid <span class="keyword">from</span> tablea order by count, day</span><br></pre></td></tr></table></figure><p>多列排序的时候， 会先按照count排序 当count相等的时候 再按照day排序</p><h4 id="order-by-xxx-desc"><a href="#order-by-xxx-desc" class="headerlink" title="order by xxx desc"></a>order by xxx desc</h4><p>默认排序是从小到大。如果希望从大到小排序。则需要添加关键字 desc</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid <span class="keyword">from</span> tablea order by count desc, day</span><br></pre></td></tr></table></figure><ul><li>desc 只针对于紧挨着关键字的列排序 如果想多列都降序排序 则需要将每一列都添加 DESC</li></ul><h3 id="筛选数据-WHERE"><a href="#筛选数据-WHERE" class="headerlink" title="筛选数据 WHERE"></a>筛选数据 WHERE</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid <span class="keyword">from</span> tablea where day &gt; <span class="number">20180412</span> order by count desc, day</span><br></pre></td></tr></table></figure><p>where 子句</p><table><thead><tr><th>含义</th><th>操作符</th></tr></thead><tbody><tr><td>等于</td><td>=</td></tr><tr><td>不等于</td><td>!= 或者 &lt;&gt;</td></tr><tr><td>大于</td><td>&gt;</td></tr><tr><td>大于等于</td><td>&gt;=</td></tr><tr><td>小于</td><td>&lt;</td></tr><tr><td>小于等于</td><td>&lt;=</td></tr><tr><td>在两者之间</td><td>between</td></tr></tbody></table><h4 id="关于查找-值为-null-的列"><a href="#关于查找-值为-null-的列" class="headerlink" title="关于查找 值为 null 的列"></a>关于查找 值为 null 的列</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid <span class="keyword">from</span> tablea where day is <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>这样虽然能查到结果 但是不建议这么操作 [未知具有特殊含义 数据库不知道他们是否匹配]</p><p>可以将 默认值 NULL 修改为字符串null 然后 where day &lt;&gt; ‘null’</p><h4 id="操作符-OR-AND-IN"><a href="#操作符-OR-AND-IN" class="headerlink" title="操作符 OR  AND IN"></a>操作符 OR  AND IN</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid <span class="keyword">from</span> tablea where day = <span class="number">20180412</span> or day =<span class="number">20180414</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid <span class="keyword">from</span> tablea where day = <span class="number">20180412</span> and city = <span class="string">'th'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select uid <span class="keyword">from</span> tablea where uid <span class="keyword">in</span> (<span class="number">123</span>, <span class="number">345</span>, <span class="number">567</span>)</span><br></pre></td></tr></table></figure><h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><p>用于否定跟在之后的条件 </p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="insert-into"><a href="#insert-into" class="headerlink" title="insert into"></a>insert into</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`insert into $&#123;TABLE&#125; (uid, name) values ($&#123;uid&#125;, $&#123;name&#125;)`</span><br></pre></td></tr></table></figure><p>如果想一次批量插入 先将语句利用循环进行拼接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> all = []</span><br><span class="line">end.forEach(<span class="function">(<span class="params">uid, name</span>) =&gt;</span> &#123;</span><br><span class="line">  all.push(<span class="string">`(<span class="subst">$&#123;uid&#125;</span>, <span class="subst">$&#123;name&#125;</span>)`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">`insert into <span class="subst">$&#123;TABLE&#125;</span> (uid, name) values (<span class="subst">$&#123;all.join(<span class="string">','</span>)&#125;</span>)`</span></span><br></pre></td></tr></table></figure><p>insert into 中如果有一列是 主键 则如果插入相同值的时候 会报错</p><h4 id="insert-ignore"><a href="#insert-ignore" class="headerlink" title="insert ignore"></a>insert ignore</h4><p>没有就进行插入 有就不做任何操作</p><ul><li>这个一般会有性能问题 不建议使用</li></ul><h4 id="插入检索出来的数据"><a href="#插入检索出来的数据" class="headerlink" title="插入检索出来的数据"></a>插入检索出来的数据</h4><p>从TABLEA 检索数据 放入 TABLEB 中</p><ul><li><p>从A中查询出所有数据然后 在放入 TABLEB中</p></li><li><p>直接放入从A检索处理来的数据</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO ACTIVITY20180529_ANCHOR (uid) SELECT uid FROM ACTIVITY20180529_ROOM</span><br></pre></td></tr></table></figure><p>注意，通过这种方式插入的列数据 不是根据列名去插入 而是根据写的位置去插入  比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO TABLEA (uid, city, time) SELECT city, uid, day FROM TABLEB</span><br></pre></td></tr></table></figure><p>如果是这样写的话 从TABLEB 中查询出来的 city 列 会进入 TABLEA 的 uid 列</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">update $&#123;TABLE&#125; set name = $&#123;name&#125; where uid = <span class="number">4</span> limit <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这个更新有一个问题  无法批量进行更新</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`DELETE FROM <span class="subst">$&#123;TABLE&#125;</span> WHERE id=3`</span></span><br></pre></td></tr></table></figure><h2 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h2><h3 id="时间戳-amp-amp-时间"><a href="#时间戳-amp-amp-时间" class="headerlink" title="时间戳 &amp;&amp; 时间"></a>时间戳 &amp;&amp; 时间</h3><ul><li>时间戳 -》时间</li></ul><p>如果表中存放的是时间戳 但是想获取的是普通时间格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`select FROM_UNIXTIME(1516243968)`</span></span><br></pre></td></tr></table></figure><ul><li>时间 -》时间戳</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`select UNIX_TIMESTAMP('2017-01-01')`</span></span><br></pre></td></tr></table></figure><h2 id="汇总函数"><a href="#汇总函数" class="headerlink" title="汇总函数"></a>汇总函数</h2><table><thead><tr><th>含义</th><th>操作符</th></tr></thead><tbody><tr><td>求和</td><td>SUM</td></tr><tr><td>返回某列的行数</td><td>COUNT</td></tr></tbody></table><ul><li>sum </li></ul><p>求和</p><p>比如 计算某一个用户收到的礼物总和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(beans) FORM TABLE WHER UID = <span class="number">131</span></span><br></pre></td></tr></table></figure><ul><li>count </li></ul><p>计算行的出现次数</p><p>比如，筛选某一个用户抽奖次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(uid) FORM TABLE WHER UID = <span class="number">131</span></span><br></pre></td></tr></table></figure><p>注： 如果使用的 COUNT(<em>) 则将会包含 NULL 值的那些行  如果不是用时</em>  那么会忽略掉 NULL  行</p><h2 id="分组-GROUP-BY"><a href="#分组-GROUP-BY" class="headerlink" title="分组 GROUP BY"></a>分组 GROUP BY</h2><p>GROUP BY xxx</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>border-image</title>
      <link href="/2017/12/05/border-image/"/>
      <url>/2017/12/05/border-image/</url>
      
        <content type="html"><![CDATA[<p>有处理到一个CSS问题 内容列表区域展示部分 边框是图片形式的~ css画不出来~~</p><a id="more"></a><p>使用的border-iamge处理边框图片的问题</p><p>最终效果如下~</p><p><img src="/img/borderImage/border1.png" alt="border"></p><p>关于border-image这里不多做解释  可参考文章</p><ul><li><p><a href="http://www.zhangxinxu.com/wordpress/2010/01/css3-border-image/" target="_blank" rel="noopener">张鑫旭css3-border-image</a></p></li><li><p><a href="https://www.cnblogs.com/fsjohnhuang/p/5449717.html" target="_blank" rel="noopener">CSS魔法堂：重拾Border之——图片作边框</a></p></li></ul><p>这里只几点使用中注意的问题</p><h4 id="round-与-repeat"><a href="#round-与-repeat" class="headerlink" title="round 与 repeat"></a>round 与 repeat</h4><p>您从万科地产买了个99.5m<em>99.5m的毛坯房，地面要贴瓷砖，都是1m</em>1m的正方形瓷砖。<br>  如果是“平铺”，对不起，这1m边长的瓷砖不行，要处理！怎么处理法？很简单，每个瓷砖压成0.995m*0.995m的，这样就可以了，所以，平铺就是以完整的单元铺满整个区域。</p><p>  如果是重复，就直接把这1m*1m的瓷砖从一个角落一个一个的放置，放到头放不下了怎么办？直接把瓷砖从中间“咔”掉，于是最后会在房子的边角看到很多半截的瓷砖</p><p> — 来自<a href="http://www.zhangxinxu.com/wordpress/2010/01/css3-border-image/" target="_blank" rel="noopener">张鑫旭css3-border-image</a></p><h4 id="border-iamge-与-border-radius-冲突"><a href="#border-iamge-与-border-radius-冲突" class="headerlink" title="border-iamge 与 border-radius 冲突"></a>border-iamge 与 border-radius 冲突</h4><p>项目设计稿中 边框是有圆角的 因此我又添加了圆角属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">background: green;</span><br><span class="line">border: 5px solid #fff;</span><br><span class="line">border-image-source:url(<span class="string">'../../img/border2.png'</span>);</span><br><span class="line"><span class="comment">/* 以九宫格形式做切片 */</span></span><br><span class="line">border-image-slice:<span class="number">20</span>;</span><br><span class="line">border-image-repeat: round;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加圆角属性 */</span></span><br><span class="line">border-radius: <span class="number">20</span>px;</span><br></pre></td></tr></table></figure><p>但是页面中并没有出现圆角效果</p><p>问题参见 <a href="https://segmentfault.com/q/1010000006613100" target="_blank" rel="noopener">css3 怎么实现border-image圆角的问题</a></p><p>核心在于 当使用border-iamge时候 会压制 border的样式  如果border-iamge 出错  就会展示border的样式</p><p>然后测试一下  写一个错误的URL图片路径</p><p><img src="/img/borderImage/border2.png" alt="border"></p><p>当border-image 失效的时候  border style 就可以看到了</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-image" target="_blank" rel="noopener">MDN</a></p><blockquote><p>使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式。虽然规范要求使用 border-image 时边框样式必须存在，但一些浏览器可能没有实现这一点。</p></blockquote><blockquote><p>特别注意，若 border-image-source（此值可用border-image-source或border-image简写设置) 的值为 none 或者图片不能显示，则将应用 border-style。</p></blockquote><p>其实我觉得 border-style 其实是实现了的 但是被border-image 的效果遮挡住了 我们可以拿一个透明图片来测试一下</p><p>那么怎么实现圆角效果呢？</p><ul><li>利用九宫格原理  将资源图片设置为圆角</li></ul><p>开始时候我们的资源图片是这个样子的</p><p><img src="/img/borderImage/border4.png" alt="border"></p><p>是一个60 x 60的图片源</p><p>这经过九宫格处理之后  每一个格子就是 20 x 20的</p><p>那么此时分布在元素border的四个角上的 对应着 九宫格的四个角</p><p>所以我们只要把资源图片的四个角位置设置为有弧度的  那么经过九宫格处理后 页面就可以看到圆角效果了</p><p>所以将资源图片更改为</p><p><img src="/img/borderImage/border3.png" alt="border"></p><p>然后刷新页面</p><p><img src="/img/borderImage/border5.png" alt="border"></p><p>这里看到有一个圆角效果了 但是后面的多余元素颜色也漏出来了 所以再添加一个 border-radius 就可以了</p><ul><li>盒子的overflow</li></ul><p>将页面结构更改为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>  国际圣诞节 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后里面div的样式不要变动</p><p>在section中做处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 10px;</span><br><span class="line">overflow: hidden;</span><br></pre></td></tr></table></figure><p><img src="/img/borderImage/border6.png" alt="border"></p><p>这样也可以走到罗马</p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
            <tag> border-iamge </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划6</title>
      <link href="/2017/12/03/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%926/"/>
      <url>/2017/12/03/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%926/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><p>国际母亲节</p><p>12-21 圣诞节</p><p>涉及知识点：</p><ul><li><p>精准定位</p></li><li><p>border-image</p></li><li><p>第三方分享机制</p></li><li><p>react-router</p></li></ul><!-- more --><h3 id="life"><a href="#life" class="headerlink" title="life"></a>life</h3><ul><li>webpack</li></ul><p>配置根据环境分开</p><ul><li>koa</li></ul><p>koa 主页解析有问题</p><ul><li>柯南</li></ul>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack-4 - webpack的常用plugin</title>
      <link href="/2017/11/30/webpack-4-webpack%E7%9A%84%E5%B8%B8%E7%94%A8plugin/"/>
      <url>/2017/11/30/webpack-4-webpack%E7%9A%84%E5%B8%B8%E7%94%A8plugin/</url>
      
        <content type="html"><![CDATA[<p>webpack的常用plugin</p><a id="more"></a><h3 id="CommonsChunkPlugin"><a href="#CommonsChunkPlugin" class="headerlink" title="CommonsChunkPlugin"></a>CommonsChunkPlugin</h3><p>打包公共文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: [<span class="string">'vendor'</span>, <span class="string">'manifest'</span>],</span><br><span class="line">  minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">  <span class="comment">// (随着 entry chunk 越来越多， 这个配置保证没其它的模块会打包进 vendor chunk)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>CommonsChunkPlugin 的配置项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(<span class="string">'init'</span>)</span><br></pre></td></tr></table></figure><p>编译之后的文件命名将按照传入的文件名 + 配置在output中 filename格式 进行命名</p><p>比如 在filename中是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">  filename: <span class="string">'[name].[chunkhash:4].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则上面公共文件输出为 init.89sk.js 也就是也会配置相应的哈希值</p><h4 id="公共业务模块与类库或框架分开打包"><a href="#公共业务模块与类库或框架分开打包" class="headerlink" title="公共业务模块与类库或框架分开打包"></a>公共业务模块与类库或框架分开打包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'react'</span>],</span><br><span class="line">    index: <span class="string">'./index.js'</span>,</span><br><span class="line">    main: <span class="string">'./main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  -- --</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: [<span class="string">'bundle'</span>, <span class="string">'vendor'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/webpack5/commonChunk.png" alt="commonsCunkPlugin"></p><p>但是这里有一个问题 如果项目中有 非 vendor 中的文件发生了重新编译  vendor 的文件也会被重新编译</p><h4 id="vendor-哈希值一直变动问题"><a href="#vendor-哈希值一直变动问题" class="headerlink" title="vendor 哈希值一直变动问题"></a>vendor 哈希值一直变动问题</h4><p>（一下的测试全部指的是单入口应用）</p><p>为了最小化生成的文件大小，webpack使用标识符而不是模块名称，在编译期间生成标识符，并映射到块文件名，然后放入一个名为chunk manifest的JS对象中。重点就在于！！当我们使用CommonsChunkPlugin分离代码时，被分离出来的代码（比如React库，被打包为vendor），会默认被移动到entry中最后一个入口进行打包（第一个入口是index.js。重要的是，chunk manifest将随着这些被分离出来的代码共同打包！！！</p><p>由于我们更改源代码后，不但会更新app的hash值，还会生成新的映射，然后新的映射又会和资源代码一同打包，又由于chunkhash是根据内容生成hash的，那么加入了新的映射对象chunk manifest的资源代码被打包后，hash自然也会发生改变。这反过来，产生的新hash将使长效缓存失效。</p><p>那么接下来我们需要做的就是把 manifest分离出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: [<span class="string">'vendor'</span>, <span class="string">'manifest'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>添加一个entry中未用到的名称 就可以manifest分离出来了 这样每次文件变动的时候  manifest.js 会发生变动 而 vendor 不会再发生变动</p><h3 id="HashedModuleIdsPlugin-与-NamedModulesPlugin"><a href="#HashedModuleIdsPlugin-与-NamedModulesPlugin" class="headerlink" title="HashedModuleIdsPlugin 与 NamedModulesPlugin"></a>HashedModuleIdsPlugin 与 NamedModulesPlugin</h3><p>这个需要配合上面说的 commonsCunkPlugin 使用</p><p><a href="http://www.jb51.net/article/120195.htm" target="_blank" rel="noopener">参考文章</a></p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>每次重新打包都会清理 pbblic 文件夹的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin(</span><br><span class="line">    [<span class="string">'public/index-*.js'</span>,<span class="string">'public/manifest-*.js'</span>],　 <span class="comment">// 匹配删除的文件</span></span><br><span class="line">    &#123;</span><br><span class="line">      root: __dirname,       　　　　　　　　　　<span class="comment">//根目录</span></span><br><span class="line">      <span class="comment">// verbose: true,   // 开启在控制台输出信息 其实默认为TRUE</span></span><br><span class="line">      <span class="comment">// dry: false  // 删除文件 默认FALSE</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样每次重新打包的时候 public文件夹都会删除掉</p><p><img src="/img/webpack/webpack-clean.png" alt="clean"></p><table><thead><tr><th>属性名</th><th>默认的属性值</th><th>含义</th></tr></thead><tbody><tr><td>root</td><td>__dirname</td><td>根节点</td></tr><tr><td>verbose</td><td>true</td><td>在控制台输出log</td></tr><tr><td>dry</td><td>false</td><td>执行删除操作</td></tr><tr><td>watch</td><td>false</td><td>在编译的时候 不去 删除旧的文件</td></tr><tr><td>exclude</td><td>数组</td><td>删除的时候 这个数组中的不进行删除</td></tr><tr><td>allowExternal</td><td>false</td><td>不可以删除在上面配置的root之外的文件</td></tr></tbody></table><p>其实还可以通过在命令行添加参数实现清除功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"webpack"</span>: <span class="string">"rm -rf public; webpack --watch"</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/johnagan/clean-webpack-plugin" target="_blank" rel="noopener">github地址</a></p><h3 id="UglifyJsPlugin"><a href="#UglifyJsPlugin" class="headerlink" title="UglifyJsPlugin"></a>UglifyJsPlugin</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</span><br></pre></td></tr></table></figure><h3 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h3><p>此插件用于分离CSS和JS文件</p><p>将css文件单独打包到css文件，而不是写在js文件中（因为webpack将一切都视为模块，所以默认会打包到js文件中）</p><p>它会将所有的入口 chunk(entry chunks)中引用的 sass less 或者 styles 文件，移动到独立分离的 CSS 文件</p><p>因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载</p><p>在Module中配置 loader 在 plugin中添加ExtractTextPlugin 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">        use: <span class="string">"css-loader"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'index.css'</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>所有chunk中被引入的 CSS文件被打包到一个CSS文件中 并被引入index</p><p><img src="/img/webpack/style.png" alt="style"></p><p>如果是多个入口文件 需要各自引入需要的js 以及 css 文件呢 则需要这么配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/webpack/style2.png" alt="style"></p><p>需要同时配置 modules 和  plugins</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> extractCSS = <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style/[name]-css.css'</span>)</span><br><span class="line"><span class="keyword">const</span> extractLESS = <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style/[name]-less.css'</span>)</span><br><span class="line"><span class="keyword">const</span> extractSCSS = <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'style/[name]-scss.css'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: extractLESS.extract([ <span class="string">'css-loader'</span>, <span class="string">'less-loader'</span> ])</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 处理 sass 相关</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: extractLESS.extract([ <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span> ])</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 处理css</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: extractCSS.extract([ <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span> ])</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    extractCSS,</span><br><span class="line">    extractLESS,</span><br><span class="line">    extractSCSS,</span><br><span class="line">  ]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/webpack-contrib/extract-text-webpack-plugin" target="_blank" rel="noopener">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划5</title>
      <link href="/2017/11/22/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%925/"/>
      <url>/2017/11/22/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%925/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><p>娃娃机项目 【紧急】</p><p>蓝v推广</p><!-- more --><p>国际父亲节</p><h3 id="life"><a href="#life" class="headerlink" title="life"></a>life</h3><p>项目总结</p><ul><li><p>koa</p></li><li><p>webpack</p></li></ul><p>** 为什么HTML变化 页面不刷新  只有js变化 才引起页面刷新</p><p>** 为什么 UglifyJsPlugin 配置出错</p><p>** 目前webpack打包之后的文件在内存中 不再public里面</p><p>** babel 配置问题</p><p>** DevServer 中 proxy 代理设置</p><p>** CleanWebpackPlugin 中 exclude</p><p>** 为什么css 和 less 都被编译了</p>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解析bilibili</title>
      <link href="/2017/11/07/%E8%A7%A3%E6%9E%90bilibili/"/>
      <url>/2017/11/07/%E8%A7%A3%E6%9E%90bilibili/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>JavaScript零碎</title>
      <link href="/2017/11/06/JavaScript%E9%9B%B6%E7%A2%8E/"/>
      <url>/2017/11/06/JavaScript%E9%9B%B6%E7%A2%8E/</url>
      
        <content type="html"><![CDATA[<p>JavaScript零碎知识点</p><a id="more"></a><p>1 关于运算符</p><p>算数运算符：+ - * / %</p><p>比较运算符：&lt; &gt; &lt;= &gt;= == === != !==</p><p>逻辑运算符：&amp;&amp; || ！</p><p>运算符的优先级: 算数 &gt; 比较 &gt; 逻辑 &gt; 赋值</p><p>2 if() 条件为真假</p><p>除了以下六个为假，其他都为真： false 0 “” null undefined NaN</p><p>4 JavaScript 基本数据类型</p><p>Undefined Null Number String Boolean</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>别人的读书笔记</title>
      <link href="/2017/11/06/%E5%88%AB%E4%BA%BA%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/11/06/%E5%88%AB%E4%BA%BA%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>1 <a href="https://sunshinevvv.coding.me/blog/2017/01/26/%E5%9B%BE%E8%A7%A3HTTP-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">《图解HTTP》读书笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>http与https</title>
      <link href="/2017/11/06/http%E4%B8%8Ehttps/"/>
      <url>/2017/11/06/http%E4%B8%8Ehttps/</url>
      
        <content type="html"><![CDATA[<p>在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：</p><!--nore--><p><img src="/img/http/https.png" alt="https"></p><p>HTTP默认的端口号为80，HTTPS的端口号为443。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>http基础知识2</title>
      <link href="/2017/11/06/http%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/"/>
      <url>/2017/11/06/http%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862/</url>
      
        <content type="html"><![CDATA[<p>http 的报文由起始行 头部 主体构成 包含许多信息</p><p>请求行包含用于请求的方法，请求 URI 和 HTTP 版本。 状态行包含表明响应结果的状态码，原因短语和 HTTP 版本</p><a id="more"></a><h3 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h3><h4 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h4><blockquote><p>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式</p></blockquote><p>本文只讲解两种 对其余有兴趣的同学可自行阅读</p><ul><li><p>GET 向特定的资源发出请求</p></li><li><p>POST</p></li></ul><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。</p><p>POST请求可能会导致新的资源的建立和/或已有资源的修改</p><p>方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）</p><h4 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET POST"></a>GET POST</h4><p>GET一般用于获取/查询资源信息，而POST一般用于更新资源信息</p><p>GET和POST的区别：</p><p>1、传递数据方式不同</p><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.</p><p>POST方法是把提交的数据放在HTTP包的Body中。</p><p>2、数据大小限制不同</p><p>GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</p><p>3、安全方面</p><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p><p>所以涉及到用户信息的 最好使用post请求处理</p><h3 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h3><p>常用的http响应状态码</p><ul><li><p>200 成功</p></li><li><p>3xx 重定向</p></li><li><p>4xx 出错</p></li><li><p>5xx 服务器出错</p></li></ul><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>1 <a href="http://www.jianshu.com/p/d8a7becd0fd1" target="_blank" rel="noopener">http协议扫盲</a></p><p>2 <a href="http://blog.csdn.net/zhangmengleiblog/article/details/52513227" target="_blank" rel="noopener">http网络请求 返回statusCode</a></p><p>3 <a href="http://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd" target="_blank" rel="noopener">99%的人都理解错了HTTP中GET与POST的区别</a></p><p>4 <a href="https://sunshinevvv.coding.me/blog/2017/02/09/HttpGETv.s.POST/" target="_blank" rel="noopener">HTTP协议中GET和POST方法的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划4</title>
      <link href="/2017/11/06/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%924/"/>
      <url>/2017/11/06/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%924/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><ul><li>公益问卷提测</li></ul><h3 id="life"><a href="#life" class="headerlink" title="life"></a>life</h3><ul><li><p>配置mac</p></li><li><p>继续阅读暗时间</p></li><li><p>正则基本知识的那篇博客 差一点东西在纸质资料中</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>客户端与服务端交互模型</title>
      <link href="/2017/11/05/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2017/11/05/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>客户端与服务器端</p><p>当用户在客户端输入一个网址，在点击enter 到页面被渲染出来，中间经历了什么事情。</p><!--nore--><p>什么是客户端</p><p>能向服务器端发送请求并且接受内容的都是客户端</p><p>什么是服务器端</p><p>能接受客户端请求并且返回内容给客户端的都是服务器端</p><p>2  详细步骤</p><p>1 购买一个服务器 在连上网后  获得了一个外网IP地址</p><p>2 通过ftp上传项目资源文件 到服务器</p><p>3买一个域名 进行DNS域名解析</p><p>在DNS 服务器    将域名  <a href="http://www.webmxx,com" target="_blank" rel="noopener">www.webmxx,com</a>  解析到购买的那服务器端 IP地址</p><p>4 在服务器上创建一个服务。</p><p>这个服务接受客户端的请求，把客户端的想要的内容返回给客户。为了区分每一个服务，给其监听一个端口号。</p><p>如何创建服务</p><p>4.1 指定当前服务负责哪个文件目录</p><p>4.2 不同的服务   端口号不同</p><p>3 当用户在客户端输入一个网址，在点击enter 到页面被渲染出来，中间经历了什么事情。</p><p>1 通过域名  找到DNS 上对应的外网IP  就是服务器主机IP 【就是所谓的外网IP】</p><p>2 通过外网IP找到对应的服务器</p><p>3 通过地址栏端口号找到相应服务</p><p>4 到相应目录中找到所需要的文件</p><p>5 服务器端这个服务会把资源文件中的源代码发回给客户端浏览器</p><p>6 客户端浏览器获取到源代码后进行解析渲染</p><p>以上123属于请求阶段  Request     45 属于响应阶段 Response</p><p>4 URL URI URN</p><p><a href="http://mxx2015web.gotoip2.com/wp-admin/post.php?post=633&amp;action=edit" target="_blank" rel="noopener">http://mxx2015web.gotoip2.com/wp-admin/post.php?post=633&amp;action=edit</a></p><p><a href="http://www.webmxx.com/dest/JSTEST/Canvas/canvas-girl.html" target="_blank" rel="noopener">http://www.webmxx.com/dest/JSTEST/Canvas/canvas-girl.html</a></p><p>这个严格意义上是叫URI</p><p>URI  统一资源标识符</p><p>URL  统一资源定位符</p><p><a href="http://mxx2015web.gotoip2.com/wp-admin/post.php" target="_blank" rel="noopener">http://mxx2015web.gotoip2.com/wp-admin/post.php</a><br>URN 统一资源名称</p><p>wp-admin/post.php?post=633&amp;action=edit<br>URI 包含了 URI 和 URN</p><p>不过一般将那个地址称为URL ，之后本文也以URL指代。</p><p>5 解析URL</p><p>以 <a href="http://www.webmxx.com:80/wp-admin/post.php?post=633&amp;action=edit#video" target="_blank" rel="noopener">http://www.webmxx.com:80/wp-admin/post.php?post=633&amp;action=edit#video</a> 为例</p><p>5.1 http</p><p>传输协议。作为一个传输载体，可以帮客户端把内容传递给服务器 也可以帮服务器把内容传递给客户端。通俗理解为快递员。</p><p>常用的传输协议</p><p>1 HTTP</p><p>超文本传输协议   [除了传递文本内容之外 还可以传递其他内容 例如 二进制编码 XML格式数据 Base64 的等等]</p><p>2 HTTPS   【HTTP SSL】</p><p>更加安全的超文本传输协议  相对于HTTP  传输的时候 进行了一层加密</p><p>3 FTP</p><p>文件上传下载协议 一般应用于把本地项目资源文件上传到服务器上  特点:传递的文件比较大</p><p>以前那种点击下载文件的就是通过FTP做的</p><p>5.2  <a href="http://www.webmxx.com" target="_blank" rel="noopener">www.webmxx.com</a></p><p>域名  作用 就是设定一个方便用户记忆的名字</p><p>1 后缀名有</p><p>.com  .cn   .net  .com.cn  .org  .gov  等等<br>2 一级域名 二级域名 三级域名</p><p>一级域名  例 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a></p><p>二级域名  例 sports.qq.com</p><p>三级域名  例 kbs.sports.qq.com</p><p>只要购买了一级域名，二级域名 三级域名 就是自己基于一级域名下分的</p><p>5.3 端口号  80</p><p>区分不同的服务</p><p>同一台服务器上 可创建多个服务 每一个都有自己的端口号</p><p>端口号取值范围 0 -65535 之间 ,也就是最大能创建65536个服务。但是一般在1-5 个左右</p><p>一般项目是不需要用户输入端口号的,浏览器这边会根据传输协议的不同 ,会添加不同的默认端口号</p><p>比如 HTTP 默认端口号 80  HTTPS 默认端口号443  FTP默认端口号21</p><p>5.4 /wp-admin/post.php</p><p>需要请求的资源文件目录</p><p>第一个/  表示请求的是当前项目根目录下的wp-admin文件夹中的post.php文件</p><p>5.5  ?后面的  ?post=633&amp;action=edit</p><p>问号传参</p><p>把这些信息以问号的方式追加在URL末尾 把内容传递给服务器</p><p>5.5.1 可以通过这种方式传递给服务器指定的内容 从而获取到指定信息</p><p>例如，要获取name=’tom’ 的信息 ，需要把name=‘tom’传递给服务器</p><p>5.5.2 通过问号传参，将数据在两个页面之间传递</p><p>例如 A为列表页 B为详情页</p><p>点击A中记录可跳转到B中页面  就是在B页面中展示不同的详细信息 所以B需要知道A点击的是谁</p><p>所以在点击A中记录的时候 不仅要跳转到B 还需要通过问号传参的方式 传递过去一些标识即可</p><p>5.6 #video   #后面的   -》 hash  哈希值</p><p>1 锚点定位</p><p>当页面加载的时候 或者 点击a 标签 可以直接跳转到 具有该ID的元素位置</p><p>2 前端路由 [单页面应用]</p><p>3 传递给服务器进行标识 [不常用 一般都是用问号传参进行标识]</p><p>6 客户端拿到服务器返回的东西 之后  渲染页面 解析数据</p><p>6.1 为什么代码放在浏览器中可以呈现出页面样式。</p><p>W3C  万维网联盟  一个制定编程语言的非联盟组织</p><p>代码写完运行在浏览器中</p><p>浏览器制造商   制定编译规范</p><p>WEB开发者  按照W3C 规则编写网页</p><p>6.2 浏览器制造商</p><p>从浏览器内核[引擎] 来分</p><p>6.2.1 webkit 内核  又称 V8引擎</p><p>移动端浏览器都是V8引擎</p><p>chrome  谷歌        safari</p><p>-webkit-</p><p>6.2.2  Trident内核代表产品Internet Explorer，又称其为IE内核</p><p>-ms-</p><p>6.2.3 Gecko内核代表作品Mozilla  火狐</p><p>-moz-</p><p>6.2.4 Presto内核代表作品Opera</p><p>-0-</p><p>6.2.5 中国版浏览器 Trident 或者 webkit</p><p>6.4</p><p>从服务器把原代码获取到之后 教给浏览器内核进行解析 在解析过程中 遇到标签 link  video  audio  script iframe</p><p>等的时候，需要重新向服务器发送请求 把内容获取到 进行解析。这样导致 一个页面在加载完毕 会向服务器发送多次请求</p><p>在chrome的network中 可以看到所有的客户端与服务器的交互信息 [请求 响应]  而且信息非常完整</p><p>6.5  前端优化</p><p>前端优化: 用户打开页面的时候 能迅速打开页面</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>http基础篇</title>
      <link href="/2017/11/04/http%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2017/11/04/http%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是http"><a href="#什么是http" class="headerlink" title="什么是http"></a>什么是http</h2><p>HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写  目前使用的大多是HTTP 1.1版本</p><a id="more"></a><p>HTTP [超文本传输协议] 是获取网络资源的协议，在获取HTML页面后者js文件都需要按照此协议。HTTP协议是web数据交换的基础。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等在客户端从服务端接受到相应后，进行数据解析和页面渲染</p><h2 id="http的特点"><a href="#http的特点" class="headerlink" title="http的特点"></a>http的特点</h2><p>1.支持客户/服务器模式。</p><p>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p><p>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p><p>4.无连接：无连接的含义是限制每次连接只处理一个请求。</p><p>服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p><p>5.无状态：HTTP协议是无状态协议。</p><p>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p><p>就是在同一个连接中，在两个请求之间是完全没有关系的。所以服务器不知道这两个请求来自同一个连接</p><p>可以通过设置请求头或者使用cookie等存储机制解决此问题</p><h2 id="http-分析"><a href="#http-分析" class="headerlink" title="http 分析"></a>http 分析</h2><p>HTTP协议属于TCP/IP协议族应用层的协议。</p><h3 id="持久链接"><a href="#持久链接" class="headerlink" title="持久链接"></a>持久链接</h3><p>持久链接（HTTP Persistent Connections、HTTP keep-alive、HTTP connection reuse）</p><p>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP链接，频繁的TCP链接与断开（如请求一个有很多图片的网页）会造成无谓的流量消耗和低效的性能。</p><p>持久链接的特点是：只要任意一端没有明确地提出断开连接，则保持TCP连接状态。</p><p>在HTTP/1.1中，所有的连接默认都是持久连接，持久连接的实现需要服务器端和客户端同时支持。</p><p>持久连接使得当有多个请求时，可以以管线化方式发出请求：不用等待前一个请求的响应即可以直接发送下一个请求（实现并行请求行为）</p><h3 id="HTTP事务"><a href="#HTTP事务" class="headerlink" title="HTTP事务"></a>HTTP事务</h3><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p><p>1）首先客户机与服务器需要建立连接。只要单击某个链接，HTTP的工作开始。</p><p>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</p><p>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p><p>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><p><strong> HTTP传输的这件事 Request + Eesponse  只有请求和响应都完成，才算HTTP事物完成 </strong></p><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>客户端不仅可以向服务器发送请求，还可以把内容传送给服务器  服务器端也会把一些内容返回给客户端</p><ul><li><p>请求报文: 客户端给服务器的内容</p></li><li><p>响应报文: 服务器给客户端的内容</p></li></ul><p>两者统称为HTTP报文</p><p>第一部分 起始行 第二部分 首部（头）第三部分 主体</p><p><img src="/img/http/message.png" alt="message"></p><p>对于请求报文 -》  请求起始行 请求头 请求主体</p><p>对于响应报文- 》  响应起始行 响应头 响应主体</p><p><img src="/img/http/message2.png" alt="message"></p><p>其实对于首部 来说，除了请求头和响应头 还有通用头 自定义请求头 自定义响应头</p><ul><li>以上这些信息在浏览器控制台 network 选项中查看到</li></ul><p><strong> 在自定义请求头时 一般不可以传入汉字 </strong> 如果非要传入汉字 需要进行编码 然后后台进行对应解码操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">'fromWho'</span>,<span class="string">'尝试传入汉字'</span>)</span><br></pre></td></tr></table></figure><p>请求报文是由客户端设置 由服务器端获取的  响应报文是由服务端设置 由客户器端获取的</p><h3 id="客户端把内容传递给服务器的方式"><a href="#客户端把内容传递给服务器的方式" class="headerlink" title="客户端把内容传递给服务器的方式"></a>客户端把内容传递给服务器的方式</h3><ul><li>问号传参</li></ul><p>使用请求报文 将内容写在请求头</p><p>使用请求报文 将内容写在请求主体</p><h3 id="服务器把内容传递给客户端的方式"><a href="#服务器把内容传递给客户端的方式" class="headerlink" title="服务器把内容传递给客户端的方式"></a>服务器把内容传递给客户端的方式</h3><p>使用响应报文 将内容写在响应头</p><p>使用响应报文 将内容写在响应主体</p><p>【不会使用起始行进行内容传递】</p><h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><h3 id="TCP-IP-协议"><a href="#TCP-IP-协议" class="headerlink" title="TCP/IP 协议"></a>TCP/IP 协议</h3><p>简单的把一次通信的过程分为三个阶段：客户端发出，线路中传输，服务端响应。互联网中的设备要完成通信必须基于双方都能识别的规则，如通信的语音，格式，硬件和操作系统等等，这些规则的集合统称为TCP/IP 协议族。</p><h3 id="http-报文"><a href="#http-报文" class="headerlink" title="http 报文"></a>http 报文</h3><p>用于HTTP协议交互的信息被称为HTTP报文</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>1 <a href="http://www.jianshu.com/p/99dc1f8f62bf" target="_blank" rel="noopener">熟悉的陌生人-HTTP</a></p><p>2 <a href="http://www.jianshu.com/p/7275aa3e4a13" target="_blank" rel="noopener">HTTP协议详解</a></p>]]></content>
      
      
      <categories>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>缓存</title>
      <link href="/2017/11/01/%E7%BC%93%E5%AD%98/"/>
      <url>/2017/11/01/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>现在的大型网站，随便一个页面都是一两百个请求，每天 pv 都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。  缓存和重用以前获取的资源的是优化网页性能很重要的一个方面。</p><a id="more"></a><h2 id="缓存的优缺点"><a href="#缓存的优缺点" class="headerlink" title="缓存的优缺点"></a>缓存的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>减少网络延迟，加快页面打开速度</li></ul><p>缓存比源服务器离客户端更近，因此，从缓存请求内容比从源服务器所用时间更少，缓存的使用能够明显加快页面打开速度，达到更好的体验。</p><ul><li>降低服务器的压力</li></ul><p>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。</p><ul><li>减少网络带宽损耗</li></ul><p>无论对于网站运营者或者用户，带宽都代表着金钱,当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>缓存没有清理机制</li></ul><p>这些缓存的文件会永久性地保存在机器上，在特定的时间内，这些文件可能是帮了你大忙，但是时间一长，我们已经不再需要浏览之前的这些网页，这些文件就成了无效或者无用的文件，它们存储在用户硬盘中只会占用空间而没有任何用处，如果要缓存的东西非常多，那就会撑暴整个硬盘空间。</p><ul><li>给开发带来的困扰</li></ul><p>明明修改了样式文件、图片、视频或脚本，刷新页面或部署到站点之后看不到修改之后的效果。</p><p>所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。</p><h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><p>Web应用领域，Web缓存大致可以分为以下几种类型：</p><h3 id="数据库数据缓存"><a href="#数据库数据缓存" class="headerlink" title="数据库数据缓存"></a>数据库数据缓存</h3><p>  Web应用，特别是社交网络服务类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached,redis等。  </p><h3 id="服务器端缓存"><a href="#服务器端缓存" class="headerlink" title="服务器端缓存"></a>服务器端缓存</h3><h4 id="代理服务器缓存"><a href="#代理服务器缓存" class="headerlink" title="代理服务器缓存"></a>代理服务器缓存</h4><p> 代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid,Nginx,Apache等。</p><p> <img src="/img/cache/agentServer.png" alt="agent Server"></p><h4 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h4><p>CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p><h3 id="浏览器端缓存"><a href="#浏览器端缓存" class="headerlink" title="浏览器端缓存"></a>浏览器端缓存</h3><p>浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。</p><h3 id="Web应用层缓存"><a href="#Web应用层缓存" class="headerlink" title="Web应用层缓存"></a>Web应用层缓存</h3><p>应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率</p><p>例如 本地存储和离线存储</p><h2 id="什么是浏览器缓存"><a href="#什么是浏览器缓存" class="headerlink" title="什么是浏览器缓存"></a>什么是浏览器缓存</h2><blockquote><p> Web缓存存在于服务器和客户端之间。Web缓存密切注视着服务器-客户端之间的通信，监控请求，并且把请求输出的内容（例如html页面、 图片和文件）另存一份；然后，如果下一个请求是相同的URL，则直接使用保存的副本，而不是再次请求源服务器。</p></blockquote><p>http缓存是<strong> 基于HTTP协议 </strong> 的浏览器文件级缓存机制。即针对文件的 <strong> 重复请求情况 </strong> 下，浏览器可以根据 <strong> 协议头 </strong> 判断从服务器端请求文件还是从本地读取文件</p><p>HTTP协议基于请求响应模式，客户端向服务器发送一个请求，请求头包含请求的方法，URI，协议版本以及包含请求修饰符，<br>客户端信息和内容的类似 MIME的消息结果。 服务器则以一个状态行为作为响应，相应的内容包括消息协议的版本，成功或错误编码加上包含服务器信息，实体元信息以及可能的实体内容。</p><p>当浏览器第一次请求某个URL时，顺利访问的话，服务器返回状态200的状态, 同时会返回给浏览器一些Headers集合，例如set-cookie,Last-Mondified,Etag等等</p><h2 id="关于处理缓存的信息头关键字"><a href="#关于处理缓存的信息头关键字" class="headerlink" title="关于处理缓存的信息头关键字"></a>关于处理缓存的信息头关键字</h2><p>HTTP协议中关于缓存的信息头关键字包括Cache-Control(HTTP1.1)，Pragma(HTTP1.0)，last-Modified，Expires等。</p><h3 id="缓存控制头-Cache-Control"><a href="#缓存控制头-Cache-Control" class="headerlink" title="缓存控制头 Cache-Control"></a>缓存控制头 Cache-Control</h3><p>Cache-Control 是最重要的规则。这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。这些指令指定用于阻止缓存对请求或响应造成不利干扰的行为。这些指令 通常覆盖默认缓存算法。缓存指令是单向的，即请求中存在一个指令并不意味着响应中将存在同一个指令。</p><p>cache-control 定义是：Cache-Control = “Cache-Control” “:” cache-directive</p><p>cache-directive 的取值请参加本文 – 名词解析 – 部分</p><h3 id="过期头-Expires"><a href="#过期头-Expires" class="headerlink" title="过期头 (Expires)"></a>过期头 (Expires)</h3><p>指定资源在浏览器缓存中的过期时间 (需要在服务端设定)</p><p>如果给文件加上关于过期时间(Expires)的header报文,这样浏览器就会先检查缓存中的文件，如果没有过期，就直接使用缓存中的文件,从而不会发送http请求</p><h3 id="控制文件是否有修改-Last-Modified-E-Tag"><a href="#控制文件是否有修改-Last-Modified-E-Tag" class="headerlink" title="控制文件是否有修改 Last-Modified/E-Tag"></a>控制文件是否有修改 Last-Modified/E-Tag</h3><p>Last-Modified: 资源更新时间  Etag: 资源的状态唯一标识 一般选择哈希值</p><p>Last-Modified PK  Etag</p><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？</p><p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li><p>(1) Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</p></li><li><p>(2)如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</p></li><li><p>(3)有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p></li></ul><p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。</p><p>Last-Modified与ETag是可以一起使用的，<strong> 服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，</strong> 最后才决定是否返回304。</p><h3 id="浏览器缓存流程图"><a href="#浏览器缓存流程图" class="headerlink" title="浏览器缓存流程图"></a>浏览器缓存流程图</h3><p>首次请求</p><p><img src="/img/cache/cache1.png" alt="cache"></p><p>第二次访问页面的缓存流程</p><p>1 判断expires，如果未过期，直接读取http缓存文件，不发http请求，否则进入下一步</p><p>2 判断是否含有etag，有则带上if-none-match发送请求，未修改返回304，修改返回200，否则进入下一步</p><p>3 判断是否含有last-modified，有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器请求</p><p><img src="/img/cache/cache2.png" alt="cache"></p><p>如果通过etag和last-modified判断，即使返回304有至少有一次http请求，只不过返回的是304的返回内容，而不是文件内容。所以合理设计实现expires参数可以减少较多的浏览器请求</p><h2 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h2><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</p><p>当该字段值为no-cache的时候，会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行</p><p>在 http1.0 时代，给客户端设定缓存方式可通过两个字段Pragma和Expires来规范。虽然这两个字段早可抛弃，但http协议做了向下兼容，所以依然可以看到</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>响应报文中Expires其定义的是资源“失效时刻”</p><p>这里的缓存时间是相对服务器上的时间而言的, 如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间</p><p>这三者的优先级从高到低分别是 Pragma -&gt; Cache-Control -&gt; Expires</p><p><strong> 作为请求首部时 </strong> 其可选属性为</p><p><img src="/img/cache/cache-control.png" alt="cache-control"></p><p>Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存。</p><p>实际上Cache-Control: no-cache是会被缓存的， 只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。</p><p>Cache-Control: no-store：这个才是响应不被缓存的意思。</p><p><strong> 作为响应首部时 </strong> 其可选属性</p><p><img src="/img/cache/cacheControl.png" alt="cache-control"></p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间</p><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><p>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。</p><p>web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），</p><p>HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</p><p>Last-Modified/If-Modified-Since要配合Cache-Control使用</p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>ETag 是HTTP1.1中才加入的一个属性，用来帮助服务器控制Web端的缓存验证。</p><p><img src="/img/cache/etag.png" alt="ETag"></p><p>它的原理是这样的，当浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值(3f80f-1b6-3e1cb03b)并通过 ETag 返回给浏览器，浏览器把”3f80f-1b6-3e1cb03b” 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: “3f80f-1b6-3e1cb03b” 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一个304未修改。</p><p>并未指定ETag是如何产生的 但是哈希是最好的选择方案</p><h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h3><p>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</p><p>Etag/If-None-Match也要配合Cache-Control使用</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>1 <a href="http://www.cnblogs.com/wangpenghui522/p/5498427.html" target="_blank" rel="noopener">浏览器缓存原理</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划3</title>
      <link href="/2017/11/01/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%923/"/>
      <url>/2017/11/01/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%923/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><ul><li>公益调查问卷</li></ul><p>第三稿修改了 甲方是爸爸 爸爸最大！！！ 希望不要有第四稿</p><ul><li>泰国父亲节 server部分</li></ul><h3 id="life"><a href="#life" class="headerlink" title="life"></a>life</h3><ul><li><p>人间草木 的读书笔记</p></li><li><p>webpack</p></li><li><p>暗时间</p></li></ul><p>涉及到思维的书 果然难读</p>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>video.js的API</title>
      <link href="/2017/11/01/video-js%E7%9A%84API/"/>
      <url>/2017/11/01/video-js%E7%9A%84API/</url>
      
        <content type="html"><![CDATA[<p>视频第三方插件库 video.js 的API文档并不清晰  查阅的时候比较麻烦  自己整理了一篇API</p><p><a href="http://videojs.com/" target="_blank" rel="noopener">官网</a></p><p><a href="https://www.npmjs.com/package/video.js" target="_blank" rel="noopener">npm</a></p><p><a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">Github</a></p><a id="more"></a><h3 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h3><ul><li>data-setup</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>*</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>videojs(id, optionsopt, readyopt)</p></li><li><p>ready</p></li><li><p>play</p></li><li><p>pause</p></li><li><p>on 事件监听</p></li><li><p>off</p></li><li><p>one</p></li><li><p>log 信息打印</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.on(<span class="string">'ended'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  videojs.log(<span class="string">'您的视频已经播放完毕'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>duration</p></li><li><p>currentTime</p></li></ul><p>获取视频播放进度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPlayer.currentTime()</span><br></pre></td></tr></table></figure><p>设置视频播放进度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myPlayer.currentTime(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><ul><li><p>width</p></li><li><p>height</p></li><li><p>size</p></li><li><p>enterFullScreen 全屏</p></li><li><p>exitFullScreen 退出全屏</p></li><li><p>removeEvent 事件移除</p></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><ul><li><p>ended 播放事件结束</p></li><li><p>fullscreenchange 全屏状态变动</p></li><li><p>play</p></li><li><p>pause</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 第三方插件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>有趣的css属性</title>
      <link href="/2017/10/26/%E6%9C%89%E8%B6%A3%E7%9A%84css%E5%B1%9E%E6%80%A7/"/>
      <url>/2017/10/26/%E6%9C%89%E8%B6%A3%E7%9A%84css%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="开启惯性滑动"><a href="#开启惯性滑动" class="headerlink" title="开启惯性滑动"></a>开启惯性滑动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-overflow-scrolling:touch</span><br></pre></td></tr></table></figure><p>但是这个可能会引起一些别的问题,参见文章<a href="https://www.cnblogs.com/xiahj/p/8036419.html" target="_blank" rel="noopener">webkit-overflow-scrolling</a></p><h3 id="图片变为黑白"><a href="#图片变为黑白" class="headerlink" title="图片变为黑白"></a>图片变为黑白</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span><span class="selector-class">.desaturate</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: <span class="built_in">grayscale</span>(100%);</span><br><span class="line">  <span class="attribute">-webkit-filter</span>: <span class="built_in">grayscale</span>(100%);</span><br><span class="line">  <span class="attribute">-moz-filter</span>: <span class="built_in">grayscale</span>(100%);</span><br><span class="line">  <span class="attribute">-ms-filter</span>: <span class="built_in">grayscale</span>(100%);</span><br><span class="line">  <span class="attribute">-o-filter</span>: <span class="built_in">grayscale</span>(100%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><p>主要应用的是 <a href="http://www.w3cplus.com/css3/ten-effects-with-css3-filter" target="_blank" rel="noopener">css3-filter</a></p><p>它可以对图片进行类似于ps的简单效果</p><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>可以设定图片实际宽度</p><h3 id="文本渐变"><a href="#文本渐变" class="headerlink" title="文本渐变"></a>文本渐变</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"element"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor sit … amet.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-mask-image</span>: <span class="selector-tag">-webkit-gradient</span>(<span class="selector-tag">linear</span>, <span class="selector-tag">left</span> <span class="selector-tag">top</span>, <span class="selector-tag">left</span> <span class="selector-tag">bottom</span>, <span class="selector-tag">from</span>(<span class="selector-tag">rgba</span>(0,0,0,0)), <span class="selector-tag">color-stop</span>(50%, <span class="selector-tag">rgba</span>(0,0,0,1)), <span class="selector-tag">to</span>(<span class="selector-tag">rgba</span>(0,0,0,0)));</span><br></pre></td></tr></table></figure><p>利用了CSS的遮罩进行处理</p><p>也可以使用一个特定的图片进行展示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-mask-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">mouse</span><span class="selector-class">.png</span>)</span><br></pre></td></tr></table></figure><h3 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 100<span class="selector-tag">px</span>)</span><br></pre></td></tr></table></figure><p>可以利用calc 实现css中的函数效果</p><h3 id="mask-–-css遮罩"><a href="#mask-–-css遮罩" class="headerlink" title="mask – css遮罩"></a>mask – css遮罩</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;__<span class="selector-tag">mask</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">mask-image</span>: <span class="built_in">url</span>(<span class="string">'../../img/product.png'</span>);</span><br><span class="line">  <span class="attribute">mask-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">mask-size</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/css/mask.png" alt="mask"><br><img src="/img/css/product.png" alt="mask"></p><p><a href="http://www.w3cplus.com/css3/css-masking.html" target="_blank" rel="noopener">css遮罩</a></p><h3 id="supports"><a href="#supports" class="headerlink" title="@supports"></a>@supports</h3><p>类似媒体查询 可以将@supports 视为 特性查询</p><p>用来查询浏览器是否支持某个CSS3的特性，这个功能除了IE之外，已被其他浏览器所支持</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">supports</span> ( display: flex ) &#123;</span><br><span class="line">    <span class="selector-class">.foo</span> &#123; <span class="attribute">display</span>: flex; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node基础</title>
      <link href="/2017/10/25/node%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/10/25/node%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><h4 id="事件发射"><a href="#事件发射" class="headerlink" title="事件发射"></a>事件发射</h4><p>on 与 emit</p><h4 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h4><p>emit 一次 相当于向方法池中添加一个函数 写一次加一次 即使是相同函数名 [ fn1 , fn2,fn1,fn4 ,fn1]</p><p>once 发射一次之后移除此事件</p><a id="more"></a><p>removeListen 在发射之前移除 是就近移除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeListen(emitName,fn)</span><br></pre></td></tr></table></figure><p>removeAllListen 移除所有监听</p><p>removeAllListen 有参数则移除参数事件</p><p>有最大监听数 10 但是可以自己设置 target.setMaxListeners()</p><p>listeners 获取当前函数池子中函数个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> girl = <span class="keyword">new</span>  Girl()</span><br><span class="line">girl.age=<span class="string">'20'</span></span><br><span class="line">girl.once(<span class="string">'smile'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i am smiling'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;)</span><br><span class="line">girl.setMaxListeners(<span class="number">5</span>)</span><br><span class="line">girl.emit(<span class="string">'smile'</span>)</span><br></pre></td></tr></table></figure><h3 id="流-stream"><a href="#流-stream" class="headerlink" title="流 stream"></a>流 stream</h3><h4 id="可读流-readStream"><a href="#可读流-readStream" class="headerlink" title="可读流  readStream"></a>可读流  readStream</h4><p>flag 打开文件要做什么</p><p>start end 前+后面 highWaterMark 最大字节数 默认64k</p><p>传送字节数</p><p>切换到流动模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'data'</span>)</span><br></pre></td></tr></table></figure><p>流的方式是异步的，不能用try catch 要用on(‘err’)</p><p>不写编码格式的， on.(‘data’) 中读取到 就是 buffer形式</p><p>如果设置之后，highwaterMark 一定要大于最小编码的字符长度</p><p>pause 暂停 resume 开始</p><p>结束</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; ... &#125;)</span><br></pre></td></tr></table></figure><h4 id="可写流-writeStream"><a href="#可写流-writeStream" class="headerlink" title="可写流 writeStream"></a>可写流 writeStream</h4><p>默认编码utf8 highWaterMark 最大字节数 默认16k</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.write(data)</span><br></pre></td></tr></table></figure><p>当数据写入核缓存区，该值为true 当数据存放到队列 ，该值为false</p><p>当流成功出刷新挂起的缓存区时调用drain</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws.on(<span class="string">'drain'</span>)</span><br><span class="line">ws.end(<span class="string">'当写入结束时候你要写入的东西'</span>)</span><br></pre></td></tr></table></figure><h4 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h4><p>相当于可读流和可写流的综合：暂停可读流直到可写流赶上再恢复可读流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(可读流).pipe(可写流);</span><br></pre></td></tr></table></figure><p>默认情况下，可读流在结束时会调用end方法  当然你可以设置不这么做</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'./2.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> ws = fs.createWriteStream(<span class="string">'./3.txt'</span>) <span class="comment">// 这个目标文件没有回自动创建的</span></span><br><span class="line"></span><br><span class="line">(rs).pipe(ws)</span><br><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'ending'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="node路径"><a href="#node路径" class="headerlink" title="node路径"></a>node路径</h2><p>__dirname 表示当前文件所在的目录的绝对路径</p><p>__filename 表示当前文件的绝对路径</p><p>module.filename ==== __filename 等价</p><p>process.cwd() 返回运行当前脚本的工作目录的路径</p><p>process.chdir() 改变工作目录</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>video 和 audio在移动端的表现</title>
      <link href="/2017/10/24/video%E5%92%8Caudio%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E8%A1%A8%E7%8E%B0/"/>
      <url>/2017/10/24/video%E5%92%8Caudio%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E8%A1%A8%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="video"><a href="#video" class="headerlink" title="video"></a>video</h2><p>video是HTML5提供的新标签 用于替代flash进行视频展示 然而video在移动端的表现情况却不如人意</p><a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">poster</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">source</span>&#125;?<span class="attr">vframe</span>/<span class="attr">jpg</span>/<span class="attr">offset</span>/<span class="attr">0</span>`&#125; <span class="attr">src</span>=<span class="string">&#123;source&#125;</span>  <span class="attr">controls</span>=<span class="string">"controls"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>或者是</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">poster</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">source</span>&#125;?<span class="attr">vframe</span>/<span class="attr">jpg</span>/<span class="attr">offset</span>/<span class="attr">0</span>`&#125; <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#123;source&#125;</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器支持情况</p><p><img src="/img/video/use.png" alt="use"></p><p>在PC端表现还是不错的</p><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><table><thead><tr><th>属性</th><th>属性值类型</th><th>含义</th></tr></thead><tbody><tr><td>autoplay</td><td>autoplay</td><td>设置为自动播放</td></tr><tr><td>controls</td><td>controls</td><td>展示视频播放的控制条</td></tr><tr><td>preload</td><td>preload</td><td>视频预加载 如果使用 “autoplay”，则忽略该属性</td></tr><tr><td>loop</td><td>loop</td><td>开启循环播放</td></tr><tr><td>src</td><td>string</td><td>视频源</td></tr><tr><td>muted</td><td>Boolean</td><td>静音</td></tr><tr><td>poster</td><td>string</td><td>视频封面</td></tr></tbody></table><h4 id="controls"><a href="#controls" class="headerlink" title="controls"></a>controls</h4><p>控制条包括：播放 暂停 定位 音量 全屏切换 字幕（如果可用）音轨（如果可用）</p><p>在iOS和Android中 控制条表现不同</p><p>以下是iOS中视频控制条的表现形式</p><p><img src="/img/video/ios.jpg" alt="ios"></p><p>以下是Android中视频控制条的表现形式</p><p><img src="/img/video/control.png" alt="control"></p><h4 id="autoplay"><a href="#autoplay" class="headerlink" title="autoplay"></a>autoplay</h4><p>此属性表示设置为默认播放 但实际上 这个效果在移动端体验非常不友好 并不能实现视频自动播放的功能</p><h3 id="移动端实际样式"><a href="#移动端实际样式" class="headerlink" title="移动端实际样式"></a>移动端实际样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#123;source&#125;</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>安卓手机呈现</p><p><img src="/img/video/video1.png" alt="video"></p><p>iOS 手机呈现</p><p><img src="/img/video/video2.jpg" alt="video"></p><p>可以看到 移动端视频展现没有一个合适的封面图 实际应该展示的是视频的第一帧作为默认封面图</p><p>然后我们添加一个 poster 属性 用于展现封面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">poster</span>=<span class="string">&#123;poster&#125;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#123;source&#125;</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/video/video3.png" alt="video"></p><p>就可以正确展示视频封面了</p><h4 id="关于获取视频封面"><a href="#关于获取视频封面" class="headerlink" title="关于获取视频封面"></a>关于获取视频封面</h4><p>项目中的视频是存储在七牛中的 七牛提供了一个图片地址 是截取视频第一帧</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> poster = <span class="string">`<span class="subst">$&#123;source&#125;</span>?vframe/jpg/offset/0`</span></span><br></pre></td></tr></table></figure><p>如果你无法拿到视频中的某一张图片 就需要另外处理了</p><ul><li>视频设置自动播放 则默认使用视频第一帧作为封面图</li></ul><p>如果视频有设置 autoplay 属性 则可以展现第一帧作为封面 但是移动端体验不好</p><ul><li>canvas截取视频封面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">`video`</span>)</span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">canvas.width = video.offsetWidth</span><br><span class="line">canvas.height = video.offsetHeight</span><br><span class="line">ctx.drawImage(video, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>)</span><br><span class="line">img.src = canvas.toDataURL(<span class="string">"image/png"</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img)</span><br></pre></td></tr></table></figure><p>这样是利用canvas截取视频 得到一个Img图片</p><p><strong> 视频跨域 则无法获取到图片 </strong></p><p>视频截取中 网页报错</p><p><img src="/img/video/crossDomain.png" alt="video"></p><p>canvas中的图像进行操作时有跨域限制（canvas安全机制）,如在某一个域名项目中的canvas中加载非本域中的图像，在进行toDataURL或getImageData进行操作时抛出异常</p><p>所以如果你的项目中视频源不涉及到跨域问题 可以直接使用这种方式</p><p>如果视频不同源 则直接将canvas元素展现出来 配合CSS充当封面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">`video`</span>)</span><br><span class="line"><span class="keyword">let</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">canvas.width = video.offsetWidth</span><br><span class="line">canvas.height = video.offsetHeight</span><br><span class="line">ctx.drawImage(video, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h4 id="全屏播放"><a href="#全屏播放" class="headerlink" title="全屏播放"></a>全屏播放</h4><p>iOS系统中 默认是全屏播放 当你点击视频 iOS会自动全屏</p><p>Android 系统就是在展现的位置播放 当点击全屏按钮才会显示全屏</p><ul><li>禁止iOS全屏播放</li></ul><p>如果不想在iOS展示全屏效果 那么可以添加属性 playsinline 来禁止iOS的默认全屏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;video ref=<span class="string">'videoEl'</span> src=&#123;source&#125; &#123;...videoProps&#125; playsinline /&gt;</span><br></pre></td></tr></table></figure><p>这样视频会在指定位置处播放 [和Android表现相同]</p><ul><li>Android 无法实现自动全屏 需要再处理</li></ul><p>如果有设置 control 属性 则可以通过点击控制条中的全屏按钮实现全屏播放</p><p>还可以通过一个虚假的蒙层实现 全屏播放 当点击按钮的是 传入视频源 然后强制蒙层中的video元素100% 播放</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>play</td><td>播放视频</td></tr><tr><td>pause</td><td>暂停视频</td></tr></tbody></table><h4 id="play"><a href="#play" class="headerlink" title="play"></a>play</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="comment">// 尝试播放视频</span></span><br><span class="line">  <span class="keyword">let</span> target = findDOMNode(<span class="keyword">this</span>.refs.videoEl)</span><br><span class="line">  target.play()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而 并没有什么用  PC端一切正常 但是在移动端是无法实现的</p><p>移动端的视频播放 必须通过用户执行点击动作 否则是无法实现播放的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>)</span><br><span class="line">  video.play()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>项目开始的时候提出一个需求 类似于微博客户端效果 当视频滑动到用户可视区 即可自动播放此视频 当此视频滑离可视区 则视频停止播放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 自动播放过一次之后 就禁止第二次自动播放了</span></span><br><span class="line">  <span class="keyword">let</span> &#123;played&#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">if</span> (played) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">  <span class="comment">// 滑动距离 + 屏幕距离  &gt; 盒子距离顶部 + 200</span></span><br><span class="line">  <span class="keyword">if</span> (scrollTop + screenH &gt; boxTop + <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.videoEl.play()</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">played</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到在PC端 可以实现这种效果  然而 由于移动端 <strong> 必须通过用户点击屏幕的动作来触发播放事件 </strong>  所以无法实现这个效果  </p><p>添加一个事件: 视频滑入可视区的时候 监听用户的 touch 事件 用户触发视频的播放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;played&#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">if</span> (played) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br><span class="line">  <span class="keyword">if</span> (scrollTop + screenH &gt; boxTop + <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.refs.videoEl.play()</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">played</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>功能上是可以实现的 但是这种方式非常不友好 体验的时候就能感觉到 当用户把视频滑动到可视区域 并不一定发生touch事件</p><h2 id="audio"><a href="#audio" class="headerlink" title="audio"></a>audio</h2><p>audio 是HTML5提供的新标签 用于进行音频文件的播放</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> audioProps = &#123;</span><br><span class="line"> src: <span class="string">'../music.mp3'</span>,</span><br><span class="line"> loop: <span class="string">'loop'</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;audio &#123;...audioProps&#125; /&gt;</span><br></pre></td></tr></table></figure><h3 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h3><table><thead><tr><th>属性</th><th>属性值类型</th><th>含义</th></tr></thead><tbody><tr><td>autoplay</td><td>autoplay</td><td>设置为自动播放</td></tr><tr><td>controls</td><td>controls</td><td>展示音频播放的控制条</td></tr><tr><td>preload</td><td>preload</td><td>音频预加载 如果使用 “autoplay”，则忽略该属性</td></tr><tr><td>loop</td><td>loop</td><td>开启循环播放</td></tr><tr><td>src</td><td>string</td><td>音频源</td></tr></tbody></table><h4 id="autoplay-自动播放"><a href="#autoplay-自动播放" class="headerlink" title="autoplay 自动播放"></a>autoplay 自动播放</h4><p>音频文件在ios系统中无法实现自动播放的这个效果</p><blockquote><p>User Control of Downloads Over Cellular Networks<br>In Safari on iOS (for all devices, including iPad), where the user may be on a cellular network and be charged per data unit, preload and autoplay are disabled. No data is loaded until the user initiates it. This means the JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action. In other words, a user-initiated Play button works, but an onLoad=”play()” event does not.</p></blockquote><p>简而言之 ios认为自动播放音频视频是不友好的行为 不想用户浪费过多的流量，禁止了自动播放的功能</p><p>所以即使你在标签中添加了 autoplay属性 在移动端也不会触发视频或者音频的播放</p><ul><li>解决方案1</li></ul><p>如果就是想要用户开启播放 可以为页面绑定一个 touchstart 点击事件  这样在页面点击的时候 触发此音频播放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> audio = <span class="built_in">document</span>.getElementById(<span class="string">'audio'</span>)</span><br><span class="line">  audio.play()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>解决方案2</li></ul><p>虽然在浏览器中有此限制 但是在微信中却可以做到自动播放</p><p>Android 中可以使用 [ios 无效]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> audio = <span class="built_in">document</span>.getElementById(<span class="string">'audio'</span>)</span><br><span class="line">  audio.play()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>iOS 可以使用 [Android 也可以]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"WeixinJSBridgeReady"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> audio = <span class="built_in">document</span>.getElementById(<span class="string">'audio'</span>)</span><br><span class="line">  audio.play()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h4 id="src"><a href="#src" class="headerlink" title="src"></a>src</h4><p>测试的时候使用了一首来自5sing的歌曲链接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> src = <span class="string">'http://data.5sing.kgimg.com/G106/M00/0A/0F/SpQEAFljNBqATRL-ADks3ezSCI8032.m4a'</span></span><br></pre></td></tr></table></figure><p>然后发现无法播放  是由于audio不支持此格式的音频文件</p><p>audio只支持三种格式的音频文件</p><p><img src="/img/video/mime.png" alt="video"></p><p>其实并非所有的浏览器都支持video与audio的所有的编码解码器 这就代表着有时候需要提供多个格式的资源  </p><p>ja提供了一个 canPlayType 方法 来判断是否支持当前播放资源</p><ul><li>canPlayType</li></ul><p>参数为 某一种格式 或者 编解码器</p><p>返回值 ‘maybe’ ‘’ ‘probably’ 三种结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> audio = <span class="built_in">document</span>.querySelector(<span class="string">'audio'</span>)</span><br><span class="line"><span class="comment">// let canPlay = audio.canPlayType('audio/mpeg')</span></span><br><span class="line"><span class="keyword">let</span> canPlay = audio.canPlayType(<span class="string">'audio/m4a'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(canPlay)</span><br></pre></td></tr></table></figure><h4 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h4><p>其实还可以通过new 来创建一个 audio 实例  就类似于 Image 来创建 img 一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> src = <span class="string">'https://os4ty6tab.qnssl.com/web/static/AllProjects/music-0c0d070d.mp3'</span></span><br><span class="line"><span class="keyword">this</span>.audio = <span class="keyword">new</span> Audio(src)</span><br><span class="line"><span class="keyword">this</span>.audio.setAttribute(<span class="string">'loop'</span>, <span class="string">'loop'</span>)</span><br></pre></td></tr></table></figure><p>这样就不必在页面中插入一个audio元素了</p><h2 id="第三方视频插件"><a href="#第三方视频插件" class="headerlink" title="第三方视频插件"></a>第三方视频插件</h2><p>其实原生的video标签有的时候无法满足UI需求 比如一般需要另行处理播放或者全屏按钮</p><p><img src="/img/video/video4.png" alt="video"></p><p>可以看到页面元素中 下面控制条部分并没有被解析为标签元素展示 整个视频源和控制条都在一个video元素中展示 所以无法处理这些按钮 比如调整位置或者样式</p><h4 id="video-js"><a href="#video-js" class="headerlink" title="video.js"></a>video.js</h4><blockquote><p>Video.js 是一个通用的在网页上嵌入视频播放器的 JS 库，Video.js 自动检测浏览器对 HTML5 的支持情况，如果不支持 HTML5 则自动使用 Flash 播放器</p></blockquote><p><a href="http://videojs.com/" target="_blank" rel="noopener">官网</a></p><p><a href="https://www.npmjs.com/package/video.js" target="_blank" rel="noopener">npm</a></p><p><a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">Github</a></p><ul><li>使用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">videojs(videoID, &#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.play()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传入的参数是  </p><table><thead><tr><th>属性</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>videoID</td><td>string</td><td>video标签元素的id</td></tr><tr><td>option</td><td>{}</td><td>标签参数</td></tr><tr><td>cb</td><td>function</td><td>回调函数  其中的this表示为当前播放源</td></tr></tbody></table><p>去看了源码 有这么一段</p><p><img src="/img/video/code.png" alt="video"></p><p>简化版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">videojs</span>(<span class="params">id, options, ready</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> string) &#123;</span><br><span class="line">    tag = $(<span class="string">`#<span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tag = id</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以第一个参数那里 不只是可以传递 id  也可以直接传递 DOM节点 比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">videojs(<span class="built_in">document</span>.querySelector(<span class="string">'video'</span>), &#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.play()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看页面元素 可以看到 每一个部分都被解析为元素节点了</p><p><img src="/img/video/video5.png" alt="video"> 这样就可以调整按钮样式了</p><p>** video.js 提供了在React中的使用方式  </p><p><a href="http://docs.videojs.com/tutorial-react.html" target="_blank" rel="noopener">react-video</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> videojs <span class="keyword">from</span> <span class="string">'video.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPlayer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">let</span> option = &#123;</span><br><span class="line">      autoplay: <span class="literal">true</span>,</span><br><span class="line">      controls: <span class="literal">true</span>,</span><br><span class="line">      poster: <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.props.video&#125;</span>?vframe/jpg/offset/0`</span>,</span><br><span class="line">      sources: [&#123;</span><br><span class="line">        src: <span class="keyword">this</span>.props.video,</span><br><span class="line">        type: <span class="string">'video/mp4'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.player = videojs(<span class="keyword">this</span>.videoNode, option, <span class="function"><span class="keyword">function</span> <span class="title">onPlayerReady</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'onPlayerReady'</span>, <span class="keyword">this</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.player) &#123;</span><br><span class="line">      <span class="keyword">this</span>.player.dispose()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div data-vjs-player&gt;</span><br><span class="line">        &lt;video ref=&#123; node =&gt; <span class="keyword">this</span>.videoNode = node &#125; className=<span class="string">"video-js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>有一些坑请看程总文章 <a href="https://github.com/GodEngine/videojs_hls" target="_blank" rel="noopener">video.js文档笔记(videojs)</a></p>]]></content>
      
      
      <categories>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> video </tag>
            
            <tag> audio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis-数据类型及其使用</title>
      <link href="/2017/10/12/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/10/12/redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>redis 是目前流行数据库的一种</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>String、 Hash、 List、 set、 sotred set</p><p>字符串类型  哈希  列表  集合 有序集合</p><a id="more"></a><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串类型是Redis中最基本的数据类型  它可以存储任何形式的字符串 包括二进制数据</p><p>可以存储用户的邮箱 JSON对象甚至图片 一个字符串键最大能存储512MB</p><p>字符串类型是其他4种数据类型的基础   差别从某些角度来说 只是组织字符串的形式不同</p><p>比如 列表类型List 是以列表形式组织字符串  而集合类型Set则是以集合形式</p><p>Redis字符串命令用于管理Redis中的字符串值</p><p>基本使用方式如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> liveRedis = reqs(<span class="string">'liveRedis'</span>)</span><br><span class="line"><span class="keyword">yield</span> liveRedis.COMMAND(KEY_NAME)</span><br></pre></td></tr></table></figure><h4 id="Redis-字符串命令"><a href="#Redis-字符串命令" class="headerlink" title="Redis 字符串命令"></a>Redis 字符串命令</h4><h5 id="设置-与-获取"><a href="#设置-与-获取" class="headerlink" title="设置 与 获取"></a>设置 与 获取</h5><p>set 设置值<br>setnx  key不存在则设置其值<br>get 获取值<br>getset 设置并且将旧值返回<br>mset 设置多个值<br>msetnx key不存在时设置多个值<br>mget 返回多个key值</p><p>1.1  set key value  设置指定key值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.set(name,<span class="string">'tom'</span>)</span><br></pre></td></tr></table></figure><p>2.2 setnx key不存在时设置其值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.setnx(name,<span class="string">'tom'</span>)</span><br></pre></td></tr></table></figure><p>将 key 的值设为 value ，当且仅当 key 不存在。</p><p>若给定的 key 已经存在，则 不做任何动作。</p><p>setnx -&gt; 『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>1.3 get key  获取指定key值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.get(name)</span><br></pre></td></tr></table></figure><p>当键不存在时候 返回null   如果key 储存的值不是字符串类型，返回一个错误</p><p>1.4 getset 设置值并返回旧值</p><p>如果key不存在 返回null</p><p>1.5 mset 设置多个值</p><p>用于同时设置一个或多个 key-value 对</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSET key1 value1 key2 value2 .. keyN valueN</span><br></pre></td></tr></table></figure><p>1.6 msetnx 当key值不存在时 设置其值</p><p>用于所有给定 key 都不存在时，同时设置一个或多个 key-value 对</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MSETNX key1 value1 key2 value2 .. keyN valueN</span><br></pre></td></tr></table></figure><p>所有 key 都成功设置，返回 1 。 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0</p><p>1.7 mget key1 key2 ..获取所有指定建的值</p><p>对于不包含字符串值或不存在的每个键，返回特殊值 - nil</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.mget(name , age ,habit ,valentines)</span><br></pre></td></tr></table></figure><p>返回值为一个包含所有给定 key 的值的列表</p><p>2 设置值以及有效期</p><p>setex 设置key值 并以秒为单位指定过期时间<br>psetex 设置key值 并以毫秒为单位指定过期时间</p><p>2.1 setex</p><p>在Redis键中的指定超时，设置键的字符串值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX KEY_NAME TIMEOUT KEY_VALUE</span><br></pre></td></tr></table></figure><p>为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值</p><p>设置成功 返回值为OK  否则返回错误</p><p>注意 此命令以秒为单位设定过期时间</p><p>2.2 psetex</p><p>该命令类型与setex类似，但是使用毫秒指定过期时间</p><h3 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 hash"></a>哈希 hash</h3><p>Redis以键值对的形式存储数据   而数据结构之一的哈希类型也是键值对形式存储数据</p><p>Hash类型适合存储对象 使用对象类别和ID构成键名 使用字段表示对象属性 而字段值则存储属性值</p><p>Hash存储了字段和字段值的映射 但是字段值只能是字符串 不支持其他数据类型</p><p>Redis 中每个 hash 可以存储 232 - 1 键值对</p><p>let liveRedis = reqs(‘liveRedis’)</p><h4 id="Redis-hash命令"><a href="#Redis-hash命令" class="headerlink" title="Redis hash命令"></a>Redis hash命令</h4><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p>1.1 HSET  哈希表中指定字段的进行赋值</p><p>HSET key filed value</p><p>设置一个用户信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hset <span class="keyword">let</span> startT = <span class="keyword">yield</span> liveRedis.hset(<span class="string">'user'</span>, <span class="string">'name'</span>,<span class="string">'tom'</span>)</span><br></pre></td></tr></table></figure><p>hset的命令不区分插入和更新操作  这意味着修改数据不用事先判断字段是否存在来决定要执行的是插入还是更新操作</p><p>如果执行的是插入[之前该字段并不存在] 则返回的是1  如果执行的是更新[之前该字段存在] 则返回的是0</p><p>如果该键不存在 则会自动创建此键</p><p>1.2 HSETEX  字段不存在则设置其值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key filed value</span><br></pre></td></tr></table></figure><p>与HSET命令一样，HSETEX同样会设置哈希表key的field字段值为value。但仅当field不存在才会设置。如果field字段已经存在，该操作无效</p><p>1.3  HGET  获取存储在哈希表中指定字段的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key filed</span><br></pre></td></tr></table></figure><p>返回哈希表key中field的值</p><p>获取到car字段的price属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startT = <span class="keyword">yield</span> liveRedis.hget(<span class="string">'car'</span>, <span class="string">'price'</span>)</span><br></pre></td></tr></table></figure><p>1.4 HGETALL</p><p>HGETALL key</p><p>获取存储在哈希表key中全部字段以及其值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> info = <span class="keyword">yield</span> liveRedis.hgetall(<span class="string">'car'</span>)</span><br></pre></td></tr></table></figure><p>一般在想要获取全部字段 又不知道有哪些字段时候使用</p><p>这个其实返回的不是很直观 不过在node中 可以将其处理为合适的对象格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.hgetall(<span class="string">'car'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,car</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 已经将其封装为一个对象了</span></span><br><span class="line">  <span class="built_in">console</span>.log(car.price)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2 批量操作</p><p>2.1 HMSET  批量设置多个字段以及值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></table></figure><p>将一个或多个field-value对设置到哈希表key。</p><p>如果要设置的field已存在，则会覆盖其值。如果哈希表不存在，首先会创建再执行HMSET操作。</p><p>2.2 HMGET  获取存储在哈希表中多个字段的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure><p>返回哈希表key中，一个或多个指定的定段。如果指定的字段在哈希表中不存在，则返回一个nil</p><p>比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> info = <span class="keyword">yield</span> liveRedis.hmget(<span class="string">'car'</span>, <span class="string">'price'</span>, <span class="string">'time'</span>, <span class="string">'user'</span>)</span><br></pre></td></tr></table></figure><p>hlen 获取哈希表中字段的数量</p><p>HLEN KEY_NAME</p><p>哈希表中字段的数量。 当 key 不存在时，返回 0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> len = <span class="keyword">yield</span> liveRedis.hlen(<span class="string">'car'</span>)</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis的列表类型List是有序的字符串列表。</p><p>LIST 内部使用双向链表实现  可以在其头部(左边)和尾部(右边)添加新的元素  而获取数据越位于链表两端的时候 速度就越快</p><p>操作列表元素时，如果是从链表的两头插入或删除元素，操作效率会非常高。即使列表中已存储了百万条数据，该操作也可以在常量短的时间内完成</p><p>比如在千万个数据的表中获取前后20个的速度与从具有100个的表中获取前后20个速度一样</p><p>不过使用链表的代价是通过索引访问元素比较慢</p><p>比如 将元素插入列表中间或是删除位于链表中间元素，那操作效率会非常的低</p><h4 id="Redis-List命令"><a href="#Redis-List命令" class="headerlink" title="Redis List命令"></a>Redis List命令</h4><h5 id="插入新元素"><a href="#插入新元素" class="headerlink" title="插入新元素"></a>插入新元素</h5><p>1.1 LPUSH 向开始位置插入元素 LPUSH</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpush key value [value...]</span><br></pre></td></tr></table></figure><p>将一个或多个值value插入到列表key的开始位置</p><p>如果有多个value，那么从左到右依次插入列表</p><p>如果列表key不存在，首先会创建一个空列表再执行LPUSH操作</p><p>命令执行成功后，返回列表的长度</p><p>如果key存在，但不是List类型，会返回一个错误提示</p><p>1.2  如果列表存在则将元素插入表头 lpushx</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpushx key value</span><br></pre></td></tr></table></figure><p>将一个或者多个value插入列表头部位置</p><p>如果列表key存在且是List类型，则将值value插入到列表key的头部</p><p>如果列表key不存在，则无操作</p><p>1.3 将指定元素插入列表末尾 RPUSH</p><p>此命令同lpush类似 只不过是插入元素的位置不同</p><p>1.4  如果列表存在则将元素插入表尾 RPUSHX</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpushx key value</span><br></pre></td></tr></table></figure><h5 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h5><p>2.1 LPOP</p><p>左侧弹出一个数值</p><p>2.2 RPOP</p><p>右侧弹出一个数值</p><p>2.3 获取列表元素个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN numbers</span><br></pre></td></tr></table></figure><p>当键不存在 则返回0</p><p>2.4 获取列表片段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start end</span><br></pre></td></tr></table></figure><p>它用来获取列表中某一片段 将返回此片段内所以的元素（包含两端的元素）</p><p>Redis列表的起始索引为0</p><p>lrange 命令支持索引为负数 表示从右侧开始读取元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange user <span class="number">-2</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>截取右侧第二个 到右侧第一个</p><p>所以获取列表中所有的值 使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lrange user <span class="number">0</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>然后注意start 与 stop的大小处理</p><p>如果start &gt; stop 则返回空列表</p><p>如果 stop 大于实际的索引 则只是返回所有的元素</p><p>2.5  通过索引获取列表中指定位置的元素 lindex</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lindex key index</span><br></pre></td></tr></table></figure><h5 id="删除列表中值"><a href="#删除列表中值" class="headerlink" title="删除列表中值"></a>删除列表中值</h5><p>3.1 LREM</p><p>LREM key count val</p><p>删除列表中val的值 删除个数为count</p><p>返回删除的元素个数</p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>Redis中的集合(Set)类型类似于List类型</p><p>Set是无序列的   集合成员是唯一的，这就意味着集合中不能出现重复的数据。如果多次添加相同元素，Set中将仅保留该元素的一份拷贝</p><p>和List类型一样，我们可以对集合类型进行元素的添加、删除或判断元素是否存在等操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> liveRedis = reqs(<span class="string">'liveRedis'</span>)</span><br></pre></td></tr></table></figure><h4 id="Redis-集合命令"><a href="#Redis-集合命令" class="headerlink" title="Redis 集合命令"></a>Redis 集合命令</h4><h5 id="1-添加元素-成员之间的操作"><a href="#1-添加元素-成员之间的操作" class="headerlink" title="1 添加元素 成员之间的操作"></a>1 添加元素 成员之间的操作</h5><p>sadd 添加元素<br>srem 移除元素</p><p>1.1  sadd 往集合中添加元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member [member ...]</span><br></pre></td></tr></table></figure><p>将一个或多个元素member添加到集合key中，如果要添加的元素在集合中已存在，那么该元素将被忽略</p><p>如果集合key不存在，那么包含元素member的集合会被创建</p><p>返回值 是被添加到集合中的新元素的数量，不包括被忽略的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> liveRedis.sadd(<span class="string">"cars"</span> ,<span class="string">"tout"</span>)</span><br></pre></td></tr></table></figure><p>1.2  移除元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><p>返回值：被移除的元素数量；如果key不是集合类型，会返回一个错误</p><p>2 查询元素</p><p>scard 集合元素数<br>smembers 返回集合成员<br>sismember  判断元素是不是集合的成员</p><p>2.1 获取集合中元素数量  scard</p><p>scard key<br>返回值 是集合的数量。 当集合 key 不存在时，返回 0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> liveRedis.scard(<span class="string">"cars"</span> )</span><br></pre></td></tr></table></figure><p>2.2  SMEMBERS - 返回集合中成员</p><p>smembers key<br>Redis Smembers 命令返回集合中的所有的成员。 不存在的集合 key 被视为空集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.sadd(<span class="string">'followers'</span>,<span class="string">'tom'</span>,<span class="string">'jury'</span>,<span class="string">'hell'</span>)</span><br><span class="line"><span class="keyword">let</span> users = <span class="keyword">yield</span> liveRedis.smembers(<span class="string">'followers'</span>)</span><br><span class="line"><span class="comment">// tom jury hell</span></span><br></pre></td></tr></table></figure><p>2.3  SISMEMBER - 判断元素是否是集合的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sismember key member</span><br></pre></td></tr></table></figure><p>如果member是集合成员，返回1 如果不是集合成员或集合不存在，返回0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.smembers(<span class="string">'followers'</span>)</span><br><span class="line"><span class="comment">// tom juar hui</span></span><br><span class="line"><span class="keyword">let</span> isM = liveRedis.sismember(<span class="string">'fallowers'</span>,<span class="string">'hui'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>项中使用案例 比如将某一天完成指定任务的用户存储在当天的key中 通过此命令可以判断当前用户是否已经完成了今日任务</p><p>3 集合之间的操作</p><p>sdiff 差集 A-B<br>sinter 交集<br>sunion  并集 A+B</p><p>3.1 一个或者多个集合的差集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br></pre></td></tr></table></figure><p>返回值为 差集的成员列表  也就是 A-B</p><p>比如当前有集合A与B A中元素为 1 2 3 B中元素为 2 3 4</p><p>计算A与B的差集</p><p>SDIFF A B</p><p>返回值为1</p><p>如果命令为</p><p>SDIFF B A</p><p>则返回值为 4</p><p>3.2 对多个集合进行交集运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure><p>返回值为交集的成员列表</p><p>3.3对多个集合进行并集运算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br></pre></td></tr></table></figure><h3 id="Redis-有序集合-sorted-set"><a href="#Redis-有序集合-sorted-set" class="headerlink" title="Redis 有序集合(sorted set)"></a>Redis 有序集合(sorted set)</h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis通过分数来为集合中的成员进行从小到大的排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复</p><p>sort set 和 LIST 类型在某些方面相似 两者都是有序的 两者艘可以获取某一范围的元素</p><p>但是两者的使用场景不同</p><p>1 LIST 更适合于实现‘新鲜事’或者‘新日志’  而不是获取中间元素信息</p><p>2 sort set 的内部机制使其即使访问中间位置元素 速度也快</p><p>3 LIST 不能简单的更改元素位置 但是SORT SET可以简单的变动score来更改位置</p><p>4 SORT SET 比LIST耗费内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> liveRedis = reqs(<span class="string">'liveRedis'</span>)</span><br></pre></td></tr></table></figure><h4 id="Redis-有序集合命令"><a href="#Redis-有序集合命令" class="headerlink" title="Redis 有序集合命令"></a>Redis 有序集合命令</h4><h5 id="添加-修改集合元素"><a href="#添加-修改集合元素" class="headerlink" title="添加 修改集合元素"></a>添加 修改集合元素</h5><p>1 zadd 添加元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN</span><br></pre></td></tr></table></figure><p>Redis Zadd 命令用于将一个或多个成员元素及其分数值加入到有序集当中。</p><p>如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。</p><p>分数值可以是整数值或双精度浮点数。</p><p>如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p><p>当 key 存在但不是有序集类型时，返回一个错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.zadd(<span class="string">'user_votes'</span>,<span class="number">23</span>,<span class="string">'tom'</span>,<span class="number">21</span>,<span class="string">'meary'</span>)</span><br></pre></td></tr></table></figure><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>2.1  zcard - 返回集合数量  zcard (key)</p><p>返回值：有序集合key的基数；当集合不存在时，返回0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">liveRedis.zadd(<span class="string">'user_votes'</span>,<span class="number">20</span>,<span class="string">'tom2'</span>)</span><br><span class="line"><span class="keyword">let</span> num1 = liveRedis.zcard(<span class="string">'user_votes'</span>) <span class="comment">// 1</span></span><br><span class="line">liveRedis.zadd(<span class="string">'user_votes'</span>,<span class="number">29</span>,<span class="string">'tom3'</span>)</span><br><span class="line"><span class="keyword">let</span> num1 = liveRedis.zcard(<span class="string">'user_votes'</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>2.2 zrank  返回元素排名</p><p>ZRANK key member</p><p>返回有序集合key中的元素member的排名。元素成员按score值递增，相同score值的成员按字典排序。元素排名从0开始计数</p><p>显示所有成员及其 score 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE keyname <span class="number">0</span> <span class="number">-1</span> WITHSCORES</span><br></pre></td></tr></table></figure><p>2.3 ZSCORE - 返回指元素的权重</p><p>ZSCORE key member<br>返回有序集合key中，元素member的score值</p><p>2.4 ZCOUNT - 返回集合两个权重间的元素数</p><p>ZCOUNT key min max<br>返回有序集合key，score值在min和max之间的元素数(包含值为min和max的元素)</p><p>2.5 ZRANGE - 返回指定区间内的元素</p><p>ZRANGE key start stop [WITHSCORES]<br>返回有序集合key指定区间内的元素。元素成员按score值递增，相同score值的成员按字典排序。</p><p>start和stop都是从0开始。当使用负数时，表示从集合的末尾开始计数</p><p>WITHSCORES用于指定是否同时返回元素的score</p><p>2.6 ZREVRANGE - 倒序返回指定区间内的元素</p><p>ZREVRANGE key start stop [WITHSCORES]<br>返回有序集合key中，指定区间内的成员。score值按倒序(从大到小)顺序排序</p><p>2.7 ZRANGEBYSCORE - 返回指定权重区间内的元素</p><p>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]<br>返回有序集合key指定区间内的元素。元素成员按score值递增，相同score值的成员按字典排序。</p><p>可选参数LIMIT用于指定返回元素数量，offset用于指定便移量</p><h5 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h5><p>3.1 ZREM - 移除元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><p>移除有序集合key中的一个或多个元素member的排名，不存在成员将被忽略。</p><p>移除全部元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE page_rank <span class="number">0</span> <span class="number">-1</span> WITHSCORES</span><br></pre></td></tr></table></figure><p>3.2 ZREMRANGEBYRANK - 移除指定区间内的元素</p><p>ZREMRANGEBYRANK key start stop<br>移除有序集合key中，指定排名(rank)区间内的元素。</p><p>start和stop用于指定元素区间，start和stop包含在区间内。start和stop的底数以0开始，也可以使用负数，如-1表示最后一个元素，依次类推</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>项目组推荐</title>
      <link href="/2017/10/10/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/"/>
      <url>/2017/10/10/%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="酷站推荐"><a href="#酷站推荐" class="headerlink" title="酷站推荐"></a>酷站推荐</h3><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><p><a href="http://loading.awesomes.cn/" target="_blank" rel="noopener">loading</a></p><p><a href="https://loading.io/" target="_blank" rel="noopener">loading.io</a></p><p><a href="https://kazzkiq.github.io/balloon.css/" target="_blank" rel="noopener">balloon</a></p><h4 id="vpn"><a href="#vpn" class="headerlink" title="vpn"></a>vpn</h4><p><a href="https://github.com/getlantern/forum" target="_blank" rel="noopener">lantern</a></p><h4 id="资源站点"><a href="#资源站点" class="headerlink" title="资源站点"></a>资源站点</h4><p><a href="http://www.css88.com/nav/" target="_blank" rel="noopener">all</a></p>]]></content>
      
      
      <categories>
          
          <category> 推荐阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划2</title>
      <link href="/2017/10/08/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%922/"/>
      <url>/2017/10/08/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%922/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><ul><li>调查问卷上线</li></ul><!-- more --><ul><li>留言墙上线</li></ul><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><ul><li><p>阅读笔记</p></li><li><p>山海经</p></li></ul><p>可以写小段子</p><h3 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h3><ul><li>英语单词</li></ul>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>call、apply、bind</title>
      <link href="/2017/10/07/call%E3%80%81apply%E3%80%81bind/"/>
      <url>/2017/10/07/call%E3%80%81apply%E3%80%81bind/</url>
      
        <content type="html"><![CDATA[<p>call apply bind 这三个方法都是Function 函数类上的方法</p><a id="more"></a><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><h3 id="call的作用："><a href="#call的作用：" class="headerlink" title="call的作用："></a>call的作用：</h3><p>改变obj1中this指向  并执行call前面的函数obj1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj1.call(obj2)</span><br></pre></td></tr></table></figure><h4 id="call-的应用"><a href="#call-的应用" class="headerlink" title="call 的应用"></a>call 的应用</h4><p>2.1  前面的函数中没有this 相当于只是执行前面的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'father'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'son'</span>)</span><br><span class="line">&#125;</span><br><span class="line">father.call(son); <span class="comment">// 控制台打印出father</span></span><br></pre></td></tr></table></figure><p>2.2  前面的函数有this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">son</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">father.call(son); <span class="comment">// 控制台打印出 function son()&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>2.3 多个call 连续使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'i am f1'</span>)&#125; ;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'i am f2'</span>)&#125; ;</span><br><span class="line">f1.call.call.call(f2)</span><br></pre></td></tr></table></figure><p>相当于执行f2 函数  所以输出 i am f2</p><p>f1.call 是走到函数的定义阶段</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>apply使用和call 相同,只不过是在传入参数的使用的是数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.apply(f2,[<span class="string">'tom'</span>,<span class="number">24</span>])</span><br></pre></td></tr></table></figure><h3 id="apply的应用"><a href="#apply的应用" class="headerlink" title="apply的应用"></a>apply的应用</h3><p>获取数组中最大值</p><p>2.1 sort 排序</p><p>2.2 假设法</p><p>2.3 利用apply 传参为数组这个特点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arys =[<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">61</span>,<span class="number">99</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>,arys)</span><br></pre></td></tr></table></figure><p>2.4 eval   将字符串转为JS代码执行</p><p>数组与字符串进行拼接 会连接为新的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">'Math.max('</span>+ arys +<span class="string">')'</span>)</span><br></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>bind 和call有点类似   改变this指向,传入参数，但是不执行函数。所以属于预处理机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.bind(f2,<span class="string">'tom'</span>,<span class="number">24</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
            <tag> call </tag>
            
            <tag> apply </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>swiper.js</title>
      <link href="/2017/10/07/swiper-js/"/>
      <url>/2017/10/07/swiper-js/</url>
      
        <content type="html"><![CDATA[<p>swiper 是一个很好的处理滑动的第三方插件</p><p><a href="https://github.com/nolimits4web/swiper/" target="_blank" rel="noopener">github地址</a></p><p><a href="http://www.swiper.com.cn/api/index.html" target="_blank" rel="noopener">API</a></p><a id="more"></a><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>fullScreen</td><td>是否支持全屏展示</td></tr><tr><td>animate</td><td>是否开启动画</td></tr><tr><td>speed</td><td>切换速度</td></tr><tr><td>loop</td><td>是否开启循环播放</td></tr><tr><td>direction</td><td>切换方向</td></tr><tr><td>autoplay</td><td>每一屏幕展示时间</td></tr><tr><td>autoplayDisableOnInteraction</td><td>是否继续保持用户行为</td></tr><tr><td>initialSlide</td><td>默认在开始的时候展示第几个实例</td></tr></tbody></table><ul><li>autoplayDisableOnInteraction</li></ul><p>关于这个属性 就是当你开启了手势滑动或者键盘切换的时候 如果不设置此属性值为 FALSE 那么当你手动滑动之后 自动切换功能将会停止 也就是只能通过 手动触发滑动事件了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoplayDisableOnInteraction: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>此属性值设置为FALSE 表示可以当用户行为结束之后 继续自动切换效果</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="onSliderMove"><a href="#onSliderMove" class="headerlink" title="onSliderMove"></a>onSliderMove</h4><p>在滑动屏幕的时候</p><p>注意这个事件在通过键盘滑动切换的时候 并不会触发</p><h4 id="onSlideChangeEnd-屏幕切换结束"><a href="#onSlideChangeEnd-屏幕切换结束" class="headerlink" title="onSlideChangeEnd 屏幕切换结束"></a>onSlideChangeEnd 屏幕切换结束</h4><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="slideTo"><a href="#slideTo" class="headerlink" title="slideTo"></a>slideTo</h4><p>指定跳转到某一页实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySwiper.slideTo(<span class="number">9</span>, <span class="number">75</span>, runCallbacks)</span><br></pre></td></tr></table></figure><h4 id="removeAllSlides"><a href="#removeAllSlides" class="headerlink" title="removeAllSlides"></a>removeAllSlides</h4><p>移除所有实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mySwiper.removeAllSlides(); <span class="comment">//移除全部</span></span><br></pre></td></tr></table></figure><p>此方法将所有的实例删除 可以查看DOM树信息 会发现所有切换实例被移除</p><h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><h4 id="DOM-元素解析"><a href="#DOM-元素解析" class="headerlink" title="DOM 元素解析"></a>DOM 元素解析</h4><p>查看页面元素发现 Swiper 将DOM树解析为包含 swiper-slide-prev swiper-slide-active swiper-slide-next 这三个比较重要的部分</p><p>包含 swiper-slide-active 类名的 表示处于激活状态的屏幕</p><h4 id="onSlideChangeStart-VS-onSlideChangeEnd"><a href="#onSlideChangeStart-VS-onSlideChangeEnd" class="headerlink" title="onSlideChangeStart VS  onSlideChangeEnd"></a>onSlideChangeStart VS  onSlideChangeEnd</h4><p>项目中一个swiper的切换banner之后获取新数据的需求 最开始的时候是把getData写到 onSlideChangeEnd 中</p><p>但是发现 如果快速滑动页面 swiper会丢失 onSlideChangeEnd 中注册的函数 不再执行</p><p>GIT中也有人反应这个bug</p><p><a href="https://github.com/nolimits4web/Swiper/issues/1403" target="_blank" rel="noopener">onSlideChangeEnd丢失</a></p><p>然后我把方法注入 onSlideChangeStart 中 发现可以正确得到结果 不会丢失</p><h3 id="v4-vs-v3"><a href="#v4-vs-v3" class="headerlink" title="v4 vs v3"></a>v4 vs v3</h3><p>v4 在一些安卓机和部分iOS中 无法使用，建议使用v3</p>]]></content>
      
      
      <categories>
          
          <category> 第三方插件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rn-下拉刷新</title>
      <link href="/2017/10/05/rn-%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
      <url>/2017/10/05/rn-%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>PullToRefreshListView 提供了页面下拉刷新 上滑获取更多数据的功能</p><p>[GitHub 地址] (<a href="https://github.com/react-native-component/react-native-smart-pull-to-refresh-listview/" target="_blank" rel="noopener">https://github.com/react-native-component/react-native-smart-pull-to-refresh-listview/</a>)</p><p>其实提供了Android和iOS两种系统的刷新</p><a id="more"></a><p>如果你的项目只服务其中一种系统 可以只引入其中一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AndroidPullToRefreshListView <span class="keyword">from</span> <span class="string">'./PullToRefreshListView-android'</span></span><br><span class="line"><span class="keyword">import</span> IOSPullToRefreshListView <span class="keyword">from</span> <span class="string">'./PullToRefreshListView-ios'</span></span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-native-smart-pull-to-refresh-listview --save</span><br></pre></td></tr></table></figure><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PullToRefreshListView</span></span></span><br><span class="line"><span class="tag"> <span class="attr">viewType</span>=<span class="string">&#123;viewType&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">enableEmptySections</span>=<span class="string">&#123;true&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">pagingEnabled</span>=<span class="string">&#123;false&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">contentContainerStyle</span>=<span class="string">&#123;styles.listView&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">dataSource</span>=<span class="string">&#123;state.dataSource&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">renderRow</span>=<span class="string">&#123;renderRow&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">renderHeader</span>=<span class="string">&#123;this._renderHeader&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">renderFooter</span>=<span class="string">&#123;this._renderFooter&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">onRefresh</span>=<span class="string">&#123;this._onRefresh&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">onLoadMore</span>=<span class="string">&#123;this._onLoadMore&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">autoLoadMore</span>=<span class="string">&#123;true&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">pullUpDistance</span>=<span class="string">&#123;1&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">pullUpStayDistance</span>=<span class="string">&#123;35&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">pullDownDistance</span>=<span class="string">&#123;pullOkMargin&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">pullDownStayDistance</span>=<span class="string">&#123;defaultTopIndicatorHeight&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">scrollRenderAheadDistance</span>=<span class="string">&#123;windowHeight&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">removeClippedSubviews</span>=<span class="string">&#123;true&#125;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">pageSize</span>=<span class="string">&#123;20&#125;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h4><p>1 viewType</p><p>2 dataSource</p><p>数据来源</p><p>3  renderRow</p><p>内置函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_renderRow = <span class="function">(<span class="params">rowData, sectionID, rowID</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">          &lt;View style=&#123;styles.thumbnail&#125;&gt;</span><br><span class="line">              &lt;View style=&#123;styles.textContainer&#125;&gt;</span><br><span class="line">                  &lt;Text&gt;&#123;rowData.text&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>View&gt;</span><br><span class="line">          &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>这个函数是组件封装好的 默认接受三个参数 第一个参数是渲染的数据</p><p>可以直接使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> renderRow = <span class="function">(<span class="params">rowData, _, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> shouldHidden ? <span class="literal">null</span> : <span class="xml"><span class="tag">&lt;<span class="name">ListRow</span> &#123;<span class="attr">...props</span>&#125; &#123;<span class="attr">...rowData</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>4 renderheader</p><p>下拉刷新时候展示的头部loading组件部分</p><p>这个是一个函数  返回值是一个组件  此组件将作为loading组件展示在头部</p><p>而关于下拉刷新的几个状态值  比如未下拉刷新 正在下拉  松手状态  刷新完毕状态 都可以获取到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_renderHeader = <span class="function">(<span class="params">viewState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;pullState, pullDistancePercent&#125; = viewState</span><br><span class="line">  <span class="keyword">let</span> &#123;refresh_none, refresh_idle, will_refresh, refreshing&#125; = PullToRefreshListView.constants.viewState</span><br><span class="line">  pullDistancePercent = <span class="built_in">Math</span>.round(pullDistancePercent * <span class="number">100</span>)</span><br><span class="line">  <span class="keyword">switch</span>(pullState) &#123;</span><br><span class="line">    <span class="keyword">case</span>  refresh_none :</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span> 请下拉用以刷新页面 <span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">    ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到几个状态值 全部保存在 PullToRefreshListView.constants.viewState 里面</p><p>5 renderFooter</p><p>同理 是在下拉获取更多的时候 在底部展示的组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_renderFooter = <span class="function">(<span class="params">viewState</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> &#123;pullState, pullDistancePercent&#125; = viewState</span><br><span class="line">   <span class="keyword">let</span> &#123;load_more_none, load_more_idle, will_load_more, loading_more, loaded_all, &#125; = PullToRefreshListView.constants.viewState</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则关于上拉的各种状态也是在PullToRefreshListView.constants.viewState中</p><p>6 autoLoadMore</p><p>是否开启上拉获取更多数据功能 默认值FALSE</p><p>7  关于处理下拉以及上滑的距离</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pullUpDistance=&#123;<span class="number">1</span>&#125;</span><br><span class="line">pullUpStayDistance=&#123;<span class="number">35</span>&#125;</span><br><span class="line">pullDownDistance=&#123;pullOkMargin&#125;</span><br><span class="line">pullDownStayDistance=&#123;defaultTopIndicatorHeight&#125;</span><br></pre></td></tr></table></figure><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>1 onRefresh</p><p>当下拉刷新的时候 触发此方法</p><p>2 onLoadMore</p><p>当上拉获取更多数据的时候 触发此方法</p><p>other</p><p>1 beginRefresh  相当于强制去执行一次下拉刷新</p><p>2 endRefresh 终止下拉刷新</p><p>3 endLoadMore 终止上拉获取更多数据</p><p>当开始执行下拉刷新 获取数据的过程  此时展示头部loading组件部分  当数据获取完毕 需要使用以上方法关闭loading状态</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">this</span>._pullToRefreshListView.endRefresh()</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"> <span class="keyword">this</span>._pullToRefreshListView.endLoadMore(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>如果不执行这个方法 加载状态会一直存在的</p>]]></content>
      
      
      <categories>
          
          <category> 第三方插件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rn-swiper</title>
      <link href="/2017/10/04/rn-swiper/"/>
      <url>/2017/10/04/rn-swiper/</url>
      
        <content type="html"><![CDATA[<p>RN 提供的react-native-swipe是一个swiper 滑动组件</p><p><a href="https://github.com/leecade/react-native-swiper" target="_blank" rel="noopener">GitHub地址</a></p><p><a href="https://preview.npmjs.com/package/react-native-swiper" target="_blank" rel="noopener">npm地址</a></p><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-native-swiper --save</span><br></pre></td></tr></table></figure><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line"> return (</span><br><span class="line">     <span class="tag">&lt;<span class="name">Swiper</span> <span class="attr">style</span>=<span class="string">&#123;styles.wrapper&#125;</span> <span class="attr">showsButtons</span>=<span class="string">&#123;true&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.slide1&#125;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.text&#125;</span>&gt;</span>Hello Swiper<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.slide2&#125;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.text&#125;</span>&gt;</span>Beautiful<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.slide3&#125;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.text&#125;</span>&gt;</span>And simple<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Swiper</span>&gt;</span></span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>index</td><td>默认展示的面板的索引</td></tr><tr><td>loop</td><td>开启循环滑动</td></tr><tr><td>horizontal</td><td>水平滑动  设置FALSE 则垂直滑动</td></tr><tr><td>autoplay</td><td>开启自动循环</td></tr><tr><td>showButtons</td><td>展示按钮</td></tr></tbody></table><p>其实是和一款js插件Swiper效果类似</p>]]></content>
      
      
      <categories>
          
          <category> 第三方插件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react-native1</title>
      <link href="/2017/10/04/react-native1/"/>
      <url>/2017/10/04/react-native1/</url>
      
        <content type="html"><![CDATA[<!-- description: RN的学习 --><p>本文搭建的是Mac环境的RN</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p><a href="http://reactnative.cn/docs/0.45/getting-started.html" target="_blank" rel="noopener">官网链接</a></p><p>安装所需模块按照官网中逐步安装即可</p><a id="more"></a><p>所有模块安装完毕 开始创建项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init HelloWorld</span><br></pre></td></tr></table></figure><p>这样就可以创建一个完成的RN项目</p><p>启动项目 在命令行中输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native run-ios</span><br></pre></td></tr></table></figure><p>即可启动此项目</p><h4 id="项目启动中bug"><a href="#项目启动中bug" class="headerlink" title="项目启动中bug"></a>项目启动中bug</h4><p>在尝试启动项目中 一直报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‘boost/iterator/iterator_adaptor.hpp’ file not found</span><br></pre></td></tr></table></figure><p>产生原因：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* <span class="regexp">/Users/</span>xxx/.rncache 中 boost_1_63_0.tar.gz， double-conversion<span class="number">-1.1</span><span class="number">.5</span>.tar.gz， folly<span class="number">-2016.09</span><span class="number">.26</span><span class="number">.00</span>.tar.gz， glog<span class="number">-0.3</span><span class="number">.4</span>.tar.gz 等文件下载不完整</span><br></pre></td></tr></table></figure><p><strong> 解决方案 </strong> 删除 .rncache 后重新下载，或手动下载后放入 .rncache 中</p><p>可能是由于网络问题或者无法翻墙 导致此文件下载不完整</p><p>然后一旦此文件存在 后面的发现有这个 就不再去安装它了 所以你会发现  即使你把所有项目删掉重新来 也依旧显示这个错误</p><h4 id="相关文章导读"><a href="#相关文章导读" class="headerlink" title="相关文章导读"></a>相关文章导读</h4><p>1 <a href="http://reactnative.cn/docs/0.45/getting-started.html" target="_blank" rel="noopener">《RN 开发错误警告处理》</a></p><p>2 <a href="https://github.com/vczero/react-native-lesson" target="_blank" rel="noopener">RN 课程自学</a></p><h3 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h3><p>RN 的元素渲染与React不同  前者就是使用的普通HTML标签 而RN则是新的一套语义化更加明白的标签</p><h4 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h4> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ActivityIndicator</span></span></span><br><span class="line"><span class="tag"><span class="attr">animating</span>=<span class="string">&#123;this.state.animating&#125;</span></span></span><br><span class="line"><span class="tag"><span class="attr">style</span>=<span class="string">&#123;[styles.centering,</span> &#123;<span class="attr">height:</span> <span class="attr">80</span>&#125;]&#125;</span></span><br><span class="line"><span class="tag"><span class="attr">color</span>=<span class="string">'#000'</span></span></span><br><span class="line"><span class="tag"><span class="attr">size</span>=<span class="string">'large'</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>其属性animating 表示是否显示loading图片  默认TRUE 显示<br>color  loading的颜色<br>size  大小设置  属性值 可写 small  large 不可以为数字或者其他</p><h4 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"><span class="attr">onPress</span>=<span class="string">&#123;this.onPressLearnMore&#125;</span></span></span><br><span class="line"><span class="tag"><span class="attr">title</span>=<span class="string">'click the button'</span></span></span><br><span class="line"><span class="tag"><span class="attr">color</span>=<span class="string">'#841584'</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>属性 onPress 当点击的时候 执行此函数</p><p>其余属性</p><p>disabled  为TRUE 时候 则按钮不可点击<br>color 按钮中字体颜色</p><h4 id="Alert-弹出层"><a href="#Alert-弹出层" class="headerlink" title="Alert  弹出层"></a>Alert  弹出层</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Alert&#125; from 'react-native'</span><br><span class="line">---</span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">onPress</span>=<span class="string">&#123;()</span> =&gt;</span> Alert.alert('you clicked the button') &#125;&gt;</span><br></pre></td></tr></table></figure><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Image</span></span></span><br><span class="line"><span class="tag">   <span class="attr">style</span>=<span class="string">&#123;styles.logo&#125;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">source</span>=<span class="string">&#123;&#123;uri:</span> '<span class="attr">http:</span>//<span class="attr">facebook.github.io</span>/<span class="attr">react</span>/<span class="attr">img</span>/<span class="attr">logo_og.png</span>'&#125;&#125;</span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的属性source  后面的URL  如果是http开头的 很可能在iOS上打不开  推荐使用https开头</p><h4 id="listView"><a href="#listView" class="headerlink" title="listView"></a>listView</h4><p>展示数据列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">var</span> ds = <span class="keyword">new</span> ListView.DataSource(&#123;<span class="attr">rowHasChanged</span>: <span class="function">(<span class="params">r1, r2</span>) =&gt;</span> r1 !== r2&#125;);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    dataSource: ds.cloneWithRows([<span class="string">'row 1'</span>, <span class="string">'row 2'</span>]),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ListView</span><br><span class="line">      dataSource=&#123;<span class="keyword">this</span>.state.dataSource&#125;</span><br><span class="line">      renderRow=&#123;(rowData) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>&#123;rowData&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最基本的使用方式就是创建一个ListView.DataSource数据源，然后给它传递一个普通的数据数组，</p><p>再使用数据源来实例化一个ListView组件，并且定义它的renderRow回调函数</p><p>这个函数会接受数组中的每个数据作为参数，去渲染每一行，返回一个可渲染的组件（作为listview的每一行）</p><p>属性参数解析</p><h5 id="dataSource"><a href="#dataSource" class="headerlink" title="dataSource"></a>dataSource</h5><p>列表依赖的数据源</p><h5 id="initialListSize-【number】"><a href="#initialListSize-【number】" class="headerlink" title="initialListSize 【number】"></a>initialListSize 【number】</h5><p>指定在组件刚挂载的时候渲染多少行数据</p><p>用这个属性来确保首屏显示合适数量的数据，而不是花费太多帧逐步显示出来</p><h5 id="onChangeVisibleRows-function"><a href="#onChangeVisibleRows-function" class="headerlink" title="onChangeVisibleRows [function]"></a>onChangeVisibleRows [function]</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(visibleRows, changedRows) =&gt; <span class="keyword">void</span></span><br></pre></td></tr></table></figure><p>视野内可见的行的集合变化的时候调用此回调函数</p><p>visibleRows 以 { sectionID: { rowID: true }}的格式包含了所有可见行，而changedRows 以{ sectionID: { rowID: true | false }}的格式包含了所有刚刚改变了可见性的行</p><p>其中如果值为true表示一个行变得可见，而为false表示行刚刚离开可视区域而变得不可见。</p><h5 id="pageSize-【number】"><a href="#pageSize-【number】" class="headerlink" title="pageSize 【number】"></a>pageSize 【number】</h5><p>每次事件循环（每帧）渲染的行数</p><h5 id="renderFooter-【function】"><a href="#renderFooter-【function】" class="headerlink" title="renderFooter 【function】"></a>renderFooter 【function】</h5><h5 id="renderHeader-【function】"><a href="#renderHeader-【function】" class="headerlink" title="renderHeader 【function】"></a>renderHeader 【function】</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; renderable</span><br></pre></td></tr></table></figure><p>页头与页脚会在每次渲染过程中都重新渲染【如果提供了这些属性】</p><p>如果它们重绘的性能开销很大，把他们包装到一个StaticContainer或者其它恰当的结构中。页脚会永远在列表的最底部，而页头会在最顶部</p><h5 id="renderRow-【function】"><a href="#renderRow-【function】" class="headerlink" title="renderRow 【function】"></a>renderRow 【function】</h5><p>(rowData, sectionID, rowID, highlightRow) =&gt; renderable</p><p>从数据源(Data source)中接受一条数据，以及它和它所在section的ID。返回一个可渲染的组件来为这行数据进行渲染。默认情况下参数中的数据就是放进数据源中的数据本身，不过也可以提供一些转换器。</p><p>如果某一行正在被高亮（通过调用highlightRow函数），ListView会得到相应的通知。当一行被高亮时，其两侧的分割线会被隐藏。行的高亮状态可以通过调用highlightRow(null)来重置</p><h4 id="ListView-DataSource"><a href="#ListView-DataSource" class="headerlink" title="ListView.DataSource"></a>ListView.DataSource</h4><p>要更新datasource中的数据，每次都重新调用cloneWithRows方法</p><p>数据源中的数据本身是不可修改的，所以请勿直接尝试修改</p><p>clone方法会自动提取新数据并进行逐行对比（使用rowHasChanged方法中的策略）这样ListView就知道哪些行需要重新渲染了</p><h5 id="cloneWithRows-dataBlob-rowIdentities"><a href="#cloneWithRows-dataBlob-rowIdentities" class="headerlink" title="cloneWithRows(dataBlob, rowIdentities)"></a>cloneWithRows(dataBlob, rowIdentities)</h5><p>根据指定的dataBlob和 rowIdentities为ListViewDataSource复制填充数据。dataBlob即原始数据。需要在初始化时定义抽取函数（否则使用默认的抽取函数）。</p><p>rowIdentities是一个二维数组，包含了行数据对应的id标识符，例如[[‘a1’, ‘a2’], [‘b1’, ‘b2’, ‘b3’], …]。如果没有指定此数组，则默认取行数据的key。</p><p>注：此方法实际并没有复制数据。它只是重新创建一个datasource，然后将你指定的dataBlob传递给构造函数中指定的提取函数，因而会抛弃先前的数据。如果你希望保留先前的数据，则必须先自行进行新老数据的合并处理，然后再将合并后的结果作为dataBlob传递给此方法调用。</p><h4 id="ScrollView-视图滚动"><a href="#ScrollView-视图滚动" class="headerlink" title="ScrollView  视图滚动"></a>ScrollView  视图滚动</h4><p>属性解析</p><h5 id="horizontal"><a href="#horizontal" class="headerlink" title="horizontal"></a>horizontal</h5><p>当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列</p><p>默认值为false</p><h5 id="showsHorizontalScrollIndicator-bool"><a href="#showsHorizontalScrollIndicator-bool" class="headerlink" title="showsHorizontalScrollIndicator bool"></a>showsHorizontalScrollIndicator bool</h5><p>当此属性为true的时候，显示一个水平方向的滚动条</p><h5 id="scrollEventThrottle-【number】"><a href="#scrollEventThrottle-【number】" class="headerlink" title="scrollEventThrottle   【number】"></a>scrollEventThrottle   【number】</h5><p>这个属性控制在滚动过程中，scroll事件被调用的频率（单位是每秒事件数量）</p><p>更大的数值能够更及时的跟踪滚动位置，不过可能会带来性能问题</p><p>默认值为0，意味着每次视图被滚动，scroll事件只会被调用一次</p><h5 id="onScroll"><a href="#onScroll" class="headerlink" title="onScroll"></a>onScroll</h5><p>滚动是触发的方法</p><h5 id="scrollEnabled-bool"><a href="#scrollEnabled-bool" class="headerlink" title="scrollEnabled bool"></a>scrollEnabled bool</h5><p>当值为false的时候，内容不能滚动，默认值为true</p><h4 id="TouchableOpacity"><a href="#TouchableOpacity" class="headerlink" title="TouchableOpacity"></a>TouchableOpacity</h4><p>本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级</p><p>使用案例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TouchableOpacity</span> <span class="attr">onPress</span>=<span class="string">&#123;this._onPressButton&#125;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Image</span></span></span><br><span class="line"><span class="tag">     <span class="attr">style</span>=<span class="string">&#123;styles.button&#125;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">source</span>=<span class="string">&#123;require(</span>'<span class="attr">image</span>!<span class="attr">myButton</span>')&#125;</span></span><br><span class="line"><span class="tag">   /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TouchableOpacity</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="项目调试"><a href="#项目调试" class="headerlink" title="项目调试"></a>项目调试</h3><p>当你的项目在模拟器中运行起来之后 需要对项目进行调试</p><p><strong> 针对于iOS开发 </strong></p><h4 id="Developer-Menu"><a href="#Developer-Menu" class="headerlink" title="Developer Menu"></a>Developer Menu</h4><p>在模拟器中开启 Developer Menu  快捷键 com + D</p><h4 id="Chrome-Developer-Tools"><a href="#Chrome-Developer-Tools" class="headerlink" title="Chrome Developer Tools"></a>Chrome Developer Tools</h4><p>谷歌开发工具是大家非常熟悉的了</p><p>第一步：启动远程调试</p><p>Developer Menu下单击”Debug JS Remotely” 启动JS远程调试功能。此时Chrome会被打开</p><p>第二步：打开Chrome开发者工具</p><p>在该“<a href="http://localhost:8081/debugger-ui.”Tab页下打开开发者工具。打开Chrome菜单-&gt;选择更多工具-&gt;选择开发者工具" target="_blank" rel="noopener">http://localhost:8081/debugger-ui.”Tab页下打开开发者工具。打开Chrome菜单-&gt;选择更多工具-&gt;选择开发者工具</a></p><p>然后选择source 进行调试</p><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><p>1 在调试模拟器的时候发现速度很慢  估计是在刷新页面的时候 误点击了commond + T 导致开启了slowe animation</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pm2</title>
      <link href="/2017/10/01/pm2/"/>
      <url>/2017/10/01/pm2/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是pm2"><a href="#什么是pm2" class="headerlink" title="什么是pm2"></a>什么是pm2</h3><p>pm2 是一个带有负载均衡功能的Node应用的进程管理器</p><p><a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener">GitHub地址</a></p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure><p>还可以使用淘宝滤镜</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2 --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>pm2 list  显示所有进程状态</p></li><li><p>pm2 start app.js 开始进程</p></li><li><p>pm2 stop 停止进程</p></li></ul><p>pm2 stop 0             # 停止指定的进程</p><p>pm2 stop all           # 停止所有进程</p><ul><li>pm2 restart 重启进程</li></ul><p>pm2 restart 0          # 重启指定的进程</p><p>pm2 restart all        # 重启所有进程</p><p>pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)</p><ul><li>pm2 delete 杀掉进程</li></ul><p>pm2 delete 0  杀死指定的进程</p><p>pm2 delete all  杀死全部进程</p><ul><li>pm2 logs  查看日志</li></ul><p>比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启</p>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> server </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>留言反馈墙</title>
      <link href="/2017/10/01/%E7%95%99%E8%A8%80%E5%8F%8D%E9%A6%88%E5%A2%99/"/>
      <url>/2017/10/01/%E7%95%99%E8%A8%80%E5%8F%8D%E9%A6%88%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<p>可以看做一个不断滚动的banner墙</p><h3 id="页面可见性"><a href="#页面可见性" class="headerlink" title="页面可见性"></a>页面可见性</h3><p>用户在浏览器可以同时打开N个tab窗口，他看的永远只是一个tab，其他不是激活态（按API，应该是叫隐藏）</p><a id="more"></a><p>但是这些 hidden 起来的窗口 里面的数据还有内存还在一直处理 没有停止 比如视频会一直处于播放状态什么的</p><p>HTML5的Page Visibility (页面可见性) API有两个属性，一个事件</p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><table><thead><tr><th>属性</th><th>属性值类型</th></tr></thead><tbody><tr><td>document.hidden</td><td>Boolean</td></tr><tr><td>document.visibilityState</td><td>hidden、visible、 prerender、 preview</td></tr></tbody></table><p>document.hidden 是一个只读的属性，返回一个布尔值标识当前页面是否hidden</p><p>事件  visibilitychange</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">document</span>.visibilityState )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果想要在用户重新进入页面的时候获取到最新数据  可以在在监听到当前标签页被重新激活的时候 进行一个reload</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.reload()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关于浏览器是否支持此属性</p><p><img src="/img/feedback/hidden.png" alt="hidden"></p><p>页面可见性API的所有属性以及事件，目前是需要添加私有前缀的 ms webkit 等</p><h3 id="根据文字框的高度来自动改变字体的大小"><a href="#根据文字框的高度来自动改变字体的大小" class="headerlink" title="根据文字框的高度来自动改变字体的大小"></a>根据文字框的高度来自动改变字体的大小</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">12</span>; i &lt; <span class="number">140</span>; i++) &#123;</span><br><span class="line">  contHeight = target.offsetHeight</span><br><span class="line">  <span class="keyword">if</span> (contHeight &gt; boxHeight) &#123;</span><br><span class="line">    <span class="comment">// 当容器高度大于最大高度的时候，上一个尝试的值就是最佳大小。</span></span><br><span class="line">    target.style.fontSize = <span class="string">`<span class="subst">$&#123;(i - <span class="number">2</span>)&#125;</span>px`</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果小于最大高度，文字大小加1继续尝试</span></span><br><span class="line">    target.style.fontSize = <span class="string">`<span class="subst">$&#123;(i)&#125;</span>px`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过不断比较已经填充内容区域高度与文字框的高度 来确定文字字号大小</p><p>其实也有一个第三方插件 react-textfit 但是在测试中发现 在这个项目中并不是特别适合</p><p><a href="https://www.npmjs.com/package/react-textfit" target="_blank" rel="noopener">npm地址</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Textfit &#125; from 'react-textfit'</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Textfit</span> <span class="attr">style</span>=<span class="string">&#123;&#123;height:</span> <span class="attr">300</span>&#125;&#125; <span class="attr">mode</span>=<span class="string">"multi"</span> <span class="attr">min</span>=<span class="string">&#123;34&#125;</span> <span class="attr">max</span>=<span class="string">&#123;100&#125;</span>&gt;</span></span><br><span class="line">  &#123;contents&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">Textfit</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="渐变透明阴影"><a href="#渐变透明阴影" class="headerlink" title="渐变透明阴影"></a>渐变透明阴影</h3><p><img src="/img/feedback/version.png" alt="bgshadow"></p><p>这各部分本来直接使用的图片 之后复查代码的时候 感觉可以直接使用CSS的处理</p><p>css的渐变分为两种  线性渐变 linear gradients 与 径向渐变 radial gradients</p><p>这里需要用到的是linear gradients  从左到右 渐变 并且渐变色 透明度逐渐降低</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">direction</span>, <span class="selector-tag">color1</span>, <span class="selector-tag">color2</span>);</span><br></pre></td></tr></table></figure><p>默认情况下 第一个渐变参数 方向 为从上到下</p><ul><li>从左到右</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(<span class="selector-tag">to</span> <span class="selector-tag">right</span>, <span class="selector-tag">red</span> , <span class="selector-tag">blue</span>);</span><br></pre></td></tr></table></figure><ul><li>指定角度</li></ul><p><img src="/img/feedback/angle.png" alt="angle"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">linear-gradient</span>(40<span class="selector-tag">deg</span>, <span class="selector-tag">red</span> , <span class="selector-tag">blue</span>);</span><br></pre></td></tr></table></figure><p>实现图例中的阴影渐变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));</span><br><span class="line">border-radius: 0.3rem 0 0 0.3rem；</span><br></pre></td></tr></table></figure><h3 id="dangerouslySetInnerHTML"><a href="#dangerouslySetInnerHTML" class="headerlink" title="dangerouslySetInnerHTML"></a>dangerouslySetInnerHTML</h3><p>由于文字框需要展示用户的留言部分 为了防止出现意外情况 （XSS攻击） 比如用户输入多个空格  需要原样展示用户留言 后者如果用户手动输入类似于代码的留言 比如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">window</span>.NAME)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不做任何处理 那么当留言被读取进入服务器再展示出来 就能看到站点信息了 因此需要将留言进行净化处理展示</p><p>dangerouslySetInnerHTML ，它的 prop 值（ 一个对象而不是字符串 ）应该被用来表明净化后的数据 简单的说 他是用来 提供插入纯 HTML 字符串的功能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dangerouslySetInnerHTML = &#123;&#123; __html: contents.replace(/\n/g, '<span class="tag">&lt;<span class="name">br</span> /&gt;</span>') &#125;&#125;</span><br></pre></td></tr></table></figure><p>关于 cross-site scripting (XSS)攻击：</p><p>简单点来说 就是非本站开发人员 通过各种方式注入影响项目功能或者获取站点信息的代码</p>]]></content>
      
      
      <categories>
          
          <category> 项目总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>屏幕尺寸、分辨率等</title>
      <link href="/2017/09/28/%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E3%80%81%E5%88%86%E8%BE%A8%E7%8E%87%E7%AD%89/"/>
      <url>/2017/09/28/%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E3%80%81%E5%88%86%E8%BE%A8%E7%8E%87%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p>项目中有遇到一个关于大屏幕适配的问题， 本来以为大屏幕的分辨率会很高，结果却只有 960 很是奇怪</p><h3 id="尺寸-英寸"><a href="#尺寸-英寸" class="headerlink" title="尺寸  英寸"></a>尺寸  英寸</h3><p>常用的长度单位 有xxx英寸  英寸转化为厘米为  1英寸（inch）= 2.54厘米（cm）</p><p>而我们说的手机是xxx英寸的 这个长度指的是手机屏幕对角线的长度 你可以直接用尺子量出几厘米然后将其转化为英寸的单位</p><a id="more"></a><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>手机的分辨率一般是xxx px 比如iPhone5的分辨率是 320px</p><p>这里px是像素 因此分辨率的单位就是像素</p><p>比如我们平时使用的设计稿为 750px  这里就是在有750个像素中的UI设计</p><h3 id="屏幕像素密度"><a href="#屏幕像素密度" class="headerlink" title="屏幕像素密度"></a>屏幕像素密度</h3><p>屏幕像素密度，即每英寸屏幕所拥有的像素数，英文简称PPI</p><p>注意 <strong>  每英寸并不是每平方英寸的简称 </strong>  这个英寸跟之前手机屏幕的尺寸一样，也是对角线的长度</p><p><strong> 屏幕像素密度就是一个对角线长度为1英寸的正方形内所拥有的像素数 </strong></p><h3 id="屏幕像素密度，分辨率，屏幕尺寸的关系是什么"><a href="#屏幕像素密度，分辨率，屏幕尺寸的关系是什么" class="headerlink" title="屏幕像素密度，分辨率，屏幕尺寸的关系是什么"></a>屏幕像素密度，分辨率，屏幕尺寸的关系是什么</h3><p><img src="/img/size/PPI.png" alt="ppi"></p><h4 id="像素的大小是固定的吗"><a href="#像素的大小是固定的吗" class="headerlink" title="像素的大小是固定的吗"></a>像素的大小是固定的吗</h4><p>iPhone<br><img src="/img/size/iphone7.png" alt="ppi"></p><p>华为荣耀6手机参数<br><img src="/img/size/other.png" alt="ppi"></p><table><thead><tr><th>手机型号</th><th>实际尺寸</th><th>屏幕分辨率</th><th>屏幕像素密度PPI</th></tr></thead><tbody><tr><td>iPhone7 plus</td><td>5.5英寸</td><td>1920 * 1080 px</td><td>401 PPI</td></tr><tr><td>华为荣耀</td><td>5.2英寸</td><td>1920 * 1080 px</td><td>424 PPI</td></tr></tbody></table><p>这两个手机的分辨率都是1920px*1080px。</p><p>但是，苹果手机的屏幕尺寸比华为荣耀7大了0.3英寸。而苹果手机的屏幕像素密度（PPI）却比华为荣耀7高</p><p>说明了同样的一英寸的长度，苹果手机用401个ppi来显示，华为只用了424个ppi来显示</p><p>同样是一英寸，同样都是像素，但是两个手机中每英寸屏幕像素个数却不同</p><p>我们知道，英寸是长度单位，它有固定的物理尺寸。那么问题就只能出在了像素身上。这说明，像素这个东西，在苹果手机上变小了。所以，像素这个东西能变大能变小。</p><p>(原文在这里)[<a href="http://www.jianshu.com/p/c3387bcc4f6e]" target="_blank" rel="noopener">http://www.jianshu.com/p/c3387bcc4f6e]</a></p><p>原文下面的讨论区也很有意思</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分辨率 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>canvas</title>
      <link href="/2017/09/27/canvas/"/>
      <url>/2017/09/27/canvas/</url>
      
        <content type="html"><![CDATA[<p>之前写过一篇 <a href="http://web.blued.cn/2017/07/03/Canvas%E5%88%9D%E8%AF%86/" target="_blank" rel="noopener">canvas初识</a></p><p>简单使用了canvas进行图形绘制</p><a id="more"></a><h3 id="canvas-绘制弧度三角"><a href="#canvas-绘制弧度三角" class="headerlink" title="canvas 绘制弧度三角"></a>canvas 绘制弧度三角</h3><p><img src="/img/canvas/bubble.png" alt="canvas"></p><p>这个气泡的左下部分 是一个有弧度的三角 最开始是使用的一个图片来处理 后来想想 使用canvas应该也可以做到这个效果</p><p>主要是canvas的弧度处理 也就是画圆</p><h3 id="ctx-arc-x-y-radius-start-end-boolean"><a href="#ctx-arc-x-y-radius-start-end-boolean" class="headerlink" title="ctx.arc(x, y, radius, start, end, boolean)"></a>ctx.arc(x, y, radius, start, end, boolean)</h3><p>这个方法是用来进行画圆的</p><p>参数解析</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>x , y</td><td>圆心</td></tr><tr><td>radius</td><td>半径</td></tr><tr><td>start</td><td>开始角度</td></tr><tr><td>end</td><td>结束角度</td></tr><tr><td>Boolean</td><td>顺时针或者逆时针</td></tr></tbody></table><p>最后一个布尔值 默认FALSE 表示顺时针开始画画</p><p><img src="/img/canvas/API.png" alt="canvas"></p><h4 id="半圆"><a href="#半圆" class="headerlink" title="半圆"></a>半圆</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(190, 190, 90, 0, Math.PI * 3, true)</span><br><span class="line">ctx.fill()</span><br></pre></td></tr></table></figure><p><img src="/img/canvas/canvas.png" alt="canvas"></p><h4 id="四分之一"><a href="#四分之一" class="headerlink" title="四分之一"></a>四分之一</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(190, 190, 90, 0, Math.PI * 0.5, false)</span><br><span class="line">ctx.fill()</span><br></pre></td></tr></table></figure><p><img src="/img/canvas/line.png" alt="canvas"></p><h4 id="带有弧度的三角形"><a href="#带有弧度的三角形" class="headerlink" title="带有弧度的三角形"></a>带有弧度的三角形</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="built_in">Math</span>.PI, <span class="built_in">Math</span>.PI * <span class="number">1.5</span>, <span class="literal">false</span>)</span><br><span class="line">ctx.lineTo(<span class="number">50</span>, <span class="number">50</span>)</span><br><span class="line">ctx.lineTo(<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">ctx.stroke()</span><br></pre></td></tr></table></figure><p><img src="/img/canvas/draw.png" alt="canvas"></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一周计划</title>
      <link href="/2017/09/25/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%92/"/>
      <url>/2017/09/25/%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f1969e015231?w=1424&amp;h=698&amp;f=png&amp;s=1887559" alt="plan"></p><a id="more"></a><h3 id="work"><a href="#work" class="headerlink" title="work"></a>work</h3><h4 id="调查问卷"><a href="#调查问卷" class="headerlink" title="调查问卷"></a>调查问卷</h4><ul><li>已经提测 等待反馈中</li></ul><h4 id="吐槽墙"><a href="#吐槽墙" class="headerlink" title="吐槽墙"></a>吐槽墙</h4><p>知识点</p><!-- more --><ul><li><p>canvas 弧度 处理对话框</p></li><li><p>服务器配置  防火墙</p></li><li><p>如何获取到IP地址  </p><p>第三方插件 <a href="https://github.com/pbojinov/request-ip" target="_blank" rel="noopener">request-ip</a></p></li><li><p>pm2</p><p>项目布置到服务器中</p></li><li><p>尺寸与分辨率  </p></li></ul><h3 id="research"><a href="#research" class="headerlink" title="research"></a>research</h3><ul><li><p>webpack</p></li><li><p>exif.js 处理照片上传之后的旋转角度</p></li></ul><h3 id="阅读计划"><a href="#阅读计划" class="headerlink" title="阅读计划"></a>阅读计划</h3><h4 id="web前端工程师的自我修养"><a href="#web前端工程师的自我修养" class="headerlink" title="web前端工程师的自我修养"></a>web前端工程师的自我修养</h4><ul><li>第一遍读完 2017/09/28</li></ul><h4 id="山海经-–-南山卷"><a href="#山海经-–-南山卷" class="headerlink" title="山海经 – 南山卷"></a>山海经 – 南山卷</h4>]]></content>
      
      
      <categories>
          
          <category> 一周计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SVG + CSS3动画实现文字描边</title>
      <link href="/2017/09/24/svg/"/>
      <url>/2017/09/24/svg/</url>
      
        <content type="html"><![CDATA[<h2 id="svg-定义"><a href="#svg-定义" class="headerlink" title="svg 定义"></a>svg 定义</h2><p>SVG 是使用 XML 来描述二维图形和绘图程序的语言</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="stroke-属性"><a href="#stroke-属性" class="headerlink" title="stroke 属性"></a>stroke 属性</h2><a id="more"></a><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>stroke</td><td>用于设置线条颜色</td></tr><tr><td>stroke-width</td><td>线条粗细</td></tr><tr><td>stroke-opacity</td><td>线条不透明度</td></tr><tr><td>stroke-linecap</td><td>描边方式</td></tr><tr><td>stroke-linejoin</td><td>两个描边之间用什么链接</td></tr><tr><td>stroke-dasharray</td><td>虚线样式</td></tr><tr><td>stroke-dashoffset</td><td>定义虚线开始的位置</td></tr></tbody></table><h3 id="stroke-dasharray"><a href="#stroke-dasharray" class="headerlink" title="stroke-dasharray"></a>stroke-dasharray</h3><blockquote><p>stroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stroke-dasharray="5,10,5"</span><br><span class="line">stroke-dasharray="5,5"</span><br></pre></td></tr></table></figure><p>注意，和path不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。</p><p>所以在上面的例子里，第二个路径会先做5个像素单位的填色，紧接着是5个空白单位，然后又是5个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。</p><p>第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复</p><h2 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h2><p>创建元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">text</span> <span class="attr">text-anchor</span>=<span class="string">"middle"</span> <span class="attr">x</span>=<span class="string">"50%"</span> <span class="attr">y</span>=<span class="string">"50%"</span> <span class="attr">class</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">      cancan</span><br><span class="line">  <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制CSS</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">64px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">  <span class="attribute">fill</span>: none;</span><br><span class="line">  <span class="attribute">stroke</span>: <span class="number">#3498db</span>;</span><br><span class="line">  <span class="attribute">stroke-width</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">stroke-dasharray</span>: <span class="number">90</span> <span class="number">310</span>;</span><br><span class="line">  <span class="attribute">animation</span>: stroke <span class="number">6s</span> infinite linear;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> stroke &#123;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">stroke-dashoffset</span>: -<span class="number">400</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启Animation动画 通过不断变动虚线开始的位置 来实现文字边线闪动</p><p><img src="/img/svg/can2.gif" alt="svg"></p><p>这样可以发现 视觉上的文字边界移动效果</p><p>如果创建多个重复元素 可以实现以下效果</p><p><img src="/img/svg/can.gif" alt="svg"></p>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svg </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack-3</title>
      <link href="/2017/09/21/webpack-3/"/>
      <url>/2017/09/21/webpack-3/</url>
      
        <content type="html"><![CDATA[<p>当在命令行输入 webpack 发生了什么</p><p>执行脚本 bin/webpack.js</p><h3 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h3><p>每次在命令行输入 webpack 后，操作系统都会去调用 ./node_modules/.bin/webpack 这个 shell 脚本。这个脚本会去调用 ./node_modules/webpack/bin/webpack.js 并追加输入的参数，如 -p , -w</p><h4 id="yargs-解析命令行参数"><a href="#yargs-解析命令行参数" class="headerlink" title="yargs 解析命令行参数"></a>yargs 解析命令行参数</h4><p>通过第三方模块 yargs 来解析命令行参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> argv = <span class="built_in">require</span>(<span class="string">'yargs'</span>).argv</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello '</span>, argv.name)</span><br></pre></td></tr></table></figure><p>可以在命令行输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hello --name=tom</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">$ hello --name tom</span><br></pre></td></tr></table></figure><p>解析 webpack 指令后面追加的与输出显示相关的参数（Display options）</p><p>比如命令行经常输入的 -w -color -hot 参数</p><h4 id="webpack-config-js-中参数"><a href="#webpack-config-js-中参数" class="headerlink" title="webpack.config.js 中参数"></a>webpack.config.js 中参数</h4><p>./node_modules/webpack/bin/convert-argv.js，是用来通过判断 argv 中参数的值决定是否去加载对应插件的功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(argv.watch) &#123;</span><br><span class="line">  options.watch = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">ifBooleanArg(<span class="string">"debug"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ensureArray(options, <span class="string">"plugins"</span>);</span><br><span class="line">  <span class="keyword">var</span> LoaderOptionsPlugin = <span class="built_in">require</span>(<span class="string">"../lib/LoaderOptionsPlugin"</span>);</span><br><span class="line">  options.plugins.push(<span class="keyword">new</span> LoaderOptionsPlugin(&#123;</span><br><span class="line">    debug: <span class="literal">true</span></span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// other code</span></span><br><span class="line"><span class="keyword">return</span> options</span><br></pre></td></tr></table></figure><p>webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中</p><p>通过 optimist 将用户配置的 webpack.config.js 和 shell 脚本传过来的参数整合成 options 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="built_in">require</span>(<span class="string">"./convert-argv"</span>)(yargs, argv)</span><br></pre></td></tr></table></figure><h3 id="plugins-插件的加载"><a href="#plugins-插件的加载" class="headerlink" title="plugins 插件的加载"></a>plugins 插件的加载</h3><p>在加载插件之前 webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins</p><p>接着 optimist.argv 会被传入到 ./node_modules/webpack/bin/convert-argv.js 中，通过判断 argv 中参数的值决定是否去加载对应插件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ifBooleanArg(<span class="string">"hot"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ensureArray(options, <span class="string">"plugins"</span>);</span><br><span class="line">  <span class="keyword">var</span> HotModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">"../lib/HotModuleReplacementPlugin"</span>);</span><br><span class="line">  options.plugins.push(<span class="keyword">new</span> HotModuleReplacementPlugin());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ifBooleanArg(<span class="string">"debug"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ensureArray(options, <span class="string">"plugins"</span>);</span><br><span class="line">  <span class="keyword">var</span> LoaderOptionsPlugin = <span class="built_in">require</span>(<span class="string">"../lib/LoaderOptionsPlugin"</span>);</span><br><span class="line">  options.plugins.push(<span class="keyword">new</span> LoaderOptionsPlugin(&#123;</span><br><span class="line">    debug: <span class="literal">true</span></span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ifArg(<span class="string">"devtool"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  options.devtool = value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> options;</span><br></pre></td></tr></table></figure><p>至此当插件对象初始化完毕</p><p>option中包含了全部的参数设置 包括webpack.config.js 与 shell 命令行中的输入的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;&#125;,<span class="comment">//入口配置</span></span><br><span class="line">  output: &#123;&#125;, <span class="comment">//输出配置</span></span><br><span class="line">  plugins: [], <span class="comment">//插件集合(配置文件 + shell指令)</span></span><br><span class="line">  <span class="built_in">module</span>: &#123; <span class="attr">loaders</span>: [ [<span class="built_in">Object</span>] ] &#125;, <span class="comment">//模块配置</span></span><br><span class="line">  context: <span class="comment">//工程路径</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后options对象传到了下一个流程的控制对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"../lib/webpack.js"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compiler;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  compiler = webpack(options);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lib-webpack-js-初始化-webpack-对象"><a href="#lib-webpack-js-初始化-webpack-对象" class="headerlink" title="lib/webpack.js 初始化 webpack 对象"></a>lib/webpack.js 初始化 webpack 对象</h3><p>在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步</p><p>而这个时候，真正的 webpack 对象才刚被初始化，具体的初始化逻辑在 lib/webpack.js</p><p>webpack 的实际入口是 Compiler 中的 run 方法，run 一旦执行后，就开始了编译和构建流程</p><p>不过在进行run之前 先判断是否配置watch参数 如果有则会开启 watch 线程</p><p>如果有配置此参数 则开启监听文件变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compilerCallback</span>(<span class="params">err, stats</span>) </span>&#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(firstOptions.watch || options.watch) &#123;</span><br><span class="line">  ......</span><br><span class="line">  compiler.watch(watchOptions, compilerCallback);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"\nWebpack is watching the files…\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  compiler.run(compilerCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书笔记-web工程师的自我修养</title>
      <link href="/2017/09/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-web%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
      <url>/2017/09/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-web%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
      
        <content type="html"><![CDATA[<p>Emmmmm… 很奇怪的书名~~</p><p>这本书不是很具体讲某一个方面的技能点 而是分析了一下程序员的生存之路吧</p><p>指点作为一名程序员如何学习 展现 提升自我</p><a id="more"></a><p>简单记录几个笔记</p><h3 id="chapter1"><a href="#chapter1" class="headerlink" title="chapter1"></a>chapter1</h3><p>一个基本的web栈由服务器 数据库 服务端编程语言 html css javascript 组成</p><p>用户量的大小 服务器承受压力的能力  软件对服务器计算要求 对服务器相应要求 等等因素</p><ul><li>MEAN 一个完整技术栈</li></ul><p>mongodb express angular node  </p><p>这个如果对照我们的项目 使用就是 MySQL koa React node</p><ul><li>VPS Virtual private server  虚拟专用服务器</li></ul><p>把一台物理服务器虚拟成多给我虚拟专用服务器的服务</p><p>每一个vps都可以分配独立的公网IP地址 运行独立的操作系统 拥有独立的磁盘空间 内存 CPU资源 进程 系统配置</p><ul><li>勿在浮沙筑高台</li></ul><p>每三个月就要更新学习计划</p><h3 id="chapter4"><a href="#chapter4" class="headerlink" title="chapter4"></a>chapter4</h3><ul><li>野生程序员</li></ul><h4 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h4><ul><li><p>前端处理： 减少同一个域的http请求数目  减少每一个资源的体积</p></li><li><p>后台处理： 尽快相应请求 以及减少请求对于服务器的开销</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>函数预解释</title>
      <link href="/2017/09/09/%E5%87%BD%E6%95%B0%E9%A2%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2017/09/09/%E5%87%BD%E6%95%B0%E9%A2%84%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>1 预解释 var 和function</p><p>2 函数操作过程，四步。</p><p>3 奇怪的预解释</p><a id="more"></a><h3 id="js中的预解释"><a href="#js中的预解释" class="headerlink" title="js中的预解释"></a>js中的预解释</h3><h4 id="什么是预解释"><a href="#什么是预解释" class="headerlink" title="什么是预解释"></a>什么是预解释</h4><p>js中，在代码执行前，带var 和function关键字是需要预解释的。</p><p>在当前作用域下，在JS代码执行之前，浏览器会对带var和带function的，进行提前声明或定义；</p><ul><li>var 和 function的预解释不同</li></ul><p>var 声明变量的时候，只是发生了声明，而不会发生定义，即赋值</p><p>function关键字的预解释，声明和定义，在整个代码执行前，就已经将函数名存入内存并且给这个函数名进行了赋值。即将函数空间地址赋值给函数名，</p><h4 id="函数的四个步骤"><a href="#函数的四个步骤" class="headerlink" title="函数的四个步骤"></a>函数的四个步骤</h4><p>1 形成私有作用域</p><p>2 形参赋值</p><p>3 变量预解释</p><p>4 代码从上到下执行</p><h4 id="预解释是在私有作用域的"><a href="#预解释是在私有作用域的" class="headerlink" title="预解释是在私有作用域的"></a>预解释是在私有作用域的</h4><h5 id="私有作用域"><a href="#私有作用域" class="headerlink" title="私有作用域"></a>私有作用域</h5><p>函数运行时会形成一个自己的私有作用域，预解释是在函数私有作用域进行的。</p><p>作用域链：<br>当函数被调用的时候，会形成一个私有作用域，</p><p>我们看该私有作用域下，是否有私有变量A：</p><p>1）如果有私有变量A：那么该作用域中的A，都是私有变量，跟外界没有任何关系<br>2）如果没有私有变量A：到上级作用域进行查找，如果没有，继续往上找，找到window全局作用域还没有的话，报错；</p><p>在私有作用域内有变量a，则与外界作用域无关</p><p>如果没有私有变量a,则到上级作用域进行查找</p><h5 id="私有变量【两种】"><a href="#私有变量【两种】" class="headerlink" title="私有变量【两种】"></a>私有变量【两种】</h5><p>1 形参 2 带var的</p><h5 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h5><p>1 栈内存提供了代码的运行环境  里面保存基本数据类型的变量</p><p>运行环境： 包括私有作用域和全局作用域</p><p>2 堆内存保存引用数据类型的数据，其中对象以键值对形式保存，函数以字符串形式保存</p><h5 id="关于带var-的和不带var-的"><a href="#关于带var-的和不带var-的" class="headerlink" title="关于带var 的和不带var 的"></a>关于带var 的和不带var 的</h5><p>如果是全局变量，无论是带不带var，都属于全局window</p><p>而带var的会进行预解释，不带var的则不进行预解释</p><h5 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h5><p>3.5.1 堆内存释放</p><p>var a =[‘hi’];<br>a=null; // 内存释放<br>3.5.2 栈内存释放</p><p>栈内存，是形成js’代码的执行环境，也就是私有作用域和全局作用域。所以需要进行作用域的销毁。</p><p>全局作用域的产生是伴随浏览器而形成，所以当关闭浏览器，全局作用域自然销毁。</p><p>私有作用域一般情况下，当函数执行完毕就会被js的垃圾回收机制自动销毁。</p><p>特殊情况有两种分为，1 不销毁 2 暂时不销毁</p><p>不销毁状态： 函数内部有东西被外部变量占用</p><p>暂时不销毁：一般是内层函数执行完毕先销毁内层之后外层函数进行销毁</p><h3 id="奇怪的预解释"><a href="#奇怪的预解释" class="headerlink" title="奇怪的预解释"></a>奇怪的预解释</h3><p>3.1 对于var在左侧的，只进行变量声明</p><p>3.2  已经声明过的，不会重复声明。但是可以进行赋值操作。</p><p>3.3 预解释阶段，函数优先级高于var 变量</p><p>3.4 自执行函数，不会进行预解释。只有执行到的时候，就是开始那个函数的四步操作</p><p>3.5 条件判断语句中，无论条件是否成立，都会进行预解释</p><p>3.6 return后面的语句不会进行预解释，但是return下面的，会进行预解释</p><h5 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h5><p>5.1 运算符：</p><p>算数&gt; 比较 &gt; 逻辑 &gt; 赋值</p><p>5.2 函数返回值出现undefined：</p><p>1 无return</p><p>2 return 后面没东西</p><p>5.3  上级作用域只跟函数在哪里开辟内存空间有关，与在哪里执行无关</p><p>6  练习</p><p>6.1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n=<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(n)</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>上面的结果输出值为 undefined。函数运行分析</p><p>1  函数运行时候，先解释关键字var和function的变量，方法中有var  n=9; 所以会先对n进行定义，但是不进行赋值操作。这个过程是函数预解释。</p><p>2 函数预解释完毕，开始按代码顺序执行函数，执行到alert(n).此时变量n由于函数的预解释作用，已经进行了变量声明，但未赋值。所以此时输出为undefined</p><p>3 继续执行代码 var n=9; 此时完成变量赋值。</p><p>6.2</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">23</span>,<span class="number">48</span>,<span class="number">98</span>,<span class="number">666</span>];</span><br><span class="line"> <span class="comment">//1.私有作用域 2.形参赋值 3.预解释 4.代码从上到下的执行</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">     a[<span class="number">0</span>]=<span class="number">123</span>;<span class="comment">//【123,48,98,666】</span></span><br><span class="line">     <span class="built_in">console</span>.log(a)</span><br><span class="line">     a=[];</span><br><span class="line">     a[a.length]=<span class="number">456</span>;</span><br><span class="line">     <span class="built_in">console</span>.log(a);<span class="comment">//[456]</span></span><br><span class="line"> &#125;</span><br><span class="line"> fn(a);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>6.3</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'fn'</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fn)</span><br><span class="line">    fn = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'i am inner'</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><p>当执行fn2时候，会输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'i am inner'</span>)&#125;</span><br></pre></td></tr></table></figure><p>函数解释：</p><p>当fn2执行时，在函数内部形成作用域，作用域内发生了变量预解释。function关键字的预解释不但有声明，而且有定义，所以可以输出函数内部定义的fn，而不是全局变量中的fn</p>]]></content>
      
      
      <categories>
          
          <category> javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预解释 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>告别</title>
      <link href="/2017/09/04/%E5%85%B3%E4%BA%8E%E5%91%8A%E5%88%AB/"/>
      <url>/2017/09/04/%E5%85%B3%E4%BA%8E%E5%91%8A%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>2017/09/01 去参加苏榭男友的葬礼  </p><a id="more"></a><p>送别会去的人很多，有的人是因为苏苏的关系，我也是其中之一。</p><p>许多人生命的散场突如其来，意外比明天更早一步与他们相见。</p><p>很久之前为他们的爱情感动过，嗯，或者说，每一位和世俗目光对抗的勇者都是直接赞叹的。</p><p>“我会一直爱你，直到死亡将我们分开”</p><p><img src="/img/miscellanea/Funeral.jpg" alt="Funeral"></p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> love </tag>
            
            <tag> 告别 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack-2</title>
      <link href="/2017/09/02/webpack-2/"/>
      <url>/2017/09/02/webpack-2/</url>
      
        <content type="html"><![CDATA[<p>webpack 配置 – 监听文件变化 开启自动刷新</p><h3 id="webpack’s-Watch-Mode"><a href="#webpack’s-Watch-Mode" class="headerlink" title="webpack’s Watch Mode"></a>webpack’s Watch Mode</h3><p>配置 –watch 开启观察模式</p><p>添加一个用于启动 webpack 的观察模式的 npm script</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"watch"</span>: <span class="string">"webpack --watch"</span>,</span><br></pre></td></tr></table></figure><p>当使用此命令 会监听到文件变动 webpack会自动重新打包编译文件重新生成bundle文件</p><a id="more"></a><p><img src="/img/webpack/webpack-watch.png" alt="watch"></p><p>当文件有变动的时候 会自动产生新的bundle文件</p><p><img src="/img/webpack/webpack-refresh.png" alt="watch"></p><p>但是唯一的缺陷是无法刷新浏览器 因此页面的刷新还需要用户手动刷新</p><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p>webpack-dev-server 提供了一个简单的 web 服务器，并且能够实时重新加载页面</p><p>webpack-dev-server主要是启动了一个使用express的Http服务器。它的作用主要是用来伺服资源文件</p><p>此外这个Http服务器和client使用了websocket通讯协议，原始文件作出改动后，webpack-dev-server会实时的编译，但是最后的编译的文件并没有输出到目标文件夹</p><p>你启动webpack-dev-server后，你在目标文件夹中是看不到编译后的文件的,实时编译后的文件都保存到了内存当中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  compress: <span class="literal">true</span>,</span><br><span class="line">  port: <span class="number">9000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上配置表示在 localhost:9090 下建立服务，将 dist 目录下的文件作为可访问文件。</p><h4 id="通过-通过CLI选项-来配置-webapck-dev-server"><a href="#通过-通过CLI选项-来配置-webapck-dev-server" class="headerlink" title="通过 通过CLI选项 来配置 webapck-dev-server"></a>通过 通过CLI选项 来配置 webapck-dev-server</h4><p>也就是在命令行启动方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --hot --inline --open</span><br></pre></td></tr></table></figure><p>那么webapck.config.js中配置如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  compress: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>–open</li></ul><p>表示自动开启一个浏览器去加载页面</p><h4 id="直接在-webapck-config-js-中配合参数"><a href="#直接在-webapck-config-js-中配合参数" class="headerlink" title="直接在 webapck.config.js 中配合参数"></a>直接在 webapck.config.js 中配合参数</h4><p>命令行中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --open</span><br></pre></td></tr></table></figure><p>那么webapck.config.js中配置如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  inline: <span class="literal">true</span>,</span><br><span class="line">  hot:<span class="literal">true</span>,</span><br><span class="line">  compress: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./index.html'</span>&#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注意plugin中这里添加HMR插件</p><h4 id="contentBase"><a href="#contentBase" class="headerlink" title="contentBase"></a>contentBase</h4><p>告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要 也就是本地服务器所加载的页面所在的目录</p><p><strong> devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先 </strong></p><p>默认情况下，将使用当前目录(所谓当前的目录就是在哪里运行webpack-dev-server这个命令的目录)作为提供内容的目录</p><p>但是你可以修改为其他目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contentBase: path.join(__dirname, <span class="string">'public'</span>)</span><br></pre></td></tr></table></figure><h4 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h4><p>表示一切服务都启用gzip 压缩</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><p>默认监听端口，如果省略，默认为”8080“</p><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>设置为true，当源文件改变时会自动刷新页面</p><h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>属性值为 Object</p><blockquote><p>如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。</p></blockquote><p>比如当前项目 koa搭建 运行端口为 localhost:3000</p><p>然后你的route 有一个接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">router.get(<span class="string">'/api/try'</span>, <span class="function"><span class="keyword">function</span> * (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.body = &#123;</span><br><span class="line">    code: <span class="number">9999999999999999999</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是前端用webpack启动 打开的端口是 9090  那么如果想通过 /api/try 接口接受信息 就可以配置 proxy</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">"/api"</span>: <span class="string">"http://localhost:3000"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果你发的请求是 /api/xxx 可以被<a href="http://localhost:3000/api/xxx" target="_blank" rel="noopener">http://localhost:3000/api/xxx</a> 接口捕获到</p><p>所以如果你的服务和页面是相同的接口  就不用配置proxy的</p><h4 id="hot"><a href="#hot" class="headerlink" title="hot"></a>hot</h4><p>表示重新加载改变的部分，如果HRM失败则刷新页面</p><ul><li>关于hot 以及 inline 参数</li></ul><p>‘inline’选项会为入口页面添加“热加载”功能，’hot’选项则开启“热替换HMR”功能，即尝试重新加载组件改变的部分（而不是重新加载整个页面）</p><p>如果两个参数都传入，当资源改变时，webpack-dev-server将会先尝试HRM（即热替换），如果失败则重新加载整个入口页面。</p><h3 id="自动刷新-Automatic-Refresh"><a href="#自动刷新-Automatic-Refresh" class="headerlink" title="自动刷新 Automatic Refresh"></a>自动刷新 Automatic Refresh</h3><h4 id="Iframe-mode"><a href="#Iframe-mode" class="headerlink" title="Iframe mode"></a>Iframe mode</h4><p>这种刷新处理方式 在网页中嵌入了一个 iframe ，将我们自己的应用注入到这个iframe当中去，因此每次你修改的文件后，都是这个iframe进行了reload当资源改变的时候会重新加载</p><p>开启这种刷新方式只需要通过 <a href="http://localhost:8081/webpack-dev-server/index.html" target="_blank" rel="noopener">http://localhost:8081/webpack-dev-server/index.html</a> 来访问你的项目就可以</p><p><img src="/img/webpack/iframe.png" alt="iframe"></p><p>每次更改数据 页面将会开启自动刷新</p><p><img src="/img/webpack/iframe2.png" alt="iframe"></p><p>页面中被插入一个 iframe 并且引入 live.bundle.js 文件</p><p>这个iframe页面会请求 live.bundle.js ,其中里面会新建一个 Iframe ，你的应用就被注入到了这个 Iframe 当中</p><p>live.bundle.js 中含有 socket.io 的 client 代码，这样它就能和 webpack-dev-server 建立的 http server 进行 websocket 通讯了，并根据返回的信息完成相应的动作</p><p><strong> iframe 引起页面自动刷新的机制为 </strong></p><p>因为我们的访问此页面的时候加载了live.bundle.js，其具有websocket的client代码，所以当websocket-dev-server服务端代码发生变化的时候会通知到这个页面，这个页面只是需要重新刷新iframe中的页面就可以了</p><h4 id="inline-mode"><a href="#inline-mode" class="headerlink" title="inline mode"></a>inline mode</h4><ul><li><p>命令行中使用 –inline</p></li><li><p>webapck 配置文件中使用 设置inline: true [感觉webpackV1好像不支持这种处理方式]</p></li></ul><p><strong> 每一个模式都是支持Hot Module Replacement的 </strong> 在HMR模式下，每一个文件都会被通知内容已经改变而不是重新加载整个页面。因此，在HMR执行的时候可以加载更新的模块，从而把他们注册到运行的应用里面。</p><h3 id="模块热替换-Hot-Module-Replacement"><a href="#模块热替换-Hot-Module-Replacement" class="headerlink" title="模块热替换(Hot Module Replacement)"></a>模块热替换(Hot Module Replacement)</h3><p>HMR 用于替换、添加或删除模块，无需重新加载整个页面</p><ul><li>HMR 与 chunkhash 的问题</li></ul><p>项目中有在输出项配置 filename 为 chunkhash</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  filename: <span class="string">`[name]-[chunkhash:8].js`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使用webpack 启动项目是可以的 但是如果是通过 webpack-dev-server –hot –inline 就会一直报错</p><p><img src="/img/webpack/dev-hash.png" alt="server"></p><p>原来是 热更新(HMR)不能和[chunkhash]同时使用</p><p><a href="http://ask.csdn.net/questions/258212" target="_blank" rel="noopener">chunkhash问题</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filename: <span class="string">`[name]-[hash].js`</span>,</span><br><span class="line">chunkFilename: <span class="string">`[name]-[hash].js`</span></span><br></pre></td></tr></table></figure><h4 id="HMR-的工作原理"><a href="#HMR-的工作原理" class="headerlink" title="HMR 的工作原理"></a>HMR 的工作原理</h4><ul><li>在应用程序中置换模块的步骤</li></ul><p>应用程序代码要求 HMR runtime 检查更新 -&gt; HMR 下载更新，然后通知应用程序代码 -&gt; 应用程序代码要求 HMR 进行处理去更新应用 -&gt;<br>HMR runtime（异步）应用更新</p><ul><li>在编译器中</li></ul><p>编译器(compiler)需要发出 “update”，以允许更新之前的版本到新的版本。”update” 由两部分组成：</p><p>更新后的 manifest(JSON)<br>一个或多个更新后的 chunk (JavaScript)</p><p>manifest 包括新的编译 hash 和所有的待更新 chunk 目录。每个更新 chunk 都含有对应于此 chunk 的全部更新模块（或一个 flag 用于表明此模块要被移除）的代码。</p><p>编译器确保模块 ID 和 chunk ID 在这些构建之间保持一致。通常将这些 ID 存储在内存中（例如，使用 webpack-dev-server 时），但是也可能将它们存储在一个 JSON 文件中。</p><p>*</p><h4 id="启用-HMR"><a href="#启用-HMR" class="headerlink" title="启用 HMR"></a>启用 HMR</h4><p>两种方式可以开启 webpack 的HMR 功能 上文已经提到过</p><ul><li><p>命令行添加参数 –hot</p></li><li><p>直接在配置文件中修改并添加 HMR 配置plugin  </p></li></ul><h5 id="HotModuleReplacementPlugin"><a href="#HotModuleReplacementPlugin" class="headerlink" title="HotModuleReplacementPlugin"></a>HotModuleReplacementPlugin</h5><p> 如果已经通过 HotModuleReplacementPlugin 启用了模块热替换(Hot Module Replacement)，则它的接口将被暴露在 module.hot 属性下面</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p>1 <a href="https://segmentfault.com/q/1010000007434045?_ea=1345250" target="_blank" rel="noopener">webpack-dev-server问题</a></p><p>2 <a href="https://www.cnblogs.com/vajoy/p/7000522.html" target="_blank" rel="noopener">webpack 插件拾趣 (1) —— webpack-dev-server</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书笔记-js高程</title>
      <link href="/2017/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-js%E9%AB%98%E7%A8%8B/"/>
      <url>/2017/09/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-js%E9%AB%98%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>面向对象[Obecjt-Oriented   简称OO]语言有一个标志，那就是【类】的概念，通过类可以创建多个具有任意属性和方法的对象。但是JS中其实是没有</p><p>类的概念的，所以js中的对象与其他语言中的类不同。</p><p>简单来说，js中的对象是一组无序的名值对，而其中的值是对象或者函数。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><a id="more"></a><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建一个对象，可以通过new一个实例或者使用对象字面量的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name=<span class="string">'tom'</span>;</span><br><span class="line"><span class="comment">// 或者使用对象字面量</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  name=<span class="string">'tom'</span>,age=<span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然以上两个方式都能创建对象，但是如果通过这些方式创建大量对象，会产生大量冗余代码。为此开始使用别的方式来创建对象。</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createP</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> per=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  per.name=name;</span><br><span class="line">  <span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂模式就是一个函数的封装</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>通过创建自定义构造函数，定义对象类型的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Per</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数相对于工厂模式，并没有显示创建对象，直接将方法属性赋值this，无return语句。就相当于系统自动进行了 var  和return 的过程。</p><p>按照惯例，构造函数的首字母大写。</p><p>要创建一个新实例，必须通过new操作符。这种方式实际会经历以下过程</p><p>创建一个新对象 &gt; 将构造函数作用域赋值给新对象 所以this为当前实例 &gt; 执行构造函数中代码 即为新对象添加属性方法 &gt; 返回新对象</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>我们创建的每一个函数都有一个prototype属性 这其实是一个指针 指向创建出当前实例的那个类的原型对象</p><p>使用原型对象的好处是，在原型对象上添加的属性和方法是所有实例都可以共享的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"><span class="title">Person</span>.<span class="title">prototype</span>.<span class="title">say</span>=<span class="title">function</span> (<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">'hello'</span>) &#125;</span><br></pre></td></tr></table></figure><p>通过这个方式，以后new出来的实例都可以使用say方法了</p><h3 id="关于类-原型-实例之间的关系"><a href="#关于类-原型-实例之间的关系" class="headerlink" title="关于类 原型 实例之间的关系"></a>关于类 原型 实例之间的关系</h3><p>构造函数也就是类，自带一个prototype属性，这是类的原型对象。</p><p><strong> 每一个原型对象自带一个constructor的属性 指向当前类 </strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor=Person;</span><br></pre></td></tr></table></figure><p>当通过构造函数new出一个实例后，<strong> 此实例会自带一个<strong>proto</strong>属性，指向当前实例所属类的原型 </strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.__proto__ = Person.prototype;</span><br></pre></td></tr></table></figure><p>在ES6中 新增了一个Object.getPrototypeOf() 方法，可以返回 实例的<strong>proto</strong>的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以在ES6中 可以使用Object.getPrototypeOf() 获取实例的原型对象</p><p>实例在查找某个属性或方法时，会先找私有属性，然后向上查找原型对象 一直最后找到基类Object为止</p><p>【虽然可以通过实例访问保存在原型中的值  但是不能通过实例重写原型中的属性或者方法】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name=<span class="string">'tom'</span>;</span><br><span class="line"><span class="keyword">var</span> per1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> per2 = <span class="keyword">new</span> Person();</span><br><span class="line">per1.name=<span class="string">'jack'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(per1.name);<span class="comment">// jack</span></span><br><span class="line"><span class="built_in">console</span>.log(per2.name);<span class="comment">// tom</span></span><br></pre></td></tr></table></figure><p>以上例子表示，在实例上添加一个同名属性，<strong> 会阻断向原型上的查找，</strong>  但是不会覆盖原型中属性。</p><p>【即使将此同名属性值设为null    也只会在实例中设置该属性 而不会恢复指向原型的链接 不过可以使用delete操作符完全删除实例属性 从而重新访问原型中的属性】</p><h3 id="属性判断"><a href="#属性判断" class="headerlink" title="属性判断"></a>属性判断</h3><p>4.1 hasOwnPrototype  判断私有属性</p><p>使用此方法可以判断一个属性是存在于实例中还是原型中   若给定属性存在于实例中 返回true</p><p>4.2 in 操作符</p><p>无论是私有属性还是共有属性 都可以使用in</p><p>【结合两者 写一个判断是公有属性的判断】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">common</span>(<span class="params">object,attr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (attr <span class="keyword">in</span> object) &amp;&amp; !object.hasOwPprototype(attr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 原型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>图片上传</title>
      <link href="/2017/08/31/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
      <url>/2017/08/31/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="File-图片文件上传到本地"><a href="#File-图片文件上传到本地" class="headerlink" title="File 图片文件上传到本地"></a>File 图片文件上传到本地</h2><p>通过input点击 选择图片上传</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">changeInput = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>)</span><br><span class="line">  <span class="keyword">let</span> src = input.files[<span class="number">0</span>]</span><br><span class="line">  <span class="comment">// 这里拿到一个File对象</span></span><br><span class="line">  src = <span class="built_in">window</span>.URL.createObjectURL(file)</span><br><span class="line">  <span class="comment">// 拿到Blob格式的图片了 就可以处理预览操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传到七牛"><a href="#上传到七牛" class="headerlink" title="上传到七牛"></a>上传到七牛</h2><p>项目中的有些图片被托管到七牛中 关于七牛的介绍请自行百度</p><p>我们的项目中封装的图片上传到七牛的方法 是传递一个File格式的参数  但是我们在前端获取的图片 确实是一个base64的格式</p>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件处理 </tag>
            
            <tag> html5 </tag>
            
            <tag> 图片上传 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>canvas,blob,file,base64格式的转换</title>
      <link href="/2017/08/30/canvas-blob-file-base64%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
      <url>/2017/08/30/canvas-blob-file-base64%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><h3 id="canvas-gt-DataURL"><a href="#canvas-gt-DataURL" class="headerlink" title="canvas -&gt; DataURL"></a>canvas -&gt; DataURL</h3><p>这个可以使用 canvas本身提供的方法来处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.toDataURL(<span class="string">'image/png'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="canvas-gt-blob"><a href="#canvas-gt-blob" class="headerlink" title="canvas -&gt; blob"></a>canvas -&gt; blob</h3><p>这个可以使用 canvas本身提供的方法来处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.toBlob(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不过这个方法在iOS中不被支持</p><p>也可以借助一些第三方插件</p><p><a href="https://github.com/blueimp/JavaScript-Canvas-to-Blob" target="_blank" rel="noopener">JavaScript-Canvas-to-Blob</a></p><h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><h3 id="base64-gt-blob"><a href="#base64-gt-blob" class="headerlink" title="base64 -&gt; blob"></a>base64 -&gt; blob</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertBase64UrlToBlob</span>(<span class="params">urlData</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bytes = <span class="built_in">window</span>.atob(urlData.split(<span class="string">','</span>)[<span class="number">1</span>])   <span class="comment">//去掉url的头，并转换为byte</span></span><br><span class="line">  <span class="comment">//处理异常,将ascii码小于0的转换为大于0</span></span><br><span class="line">  <span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(bytes.length)</span><br><span class="line">  <span class="keyword">var</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">    ia[i] = bytes.charCodeAt(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob( [ab] , &#123;<span class="attr">type</span> : <span class="string">'image/png'</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>  这里传入的参数 urlData 是base64格式的  但是是不带有头部的 因此在函数内部做了处理  </strong></p><ul><li><p>window.btoa() 编码一个可能在传输过程中出现问题的数据</p></li><li><p>window.atob() 将使用window.btoa方法的数据进行解码</p></li></ul><p>这两个方法的支持情况还不错</p><p><img src="/img/btoa.png" alt="btoa&amp;atob"></p><h3 id="base64-gt-file"><a href="#base64-gt-file" class="headerlink" title="base64 -&gt; file"></a>base64 -&gt; file</h3><p>将图片转化为file格式 其实是模拟了一个form表单的提交 但是这里需要将base64先转化为Blob格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">base64ToFile</span> (<span class="params">base64</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> form = <span class="keyword">new</span> FormData()</span><br><span class="line">  formData.append(<span class="string">'photo'</span>, Base64UrlToBlob(base64))</span><br><span class="line">  formData.append(<span class="string">'uid'</span>, uid)</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'upload'</span>,</span><br><span class="line">    type: <span class="string">'POST'</span>,</span><br><span class="line">    data: formData,</span><br><span class="line">    processData: <span class="literal">false</span>,  <span class="comment">// 不处理数据</span></span><br><span class="line">    contentType: <span class="literal">false</span>   <span class="comment">// 不设置内容类型</span></span><br><span class="line">  &#125;).done(<span class="function">(<span class="params">&#123;photoUrl&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 得到截图上传到七牛的URL</span></span><br><span class="line">    <span class="built_in">console</span>.log(photoUrl)</span><br><span class="line">    resolve(&#123;photoUrl&#125;)</span><br><span class="line">  &#125;).fail(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用的append方法是FormData对象中的方法</p><blockquote><p>通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同</p></blockquote><h2 id="DataURL"><a href="#DataURL" class="headerlink" title="DataURL"></a>DataURL</h2><h3 id="DataURL-展示图片"><a href="#DataURL-展示图片" class="headerlink" title="DataURL 展示图片"></a>DataURL 展示图片</h3><p>将DataURL 图片绘制在canvas中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  canvas.drawImage(img)</span><br><span class="line">&#125;</span><br><span class="line">img.src = dataurl</span><br></pre></td></tr></table></figure><h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><h3 id="File-gt-dataUrl"><a href="#File-gt-dataUrl" class="headerlink" title="File -&gt; dataUrl"></a>File -&gt; dataUrl</h3><h3 id="File-gt-Blob"><a href="#File-gt-Blob" class="headerlink" title="File -&gt; Blob"></a>File -&gt; Blob</h3><p>两种方式全部借助 FileReader 对象的方法  参见本站文章  <a href="https://mengxxself.github.io/2017/08/25/%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/" target="_blank" rel="noopener">《关于文件的那点事》</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> canvas </tag>
            
            <tag> file </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack-1</title>
      <link href="/2017/08/27/webpack-1/"/>
      <url>/2017/08/27/webpack-1/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么使用webpack"><a href="#为什么使用webpack" class="headerlink" title="为什么使用webpack"></a>为什么使用webpack</h2><p>现在的应用大多是webAPP的形式 通常都是单页面应用 每一个视图异步加载文件信息 在页面初始化过程中 会加载很多的JavaScript代码</p><p>页面中所需的资源通过增量加载的方式运行到浏览器 那么在开发环境中如何很好的将这些碎片资源组织起来 更加优雅迅速的在浏览器中展现 就需要一个模块化系统的支持</p><a id="more"></a><h3 id="模块化系统的演进"><a href="#模块化系统的演进" class="headerlink" title="模块化系统的演进"></a>模块化系统的演进</h3><p>模块系统主要解决模块的定义 依赖 导入</p><h4 id="常用的模块系统"><a href="#常用的模块系统" class="headerlink" title="常用的模块系统"></a>常用的模块系统</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./jquery.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'./zeptojs'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种是最原始的模块加载方式（将每一个js文件看做一个模块） 这种加载方式有很多不足之处</p><ul><li>由于是暴露在全局作用域中 所以很容易造成变量冲突</li><li>文件的加载顺序是js文件引入顺序</li><li>开发人员需要处理模块与各个代码库的依赖关系</li></ul><h4 id="前端模块加载"><a href="#前端模块加载" class="headerlink" title="前端模块加载"></a>前端模块加载</h4><p>前端模块是需要加载到浏览器中</p><p>预想的加载方式有两种 一种为将所有模块打包为一个文件 一次性将其加载到页面中 但这种处理方式会导致流量浪费、初始化过程慢 或者每一个模块都单独请求 但是这样会导致请求次数发送或多</p><h2 id="webpack-介绍"><a href="#webpack-介绍" class="headerlink" title="webpack 介绍"></a>webpack 介绍</h2><blockquote><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用</p></blockquote><p>webpack 处理文件方式是  把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件</p><p>webpack 在命令行中打包项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack &#123;entry file&#125; &#123;build file&#125;</span><br></pre></td></tr></table></figure><p>但是一般我们都是在项目中通过一个配置文件来将所需的webpack信息进行完整的配置</p><h3 id="启动webpack"><a href="#启动webpack" class="headerlink" title="启动webpack"></a>启动webpack</h3><p>在命令行执行编译命令</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webapck</span><br></pre></td></tr></table></figure><p>这条命令会自动引用webpack.config.js文件中的配置选项</p><p>如果你不是在全局安装的 webpack 就需要另行指定路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack --config webpack.config.js</span><br></pre></td></tr></table></figure><p>或者在package.json中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span>: <span class="string">"webpack"</span>,</span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack --config webpack.config.js"</span></span><br></pre></td></tr></table></figure><p>命令行执行此命令后 可以看到有bundle文件生成</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>chunk：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module</p><h2 id="webpack-基本配置"><a href="#webpack-基本配置" class="headerlink" title="webpack 基本配置"></a>webpack 基本配置</h2><p>在项目中新建 webpack.config.js 的文件 用于配置webpack</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="context-上下文"><a href="#context-上下文" class="headerlink" title="context 上下文"></a>context 上下文</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context: path.resolve(__dirname, <span class="string">"app"</span>)</span><br></pre></td></tr></table></figure><p>绝对路径，用于从配置中解析入口起点(entry point)和 loader</p><p>默认值是当前目录</p><h3 id="entry-入口"><a href="#entry-入口" class="headerlink" title="entry 入口"></a>entry 入口</h3><p>Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js</p><p>入口文件</p><table><thead><tr><th>属性名</th><th>参数类型</th></tr></thead><tbody><tr><td>entry</td><td>String Array Object</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  entry: <span class="string">'./index.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  entry: [<span class="string">'./index.js'</span>, <span class="string">'./main.js'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: <span class="string">'./index.js'</span>,</span><br><span class="line">    home: <span class="string">'./home.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当为数组时</p><blockquote><p>向 entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用</p></blockquote><p>也就是 将所有的文件会打包到最后一个chunk文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  entry: [<span class="string">'./index.js'</span>, <span class="string">'./main.js'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现dist中只会生成一个文件</p><p><img src="/img/webpack/array.png" alt="bubdle"></p><p>当为对象格式时 Webpack会为每一个html生成一个 bundle 文件  这是应用程序中定义入口的最可扩展的方式</p><blockquote><p>在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载</p></blockquote><p><img src="/img/webpack/object.png" alt="bubdle"></p><ul><li>关于生成的 bundle 文件</li></ul><p><img src="/img/webpack/hash.png" alt="bubdle"></p><p>发现如果文件中有代码变动 则这里的哈希值就会发生变化 表示webpack打包之后的bundle.js文件也变化了</p><h4 id="vendor"><a href="#vendor" class="headerlink" title="vendor"></a>vendor</h4><p>分离第三方应用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'jquery'</span>, <span class="string">'react'</span>, <span class="string">'redux'</span>],</span><br><span class="line">    home: <span class="string">'./home.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分离第三方应用主要是因为vendor.js 的内容基本上很少更新，所以如果下一次更改了 app.js 的内容时，vendor.js 仍然在浏览器的缓存中，那么用户就只需要重新下载 app.js 就可以了</p><p>注意如果这里配置了vendor属性 需要在plugins只能怪添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'vendor'</span>,</span><br><span class="line">  filename: <span class="string">'vendor-[hash].min.js'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是 在测试中发现 虽然vendor中的是第三方代码 不经常更新 但是每次有其余代码更新 都会生成一个新的vendor文件 哈希值发生变化</p><p><img src="/img/webpack/vendor.png" alt="vendor"></p><p><a href="https://github.com/webpack/webpack/issues/1315" target="_blank" rel="noopener">关于此问题的讨论</a></p><p>然后将配置文件修改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  vendor: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>],</span><br><span class="line">  index: path.resolve(<span class="string">'views'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(<span class="string">'public'</span>),</span><br><span class="line">  filename: <span class="string">`[name]-[chunkhash:8].js`</span>,</span><br><span class="line">  chunkFilename: <span class="string">`[name]-[chunkhash:8].js`</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: [<span class="string">'vendor'</span>, <span class="string">'manifest'</span>],</span><br><span class="line">  &#125;)  </span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>manifest是为了解决vendor再次编译的问题</li></ul><p>公共文件被编译为vendor.js 并且不再变化  但是还会生成一个manifest.js 这个会一直有哈希值变化生成新文件</p><p><strong> 注意 </strong></p><p>如果此时有在plugin中配置热加载</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br></pre></td></tr></table></figure><p>就会发现一直报错</p><p><img src="/img/webpack/vendor2.png" alt="vendor"></p><p>是因为在 热更新(HMR)不能和[chunkhash]同时使用 所以可以把 HMR 注释掉</p><h3 id="output-输出"><a href="#output-输出" class="headerlink" title="output 输出"></a>output 输出</h3><p>webpack的输出配置 控制 webpack 如何向硬盘写入编译文件</p><blockquote><p>即使可以存在多个入口起点，但只指定一个输出配置。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    path:  path.resolve(<span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="path"><a href="#path" class="headerlink" title="path"></a>path</h4><p>此选项规定了文件被写入硬盘的位置</p><p>也可以采用绝对路径的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br></pre></td></tr></table></figure><h4 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h4><p>进行文件的命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  home: <span class="string">"./home.js"</span>,</span><br><span class="line">  server: <span class="string">"./server.js"</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: <span class="string">'build'</span>,</span><br><span class="line">  filename: <span class="string">'[name].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称</p></blockquote><p>[name] 被 chunk 的 name 替换 也就是entry的对象键名 则生成的文件为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/home.js 与  build/server.js</span><br></pre></td></tr></table></figure><h4 id="name-id-and-hash"><a href="#name-id-and-hash" class="headerlink" title="name], [id] and [hash]"></a>name], [id] and [hash]</h4><p>如果考虑缓存问题，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）</p><p>webpack可以把一个哈希值添加到打包的文件名中，将特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: <span class="string">'build'</span>,</span><br><span class="line">  filename: <span class="string">'[name]-[hash].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h4><p>通常用来进行开发者模式与正式环境的路径替换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line"> path: path.resolve(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line"> publicPath: isDev ? <span class="string">'http://localhost:9333/'</span> : <span class="string">'/'</span>,</span><br><span class="line"> filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在本地开发者模式中 加载一个图片的方式为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bg</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'../img/webpack/bg.png'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在正式环境中 路径可能是CDN的路径 所以需要对文件中的路径进行修改</p><p>因此借助环境变量 来处理此问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当前是生产模式，使用前者，否则[也就是本地开发者模式]使用localhost:3000</span></span><br><span class="line"><span class="keyword">const</span> ASSET_PATH = isProd ? <span class="string">`<span class="subst">$&#123;QNCDN&#125;</span>/project/`</span> : <span class="string">'http://locahost:3000'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: ASSET_PATH</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/webpack/publicPath.png" alt="publicPath"></p><p>此属性 有默认值 为’’</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publicPath: <span class="string">''</span></span><br></pre></td></tr></table></figure><p>publicPath参数跟path参数的区别是：path参数其实是针对本地文件系统的，而publicPath则针对的是浏览器；</p><p>因此，publicPath既可以是一个相对路径，如示例中的’’，也可以是一个绝对路径如<a href="http://www.xxxxx.com/。" target="_blank" rel="noopener">http://www.xxxxx.com/。</a></p><p>一般来说，我还是更推荐相对路径的写法，这样的话整体迁移起来非常方便。那什么时候用绝对路径呢？其实也很简单，当你的html文件跟其它资源放在不同的域名下的时候，就应该用绝对路径了，这种情况非常多见于后端渲染模板的场景</p><h4 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h4><p>chunkFilename 参数指定的是除入口文件外的chunk（这些chunk通常是由于webpack对代码的优化所形成的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chunkFilename: <span class="string">`[name]-[chunkhash:8].js`</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">chunkFilename: <span class="string">`[name]-[hash].js`</span></span><br></pre></td></tr></table></figure><h3 id="module-amp-amp-loaders-模块加载器"><a href="#module-amp-amp-loaders-模块加载器" class="headerlink" title="module &amp;&amp; loaders 模块加载器"></a>module &amp;&amp; loaders 模块加载器</h3><p>决定了项目中如何处理不同类型的模块</p><blockquote><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件 loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！</p></blockquote><p>简而言之  loaders 用以将浏览器无法解析的 全部转化为可解析的代码</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>loader 会以数组逆序运行。这意味着 css-loader 会在 style-loader 之前运行</p><h4 id="处理style"><a href="#处理style" class="headerlink" title="处理style"></a>处理style</h4><p>css-loader 和 style-loader，二者处理的任务不同</p><p>css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能</p><p>style-loader将所有的计算后的样式加入页面中，二者组合在一起使能够把样式表嵌入webpack打包后的JS文件中</p><h5 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h5><h5 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h5><h5 id="postcss-loader"><a href="#postcss-loader" class="headerlink" title="postcss-loader"></a>postcss-loader</h5><p>可以自动补全css中那些兼容性前缀</p><p><a href="https://github.com/postcss/postcss" target="_blank" rel="noopener">github</a></p><ul><li>配置Module</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">        use: [<span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我的项目中是将CSS与js抽离开的 所以使用了 ExtractTextPlugin 如果你不需要这么做 可以直接配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>但是需在目录中添加一个文件 postcss.config.js 内容为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以成功的添加样式各种浏览器前缀了</p><p>关于参数 这里可以传入一个对象作为参数 用于指定哪些浏览器来使用postcss</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">      browsers: [<span class="string">'last 2 versions'</span>, <span class="string">'&gt; 5%'</span>, <span class="string">'last 5 iOS versions'</span>, <span class="string">'Android &gt;= 3'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/webpack/webpack-plugin-css.png" alt="img"></p><p>如果不在这里写 还可以配置在package.json 中 添加支持哪些浏览器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"browserslist"</span>: [</span><br><span class="line">  <span class="string">"defaults"</span>,</span><br><span class="line">  <span class="string">"not ie &lt; 11"</span>,</span><br><span class="line">  <span class="string">"last 2 versions"</span>,</span><br><span class="line">  <span class="string">"&gt; 1%"</span>,</span><br><span class="line">  <span class="string">"iOS 7"</span>,</span><br><span class="line">  <span class="string">"last 3 iOS versions"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li><strong> 坑 </strong></li></ul><p>网上有的文章是将 autoprefixer 配置在 plugin中 这样写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者是添加一个对象参数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">  browsers: [<span class="string">'last 2 versions'</span>, <span class="string">'&gt; 5%'</span>, <span class="string">'last 5 iOS versions'</span>, <span class="string">'Android &gt;= 3'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是我没有调试出结果来 所以采用了 添加 postcss.config.js 文件的形式</p><h5 id="配置-module-rules"><a href="#配置-module-rules" class="headerlink" title="配置 module.rules"></a>配置 module.rules</h5><p>创建模块时，匹配请求的规则数组</p><p>这些规则能够修改模块的创建方式 这些规则能够对模块(module)应用加载器(loader)，或者修改解析器(parser)</p><p>允许你在 webpack 配置中指定多个 loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: <span class="string">'css-loader'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="attr">use</span>: <span class="string">'ts-loader'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者 使用多个loader解析同一个类型的文件 use 这里就可以配置数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            modules: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://doc.webpack-china.org/development/how-to-write-a-loader" target="_blank" rel="noopener">如何编写loader</a></p><h4 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(gif|png|jpe?g|svg)$/</span>,</span><br><span class="line">  include: path.resolve(__dirname, <span class="string">'component'</span>),</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">'file-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: <span class="string">`[name]-[hash:8].[ext]`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后图片格式就成了这样子了</p><p><img src="/img/webpack/webpack-plugin-img.png" alt="img"></p><h4 id="配置-module-noParse"><a href="#配置-module-noParse" class="headerlink" title="配置 module.noParse"></a>配置 module.noParse</h4><p>防止 webpack 解析那些任何与给定正则表达式相匹配的文件</p><p>忽略的文件不应该被 import, require, define 或者任何其他导入机制调用</p><p>用这个忽略大型库文件(library)可以提高构建性能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  noParse: <span class="regexp">/jquery|backbone/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><blockquote><p>配置模块如何解析 解析规则也可以称之为检索，索引规则  配置索引规则能够缩短webpack的解析时间，提升打包速度</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [path.resolve(__dirname, <span class="string">"src"</span>), <span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先指定了我们自己的源文件目录，然后是 node_modules。这样子 Webpack 解决起来就会处理得更好一些，按照那个顺序先找我们的源文件目录，然后是已安装的 Node Modules</p><h4 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h4><blockquote><p>webpack 解析模块时应该搜索的目录</p></blockquote><p>可以使用绝对路径和相对路径</p><ul><li><p>如果使用相对路径将类似于 Node 查找 ‘node_modules’ 的方式进行查找 也就是现在当前文件中查找 然后去父级查找 层层向上查</p></li><li><p>如果使用绝对路径，将只在给定目录中搜索</p></li></ul><p>默认值是  node_modules  表示从 node_modules 文件夹中搜索所有组件中引入的模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules: [<span class="string">'node_modules'</span>]</span><br></pre></td></tr></table></figure><ul><li>手动添加到数组中</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules: [path.resolve(__dirname, <span class="string">'src'</span>), <span class="string">'node_modules'</span>]</span><br></pre></td></tr></table></figure><h4 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line"> extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置此属性 则可以在项目中 引入模块的时候 省略后缀名 因为webpack会根据这里配置的数组作为后缀  分别进行匹配</p><p>比如引入 jQuery.js 可以忽略后缀 .js  直接写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br></pre></td></tr></table></figure><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p>配置别名 在引入模块的时候 就可以使用更加简单的方式 例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Utility <span class="keyword">from</span> <span class="string">'../../src/utilities/utility'</span></span><br></pre></td></tr></table></figure><p>可以在alias中 配置好路径 然后 组件中使用别名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  Utilities: path.resolve(__dirname, <span class="string">'src/utilities/utility'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Utility <span class="keyword">from</span> <span class="string">'Utilities'</span></span><br></pre></td></tr></table></figure><p>项目中使用到别名的案例: 通过环境变量的不同 来区分引入模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line"> <span class="string">'react'</span>: needReact</span><br><span class="line"> ? path.resolve(__dirname, <span class="string">`../node_modules/react/dist/react<span class="subst">$&#123;isProd ? <span class="string">'.min'</span> : <span class="string">''</span>&#125;</span>.js`</span>)</span><br><span class="line"> : path.resolve(__dirname, <span class="string">`../node_modules/preact-compat/dist/preact-compat<span class="subst">$&#123;isProd ? <span class="string">'.min'</span> : <span class="string">''</span>&#125;</span>.js`</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在项目中模块引入是相同的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure><h4 id="mainFiles"><a href="#mainFiles" class="headerlink" title="mainFiles"></a>mainFiles</h4><p>属性值为数组格式  表示解析目录时要使用的文件名</p><p>默认值为 index</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainFiles: [<span class="string">'index'</span>]</span><br></pre></td></tr></table></figure><p>一般我们都是默认是index 所以想要引入某一个组件 可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> main <span class="keyword">from</span> <span class="string">'./components'</span></span><br></pre></td></tr></table></figure><p>不用具体书写为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> main <span class="keyword">from</span> <span class="string">'./components/index'</span></span><br></pre></td></tr></table></figure><p>如果你想使用main 来作为默认的文件名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mainFiles: [<span class="string">'main'</span>]</span><br></pre></td></tr></table></figure><h3 id="插件-Plugins"><a href="#插件-Plugins" class="headerlink" title="插件(Plugins)"></a>插件(Plugins)</h3><p>属性值为数组格式 数组元素是通过new 创建出来的每一个实例 表示 webpack 使用的插件列表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="CommonsChunkPlugin"><a href="#CommonsChunkPlugin" class="headerlink" title="CommonsChunkPlugin"></a>CommonsChunkPlugin</h4><p>当多个 bundle 共享一些相同的依赖，CommonsChunkPlugin 有助于提取这些依赖到共享的 bundle 中，来避免重复打包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">"common"</span>,</span><br><span class="line">    filename: <span class="string">"common.js"</span>,</span><br><span class="line">    minChunks: <span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在 output 的文件里，如果有任意模块加载了两次或更多（通过 minChunks 设置该值），它就会被打包进一个叫 commons.js 的文件里，后面你就可以在客户端缓存这个文件了</p><p>当然，这肯定会造成一次额外的请求，但是却避免了客户端多次下载相同库的问题。所以在很多场景下，这都是提升速度的举措</p><p><a href="https://doc.webpack-china.org/plugins" target="_blank" rel="noopener">常用的webpack插件列表</a></p><h3 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h3><p>多个文件打包到一个bundle文件中 只要其中一个出错 控制台的错误提示都将指到编译后的 bundle文件</p><p>source map 可以追踪代码错误 准确地知道错误来自于哪个源文件</p><p>需要配置 devtool 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: <span class="string">'inline-source-map'</span></span><br></pre></td></tr></table></figure><p>当没有配置devtool 属性的时候 倘若文件中有错误 则提示很粗暴</p><p><img src="/img/webpack/noSource.png" alt="noSource"></p><p>当配置了此属性 则可以明确指出错误文件位置</p><p><img src="/img/webpack/source.png" alt="noSource"></p><p>其实一般在生产环境 可以关掉 source map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: isProduction ? <span class="literal">null</span> : <span class="string">'inline-source-map'</span></span><br></pre></td></tr></table></figure><p>常用的属性值</p><table><thead><tr><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>source-map</td><td>在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度</td></tr><tr><td>cheap-module-source-map</td><td>在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便</td></tr><tr><td>eval-source-map</td><td>使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项</td></tr><tr><td>cheap-module-eval-source-map</td><td>这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点</td></tr></tbody></table><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>没用 html-webpack-plugin 插件之前 我们需要在html文件中手动引用我们之前经过webpack打包好的js文件 而此插件会自动生成html文件并将打包好的js插入文件</p><p>HtmlWebpackPlugin 简化创建服务于 webpack bundle 的 HTML 文件，尤其是对于在文件名中包含了 hash 值，而这个值在每次编译的时候都发生变化的情况 可以让这个插件来帮助你自动生成 HTML 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">     index: <span class="string">'./index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行相应命令后 在dist文件中生成一个 index.html 以及 index.bundle.js 文件</p><p>其中 index.html已经引入了script文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Webpack App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"index.bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果配置多个入口文件呢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">   index: <span class="string">'./index.js'</span>,</span><br><span class="line">   server: <span class="string">'./server.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现所有文件都被引入了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"index.bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"server.bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h4><table><thead><tr><th>属性</th><th>含义</th><th>属性值</th></tr></thead><tbody><tr><td>title</td><td>用来生成页面的 title 元素</td><td>无</td></tr><tr><td>filename</td><td>输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录</td><td>无</td></tr><tr><td>template</td><td>模板文件路径，支持加载器，比如 html!./index.html</td><td>无</td></tr><tr><td>inject</td><td>注入所有的资源到特定的 template 或者 templateContent 中，如果设置为 true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部，’head’ 将放置到 head 元素中</td><td>{true / ‘head’ / ‘body’ / false}</td></tr><tr><td>favicon</td><td>添加特定的 favicon 路径到输出的 HTML 文件中</td><td>无</td></tr><tr><td>minify</td><td>传递 html-minifier 选项给 minify 输出</td><td>{} / false</td></tr><tr><td>hash</td><td>如果为 true, 将添加一个唯一的 webpack 编译 hash 到所有包含的脚本和 CSS 文件，对于解除 cache 很有用</td><td>true /  false</td></tr><tr><td>cache</td><td>如果为 true, 这是默认值，仅仅在文件修改之后才会发布文件</td><td>true /  false</td></tr><tr><td>showErrors</td><td>如果为 true, 这是默认值，错误信息会写入到 HTML 页面中</td><td>true /  false</td></tr><tr><td>chunks</td><td>允许只添加某些模块 从entry 中定义的入口文件中选择</td><td>无</td></tr><tr><td>chunksSortMode</td><td>允许控制块在添加到页面之前的排序方式</td><td>‘none’ / ‘default’ / {function}-default:’auto’</td></tr><tr><td>excludeChunks</td><td>允许跳过某些块，(比如，跳过单元测试的块)</td><td>无</td></tr></tbody></table><h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><ul><li>指定title 以及模板</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">title</span>: <span class="string">'new html title'</span>, <span class="attr">template</span>: <span class="string">'./index.html'</span>&#125;),</span><br></pre></td></tr></table></figure><ul><li>如果有多个单页面 需要配置多个 HtmlWebpackPlugin 实例</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">title</span>: <span class="string">'new html title'</span>, <span class="attr">template</span>: <span class="string">'./server.html'</span>&#125;),</span><br></pre></td></tr></table></figure><ul><li>可以自己创建模板文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  title: <span class="string">'default template'</span>,</span><br><span class="line">  template: <span class="string">'myself.html'</span>,</span><br><span class="line">  inject: <span class="string">'body'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>编译 myself.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/img/webpack/html.png" alt="HtmlWebpackPlugin"></p><p><a href="http://www.cnblogs.com/haogj/p/5160821.html" target="_blank" rel="noopener">延伸阅读</a></p><h4 id="chunk-1"><a href="#chunk-1" class="headerlink" title="chunk"></a>chunk</h4><p>当指定了chunks属性，webpack会按照这个属性定义的数组，将数组中所有片段完成打包，并用script标签将打包的js插入到生成的页面中，没有在数组中的片段，则不插入页面</p><p>比如你的入口文件中有三个 但是只想让其中一个被打包引入文件 就可以使用chunk属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">   index: <span class="string">'./index.js'</span>,</span><br><span class="line">   server: <span class="string">'./server.js'</span></span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    chunks: [<span class="string">'server'</span>],</span><br><span class="line">    title: <span class="string">'cancan'</span>,</span><br><span class="line">    template: <span class="string">'./index.html'</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><p>有一个奇怪的问题 当我同时指定title 和 template [不是那种自己写的模板] 之后 这里书写的title值将失效</p><p><img src="/img/webpack/title2.png" alt="title"></p><p>也就是当你指定了 template 的时候 编译之后的模板使用的将是初始模板中的title 即使这里重新指定title也是无效的</p><p><img src="/img/webpack/title1.png" alt="title"></p><p>还有一个title失效问题</p><p>如果使用自己写的模板</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  title: <span class="string">'default template'</span>,</span><br><span class="line">  template: <span class="string">'myself.html'</span>,</span><br><span class="line">  inject: <span class="string">'body'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发现无法正确解析title部分</p><p><img src="/img/webpack/title3.png" alt="title"></p><p>原因是webpack.config.js的配置文件里面加了 html-loader，加了之后会正常解析html文件作为模版，就会直接把 &lt;%= htmlWebpackPlugin.options.title %&gt; 解析成字符串</p><p>如果有html-loader, 去掉就可以了</p><p><img src="/img/webpack/title4.png" alt="title"></p><p>所以使用别的模板进行解析</p><p><img src="/img/webpack/title5.png" alt="title"></p><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>设置了此属性为true 则在编译之后的文件中 引入的外部文件会加上哈希值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"server.bundle.js?81641f9e16cafa3fb408"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="minify"><a href="#minify" class="headerlink" title="minify"></a>minify</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minify: &#123;    </span><br><span class="line">   removeComments:<span class="literal">true</span>,    <span class="comment">//移除HTML中的注释</span></span><br><span class="line">   collapseWhitespace:<span class="literal">true</span>    <span class="comment">//删除空白符与换行符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/webpack/minify.png" alt="minify"></p><p>配置里的hash属性虽然可以给html引入的所以css文件后面加hash字符串，可以达到清除缓存的效果，但缺点是有些不需要清除缓存的css文件它也清除了</p><p>因为每次编译它会给所有css文件加同样的hash字符串。即时其他css没有变化。所以推荐用extract-text-webpack-plugin插件在编译提取css属性的时候用contenthash配置一下就可以解决这个问题</p><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>babel-loader的功能就是将项目中使用到ES6或者jsx的代码转化为es5,并且会把项目中所有的js文件都进行转化一遍，其中包括node_modules文件里面的内容</p><p>如果直接在webpack中配置babel</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      options: &#123; <span class="attr">presets</span>: [<span class="string">'es2015'</span>, <span class="string">'react'</span>] &#125;</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中</p><p>如果不在webpack中写入babel的options部分 则webpack会自动调用.babelrc里的babel配置选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    use: [&#123;</span><br><span class="line">      loader: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>一个简单的 .babelrc 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [ <span class="string">"es2015"</span>, <span class="string">"stage-0"</span>, <span class="string">"react"</span> ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"import"</span>,</span><br><span class="line">      [</span><br><span class="line">        &#123; <span class="string">"libraryName"</span>: <span class="string">"antd"</span>, <span class="string">"style"</span>: <span class="string">"css"</span> &#125;,</span><br><span class="line">        &#123; <span class="string">"style"</span>: <span class="string">"css"</span>,<span class="string">"libraryName"</span>: <span class="string">"antd-mobile"</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里控制台可能会报错  </p><p><img src="/img/webpack/webpack-babelrc.png" alt="babelrc"></p><p>根据<a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">api</a>  需要安装一个模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-plugin-<span class="keyword">import</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端自动化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react-hammer</title>
      <link href="/2017/08/27/react-hammer/"/>
      <url>/2017/08/27/react-hammer/</url>
      
        <content type="html"><![CDATA[<p>react-hammer是一个帮助实现移动端拖拽效果的插件</p><p><a href="https://www.npmjs.com/package/react-hammerjs" target="_blank" rel="noopener">npm</a></p><p><a href="https://github.com/JedWatson/react-hammerjs" target="_blank" rel="noopener">Github</a></p><a id="more"></a><p>其实React-hammer是基于<a href="http://hammerjs.github.io/" target="_blank" rel="noopener">hammer.js</a> 构建而成的一个更适合在React中使用的触摸插件</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let Hammer = require('react-hammerjs')</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Hammer</span> <span class="attr">onTap</span>=<span class="string">&#123;handleTap&#125;</span> <span class="attr">options</span>=<span class="string">&#123;options&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span>Tap Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">Hammer</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="六种手势支持"><a href="#六种手势支持" class="headerlink" title="六种手势支持"></a>六种手势支持</h2><p>react-hammer.js 支持六种手势操作</p><table><thead><tr><th>事件</th><th>手势</th></tr></thead><tbody><tr><td>pan</td><td>单手指滑动</td></tr><tr><td>tap</td><td>单手指点触</td></tr><tr><td>doubleTap</td><td>单手指双击</td></tr><tr><td>pinch</td><td>两个手指进行缩放动作</td></tr><tr><td>press</td><td>单手指下压</td></tr><tr><td>rotate</td><td>双手指旋转</td></tr><tr><td>swipe</td><td>单手指滑动</td></tr></tbody></table><p>默认状态下 是无法进行pinch 与 rotate 操作的 需要手动将其设置为TRUE</p><blockquote><p>As a default, the pinch and rotate events are disabled in hammer.js, as they would make actions on an element “blocking”.</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let options = &#123;</span><br><span class="line">  recognizers: &#123;</span><br><span class="line">    pinch: &#123; enable: true &#125;,</span><br><span class="line">    rotate: &#123; enable: true &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Hammer</span> <span class="attr">options</span>=<span class="string">&#123;options&#125;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Hammer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样才能进行缩放以及旋转动作</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>每一个事件的回调函数中都有一个事件对象 包含以下属性 (展示部分常用属性)</p><table><thead><tr><th>事件对象</th><th>含义</th></tr></thead><tbody><tr><td>type</td><td>事件类型</td></tr><tr><td>deltaX</td><td>X轴方向移动</td></tr><tr><td>deltaY</td><td>Y轴方向移动</td></tr><tr><td>distance</td><td>移动距离</td></tr><tr><td>direction</td><td>移动的方向</td></tr><tr><td>srcEvent</td><td>事件来源</td></tr><tr><td>rotation</td><td>多点触摸时已经完成的旋转（deg）</td></tr><tr><td>eventType</td><td>事件类型，匹配INPUT常量</td></tr></tbody></table><h2 id="pan-单手滑动"><a href="#pan-单手滑动" class="headerlink" title="pan 单手滑动"></a>pan 单手滑动</h2><table><thead><tr><th>事件</th><th>含义</th></tr></thead><tbody><tr><td>pan</td><td>单手指滑动 整个滑动周期</td></tr><tr><td>panstart</td><td>开始滑动</td></tr><tr><td>panmove</td><td>滑动</td></tr><tr><td>panend</td><td>滑动结束</td></tr><tr><td>pancancel</td><td>滑动取消</td></tr></tbody></table><p>默认只能进行水平方向的滑动  <strong> 无法处理垂直方向的滑动  </strong>    因此需要手动添加属性  direction</p><p>npm 中这样说道</p><blockquote><p>If you provide the prop direction the pan and swipe events will support Hammer.DIRECTION_(NONE/LEFT/RIGHT/UP/DOWN/HORIZONTAL/VERTICAL/ALL).</p></blockquote><p>因此我就这么写的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Hammer</span> <span class="attr">direction</span>=<span class="string">&#123;DIRECTION_ALL&#125;</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Hammer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而并没有效果 之后查看issue 发现实际是这么处理</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Hammer</span> <span class="attr">direction</span>=<span class="string">'DIRECTION_ALL'</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">Hammer</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong> 关于 pancancel </strong></p><p>个人感觉应该是在快速拖动导致手势丢失的时候 会触发此事件发生 然而测试中并没有发现有什么用 因为一直会被 panend 被捕捉而不是 pancancel</p><h3 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h3><p>此函数会一直被执行 从整个滑动开始 正在滑动 滑动结束  </p><p>元素跟随手指滑动变动位置的原理是 获取元素初始位置 + 手指滑动距离 然后在手指抬起瞬间 更新元素初始位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> eleLeft = startX + deltaX</span><br></pre></td></tr></table></figure><p><strong>  结束手指滑动时候 更新元素位置 </strong></p><p>之前一直是在 Panend 中处理这个问题 但是发现实际页面拿到的left数据  一旦发生一次滑动结束 再次滑动的时候  里面的值就是undefined  </p><p>调试很久之后 将事件处理到 pan 事件中</p><p>通过监听事件对象的 eventType === 4 来判断词此时是要结束滑动 然后更新元素初始位置</p><p><strong>  有一个坑  </strong></p><p>当手指离开屏幕 也就是结束滑动的时候    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不触发方向运动 也就是手指离开的时候</span></span><br><span class="line"><span class="keyword">if</span> (direction === <span class="number">1</span>) &#123;</span><br><span class="line">  end = translateX</span><br><span class="line">  topEnd = translateY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不属于任何一个判断条件  但是此时也要处理 左 上 的值  否则也会发现下次出现undefined</p><p><strong> 建议不要使用定位变动元素位置 </strong></p><p>最开始通过position将元素进行定位 在滑动过程中更改left top 坐标点  但是这种处理方式中 元素滑动并不流畅 体验性很差</p><p>可以通过transform来移动元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: <span class="string">`translateX(<span class="subst">$&#123;translateX&#125;</span>px) translateY(<span class="subst">$&#123;translateY&#125;</span>px)`</span>,</span><br></pre></td></tr></table></figure><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><table><thead><tr><th>事件</th><th>含义</th></tr></thead><tbody><tr><td>pinch</td><td>两个手指缩放 整个缩放周期</td></tr><tr><td>pinchstart</td><td>开始滑动</td></tr><tr><td>pinchIn</td><td>缩小</td></tr><tr><td>pinchOut</td><td>放大</td></tr><tr><td>PinchEnd</td><td>缩放取消</td></tr><tr><td>PinchCancel</td><td>滑动取消</td></tr></tbody></table><p>缩放监听的是两个手指捏合的动作</p><p>元素缩小</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pinchIn () &#123;</span><br><span class="line">  <span class="keyword">let</span> width = <span class="keyword">this</span>.state.width - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> height = <span class="keyword">this</span>.state.height - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素放大</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pinchOut () &#123;</span><br><span class="line">  <span class="keyword">let</span> width = <span class="keyword">this</span>.state.width + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> height = <span class="keyword">this</span>.state.height + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于手指捏合速度很快 所以这里直接将元素进行宽度与长度的增减</p><p><strong> 最好不要将元素大小变化的处理放入 onPinch 事件 防止手势丢失导致元素一直放大或者缩小 </strong></p><h3 id="旋转-rotate"><a href="#旋转-rotate" class="headerlink" title="旋转 rotate"></a>旋转 rotate</h3><p>hammer.js官网中提供的 <a href="http://hammerjs.github.io/#try-it" target="_blank" rel="noopener">旋转案例</a> 中  通过判断两个手指之间的角度差 来更改元素旋转角</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onRotate (ev) &#123;</span><br><span class="line">  transform.angle = initAngle + ev.rotation</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样是有一个问题如果最开始两个手指之间不在同一个水平线上 同样检测到两个手指之间的差值 元素会马上发生转动</p><p>所以这个属性不能准确读取到手指旋转角度</p><p>测试中发现 函数中事件对象 ev 有一个 srcEvent 参数  它也是一个对象 里面也有一个 rotation 属性 这个真正的表示了每一次手指旋转的角度值</p><p><strong> 此处有坑 只在iOS中有此属性 </strong></p><p>所以更改为使用此属性值来进行元素的旋转效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">handleRotate (ev) &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;startRotate&#125; = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">let</span> &#123;deltaTime, srcEvent&#125; = ev</span><br><span class="line">  <span class="comment">// 点触事件  时间太短不去触发旋事件</span></span><br><span class="line">  <span class="keyword">if</span> (deltaTime &lt; <span class="number">100</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> &#123;rotation = <span class="string">''</span>&#125; = srcEvent || &#123;&#125; <span class="comment">// 每次手指旋转的角度</span></span><br><span class="line">  <span class="keyword">let</span> end</span><br><span class="line">  <span class="keyword">if</span> (rotation) &#123;</span><br><span class="line">    <span class="comment">// 如果存在则表示是在iOS中 rotation 从srcEvent 中获取 表示每一次旋转的角度</span></span><br><span class="line">    end = startRotate + rotation</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按压-press"><a href="#按压-press" class="headerlink" title="按压 press"></a>按压 press</h3><table><thead><tr><th>事件</th><th>含义</th></tr></thead><tbody><tr><td>press</td><td>按压周期</td></tr><tr><td>pressUp</td><td>按压结束 手指抬起</td></tr></tbody></table><ul><li>旋转的补充方案</li></ul><p>由于在安卓机中没有拿到每一次旋转角度 因此使用plan B 通过添加两个按钮 当点击按钮或者长按按钮 可以进行图片的旋转</p><p>按压过程 通过开启定时器 来不断旋转目标元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  old--</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">rotateArg</span>: old&#125;)</span><br><span class="line">&#125;, <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p>在按压结束的时候 清除定期器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handlePressUp () &#123;</span><br><span class="line">  timer = <span class="built_in">window</span>.clearInterval(timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> bug 处理  手势并发 导致不停旋转 </strong></p><p>后来发现 如果在点击旋转按钮的时候 同时触发了别的手势 比如滑动 那么一旦手指离开屏幕 会发现元素会一直转个不停</p><p>这是因为定时器的清除操作只写在了 PressUp 这个手势中 而多手势的时候 有时候会读不到此事件</p><p>修正措施： 在每一种手势结束的时候 都清除一次定时器 比如 tapEnd 、 pinchEnd等</p>]]></content>
      
      
      <categories>
          
          <category> 第三方插件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js实现截屏效果</title>
      <link href="/2017/08/26/js%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%B1%8F%E6%95%88%E6%9E%9C/"/>
      <url>/2017/08/26/js%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%B1%8F%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>项目中需要一个截屏的效果 因此尝试了两个不错的第三方截屏插件</p><h2 id="html2canvas"><a href="#html2canvas" class="headerlink" title="html2canvas"></a>html2canvas</h2><a id="more"></a><p><a href="http://html2canvas.hertzen.com/index.html" target="_blank" rel="noopener">官网</a></p><p><a href="https://github.com/niklasvh/html2canvas" target="_blank" rel="noopener">Github</a></p><p>基本使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">html2canvas(<span class="built_in">document</span>.getElementById(<span class="string">'view'</span>), &#123;</span><br><span class="line">  onrendered: <span class="function">(<span class="params">canvas</span>) =&gt;</span> &#123;</span><br><span class="line">    image = canvas.toDataURL(<span class="string">'image/png'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  width: <span class="number">300</span>,</span><br><span class="line">  height: <span class="number">300</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里返回的是一个canvas元素  你可以通过canvas的方法获base64的图片格式 或者 Blob的形式</p><ul><li>base64</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> baseimage = canvas.toDataURL(<span class="string">'image/png'</span>)</span><br></pre></td></tr></table></figure><ul><li>Blob</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas.toBlob(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里就可以拿到图片Blob的形式</p><p>但是这里也有一个坑  此Blob无法在iOS中实现  所以如果需要Blob 最好不要使用这种方式</p><p>使用base64 转化为 Blob  的函数方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertBase64UrlToBlob</span>(<span class="params">urlData</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bytes = <span class="built_in">window</span>.atob(urlData.split(<span class="string">','</span>)[<span class="number">1</span>])   <span class="comment">//去掉url的头，并转换为byte</span></span><br><span class="line">  <span class="comment">//处理异常,将ascii码小于0的转换为大于0</span></span><br><span class="line">  <span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(bytes.length)</span><br><span class="line">  <span class="keyword">var</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">    ia[i] = bytes.charCodeAt(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob( [ab] , &#123;<span class="attr">type</span> : <span class="string">'image/png'</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的参数  是不需要带有base64格式头部那里的部分 最开始没有注意到这里 会发现在控制台报错</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to execute 'atob' on 'window': the string to be decoded is not correctly encoded.</span><br></pre></td></tr></table></figure><p>这种方法是可以兼容安卓以及iOS系统的</p><p>将指定元素的部分以图片形式展示</p><h2 id="dom-to-image"><a href="#dom-to-image" class="headerlink" title="dom-to-image"></a>dom-to-image</h2><p>此插件最大的坑是 <strong> Safari is not supported </strong></p><p><a href="https://github.com/tsayen/dom-to-image" target="_blank" rel="noopener">Github</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">domtoimage.toPng(<span class="built_in">document</span>.getElementById(<span class="string">'view'</span>))</span><br><span class="line">.then(<span class="function">(<span class="params">dataUrl</span>) =&gt;</span> &#123;</span><br><span class="line">  imgSrc = dataUrl</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oops, something went wrong!'</span>, error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 第三方插件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于文件的那点事</title>
      <link href="/2017/08/25/%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
      <url>/2017/08/25/%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>我们经常使用的文档上传方式为 借助input标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'file'</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="FileUpload"><a href="#FileUpload" class="headerlink" title="FileUpload"></a>FileUpload</h2><p>创建一个此 input 元素标签 则新建了一个 FileUpload 对象</p><p>file-upload 元素的表单被提交的时候，浏览器会向服务器发送选中的文件的内容</p><a id="more"></a><p>当用户选择一个新的文件，file-upload 元素会触发 onchange 事件句柄 所以可以通过监听此事件 来处理用户操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'input'</span>)</span><br><span class="line">element.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure><h2 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h2><p>File API 为web开发人员提供一种安全的方式 方便客户端访问计算机中的文件 并对其进行操作</p><p>HTML5在DOM中为文件添加了 files 集合 在通过 input 元素 选择一个或者多个文件时候 files中将包含一组File对象 每一个File对象对应着一个文件 每一个File对象有以下只读属性</p><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>在本地系统中的文件名</td></tr><tr><td>size</td><td>文件字节大小</td></tr><tr><td>type</td><td>文件的MIME类型</td></tr><tr><td>lastModifiedDate</td><td>文件上次修改时间(chorme支持)</td></tr></tbody></table><p>所以可以在监听函数中 读取files属性  注意files属性不是匿名函数的参数 而是元素的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'input'</span>)[<span class="number">0</span>]</span><br><span class="line">element.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element.files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/img/file1.png" alt="fiels"></p><h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br></pre></td></tr></table></figure><h3 style="color: #1683bc"> FileReader 的方法 </h3><h4 id="readAsText（file-encoding）"><a href="#readAsText（file-encoding）" class="headerlink" title="readAsText（file, encoding）"></a>readAsText（file, encoding）</h4><p>纯文本形式读取文件 将读取到的文版保存在result中  第二个参数指定编码类型 是可选参数</p><h4 id="readAsDataURL（file"><a href="#readAsDataURL（file" class="headerlink" title="readAsDataURL（file)"></a>readAsDataURL（file)</h4><p>读取文件 并将其以数据URL的形式保存在result中</p><h4 id="readAsArrayBuffer-file"><a href="#readAsArrayBuffer-file" class="headerlink" title="readAsArrayBuffer (file)"></a>readAsArrayBuffer (file)</h4><p>读取文件 并将一个包含文件内容的 ArrayBuffer 保存在result中</p><p>此方法 IE 并不能很好的支持</p><h4 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h4><p>中断文件读取过程</p><h3 style="color: #1683bc"> FileReader 的事件 </h3><p>由于读取内容的过程是异步的 所以FileReader提供了几个事件 比较常用的有 progress error load</p><h4 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h4><p>每50ms左右 会出发一次progress事件</p><h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>如果由于某些原因无法读取文件 则会出发error事件</p><h4 id="load"><a href="#load" class="headerlink" title="load"></a>load</h4><p>当文件成功加载之后 会出发load事件</p><h4 id="loadend"><a href="#loadend" class="headerlink" title="loadend"></a>loadend</h4><p>在触发 error 或者 load 或者 abort 事件之后 会触发 loadend 事件</p><h3 style="color: #1683bc"> FileReader 的属性 </h3><h4 id="error-1"><a href="#error-1" class="headerlink" title="error"></a>error</h4><p>当文件出错时 先关信息会存在error中</p><h4 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h4><p>表明FileReader对象的当前状态</p><h4 id="result"><a href="#result" class="headerlink" title="result"></a>result</h4><p>读取到的文件内容.这个属性只在读取操作完成之后才有效,并且数据的格式取决于读取操作是由哪个方法发起的</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ele = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'input'</span>)[<span class="number">0</span>]</span><br><span class="line">ele.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/image/</span>.test(ele.files[<span class="number">0</span>].type)) &#123;</span><br><span class="line">    reader.readAsDataURL(ele.files[<span class="number">0</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reader.readAsText(ele.files[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line">  reader.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg)</span><br><span class="line">  &#125;</span><br><span class="line">  reader.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">  reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="读取文件部分内容"><a href="#读取文件部分内容" class="headerlink" title="读取文件部分内容"></a>读取文件部分内容</h2><p>如果想要读取部分文件内容 可以借助Blob 类型的方法 slice</p><p>Blob是File 类型的父类型  具有slice属性 以及 type 属性  而且它支持 slice 方法 可以切割数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getblob</span> (<span class="params">blob, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (blob.slice) &#123;</span><br><span class="line">    <span class="keyword">return</span> blob.slice(start, end)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (blob.webkitSlice) &#123;</span><br><span class="line">    <span class="keyword">return</span> blob.webkitSlice(start, end)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (blob.mozSlice) &#123;</span><br><span class="line">    <span class="keyword">return</span> blob.mozSlice(start, end)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ele = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'input'</span>)[<span class="number">0</span>]</span><br><span class="line">ele.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">  <span class="keyword">let</span> blob = getblob(ele.files[<span class="number">0</span>], <span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">  <span class="keyword">if</span> (blob) &#123;</span><br><span class="line">    reader.readAsText(blob)</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(reader.result) <span class="comment">// 读取文件的32b的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="对象URL"><a href="#对象URL" class="headerlink" title="对象URL"></a>对象URL</h2><p>也称之为Blob URL  值得是引用保存在File或者 Blob中数据的URL  </p><p>这种好处是 可以不必把文件内容读取到JavaScript中 而是直接使用文件内容</p><h3 id="创建对象URL"><a href="#创建对象URL" class="headerlink" title="创建对象URL"></a>创建对象URL</h3><p>考虑浏览器兼容问题 可以使用以下函数来创建对象URL</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatObjUrl</span> (<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.URL) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.URL.createObjectURL(blob)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.webkitURL) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.webkitURL.createObjectURL(blob)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回值为字符串 指向内存的地址</p><p>实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ele = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'input'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> imgs = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'img'</span>)[<span class="number">0</span>]</span><br><span class="line">ele.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">  <span class="keyword">let</span> imgUrl = creatObjUrl(ele.files[<span class="number">0</span>])</span><br><span class="line">  imgs.src = imgUrl <span class="comment">// 可以在页面中看到此图片</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>直接将对象URL 放入 Img标签中 就省去了数据先读到JavaScript中的麻烦  <img> 标签会自动找到相应地址 直接将图像读取出来</p><p>如果不需要相应数据 最好释放内存  有两种方式可以进行内存的释放</p><ul><li>手工释放内存</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revokeObjectUrl</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.URL) &#123;</span><br><span class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(url)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.webkitURL.revokeObjectURL(url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>页面卸载时 会自动释放对象URL占用的内存</li></ul>]]></content>
      
      
      <categories>
          
          <category> html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件处理 </tag>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正则基本知识</title>
      <link href="/2017/08/22/%E6%AD%A3%E5%88%99%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/2017/08/22/%E6%AD%A3%E5%88%99%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><p>正则可以用来检查某一个紫川是否存在 或者将其进行查找 替换等操作</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则元字符分为两种 基本元字符 修饰元字符</p><a id="more"></a><h3 id="基本元字符"><a href="#基本元字符" class="headerlink" title="基本元字符"></a>基本元字符</h3><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>转义</td></tr><tr><td></td><td>或者</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>.</td><td>除了换行之外的任意字符</td></tr><tr><td>\b</td><td>开头 结尾 空格</td></tr><tr><td>\B</td><td>非 开头 结尾 空格</td></tr><tr><td>^</td><td>开始</td></tr><tr><td>$</td><td>结尾</td></tr><tr><td>\S</td><td>非空格</td></tr><tr><td>\d</td><td>数字</td></tr><tr><td>\D</td><td>非数字</td></tr><tr><td>\w</td><td>数字字母下划线</td></tr><tr><td>\W</td><td>非数字字母下划线</td></tr><tr><td>[abc]</td><td>a b c三者中任何一个</td></tr><tr><td>[a-z]</td><td>a到z</td></tr><tr><td>{n}</td><td>n个</td></tr><tr><td>{n,}</td><td>大于n个</td></tr><tr><td>{n,m}</td><td>n到m个</td></tr></tbody></table><h3 id="量词元字符"><a href="#量词元字符" class="headerlink" title="量词元字符"></a>量词元字符</h3><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>可有可无</td></tr><tr><td>+</td><td>1个或者多个</td></tr><tr><td>*</td><td>0个或者多个</td></tr></tbody></table><h3 id="修饰元字符"><a href="#修饰元字符" class="headerlink" title="修饰元字符"></a>修饰元字符</h3><table><thead><tr><th>元字符</th><th>含义</th></tr></thead><tbody><tr><td>g</td><td>全局查找</td></tr><tr><td>i</td><td>忽略大小写</td></tr><tr><td>m</td><td>换行</td></tr></tbody></table><h2 id="创建正则"><a href="#创建正则" class="headerlink" title="创建正则"></a>创建正则</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/</span></span><br></pre></td></tr></table></figure><h3 id="new-一个实例"><a href="#new-一个实例" class="headerlink" title="new 一个实例"></a>new 一个实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\d+'</span>, <span class="string">'g'</span>)</span><br></pre></td></tr></table></figure><p>实例创建的时候,传入两个参数,第一个是你本来要在两个反斜杠之间的内容, 所以有时候需要转义。第二个参数是修饰符</p><p>实例创建可以进行变量拼接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`new<span class="subst">$&#123;arg&#125;</span>\d`</span>, <span class="string">'g'</span>)</span><br></pre></td></tr></table></figure><h2 id="正则的方法"><a href="#正则的方法" class="headerlink" title="正则的方法"></a>正则的方法</h2><h3 id="test-验证字符串是否正则规则"><a href="#test-验证字符串是否正则规则" class="headerlink" title="test 验证字符串是否正则规则"></a>test 验证字符串是否正则规则</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/^\d$/</span></span><br><span class="line"><span class="keyword">let</span> end = reg.test(<span class="string">'6'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>test</td><td>布尔值</td></tr></tbody></table><h3 id="exec-捕获"><a href="#exec-捕获" class="headerlink" title="exec 捕获"></a>exec 捕获</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\w&#123;2&#125;/</span></span><br><span class="line"><span class="keyword">let</span> end = reg.exec(<span class="string">'d3fe'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// ["d3", index: 0, input: "d3fe"]</span></span><br></pre></td></tr></table></figure><p>返回值为数组: 负责大正则的内容  内容下标 原始字符串</p><p>如果正则表达式中有小分组 就是() 这种的  exec 还可以将小分组的内容进行捕获 并且返回到数组第二项</p><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>exec</td><td>数组</td></tr></tbody></table><h2 id="正则的属性"><a href="#正则的属性" class="headerlink" title="正则的属性"></a>正则的属性</h2><h3 id="lastIndex"><a href="#lastIndex" class="headerlink" title="lastIndex"></a>lastIndex</h3><p>表示下一次正则开始查找的索引</p><p>可以一个影响此属性变动的是test与exec 如果不使用全局搜索 每次lastIndex 将会是0  如果添加全局g  则lastIndex会发生变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\d+/</span></span><br><span class="line">reg.test(<span class="string">'love2017'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">// 0</span></span><br><span class="line">reg.test(<span class="string">'love2017'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(reg.lastIndex) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 添加全局查找g</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/[0-3]/g</span></span><br><span class="line">reg2.exec(<span class="string">'love2017and2018'</span>) <span class="comment">// ['2', index: 4    ]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.lastIndex) <span class="comment">// 5</span></span><br><span class="line">reg2.exec(<span class="string">'love2017and2018'</span>) <span class="comment">// ['0', index: 5   ]</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.lastIndex) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h2 id="支持正则的字符串常用的方法"><a href="#支持正则的字符串常用的方法" class="headerlink" title="支持正则的字符串常用的方法"></a>支持正则的字符串常用的方法</h2><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RegExp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组</title>
      <link href="/2017/08/13/%E6%95%B0%E7%BB%84/"/>
      <url>/2017/08/13/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组是JavaScript基本数据类型之一  </p><p>数组是值的有序集合 每一个值称为数组元素</p><a id="more"></a><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ul><li>字面量形式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> anchorAry = [<span class="string">'tom'</span>, <span class="string">'juery'</span>]</span><br></pre></td></tr></table></figure><ul><li>实例创建</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rank = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h2><ul><li>length   数组长度 表示数组内部有多少个元素</li></ul><p>数组的索引总是由0开始，所以一个数组的上下限分别是0和length-1</p><h2 id="数组实例的方法"><a href="#数组实例的方法" class="headerlink" title="数组实例的方法"></a>数组实例的方法</h2><h3 id="增加数组"><a href="#增加数组" class="headerlink" title="增加数组"></a>增加数组</h3><ul><li>1  unshift</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flowers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> end = flowers.unshift(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(flowers) <span class="comment">// [4, 1, 2, 3,]</span></span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>unshift 向数组头部增加元素 返回值为新数组的长度  原数组发生变动</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>unshift</td><td>任何类型</td><td>是</td><td>新数组长度</td></tr></tbody></table><ul><li>2 push</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> grass = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> end = grass.push(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(grass) <span class="comment">// [1, 2, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>push 向数组末尾追加元素  返回值为新数组长度 原数组发生变动</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>push</td><td>任何类型</td><td>是</td><td>新数组长度</td></tr></tbody></table><ul><li>3 concat</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> birds = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> trees = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> end = birds.concat(trees)</span><br><span class="line"><span class="built_in">console</span>.log(birds) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// [1, 2, 2, 3]</span></span><br></pre></td></tr></table></figure><p>concat  两个数组的拼接  返回值为新数组 原数组不变</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>concat</td><td>数组</td><td>否</td><td>新数组</td></tr></tbody></table><ul><li>4 splice</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stars = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> end = stars.splice(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stars) <span class="comment">// [1, 2, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>splice 对数组元素进行删除或者替换</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>splice</td><td>三个</td><td>否</td><td>新数组</td></tr></tbody></table><h3 id="删减数组"><a href="#删减数组" class="headerlink" title="删减数组"></a>删减数组</h3><ul><li>1 shift</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> songs = [<span class="string">'can1'</span>, <span class="string">'can2'</span>]</span><br><span class="line"><span class="keyword">let</span> end = songs.shift()</span><br><span class="line"><span class="built_in">console</span>.log(songs)</span><br><span class="line"><span class="built_in">console</span>.log(end)</span><br></pre></td></tr></table></figure><p>shift 从数组头部开始删除元素  返回值为删掉的元素 原数组变化</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>shift</td><td>无</td><td>是</td><td>删除的元素</td></tr></tbody></table><ul><li>2 pop</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wind = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> end = wind.pop()</span><br><span class="line"><span class="built_in">console</span>.log(wind) <span class="comment">// [1, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>pop</td><td>无</td><td>是</td><td>删除的元素</td></tr></tbody></table><ul><li>3 splice</li></ul><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><ul><li>1 forEach (fn, thisArg)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> valley = [<span class="string">'Canada'</span>, <span class="string">'Zealand'</span>, <span class="string">'Mexico'</span>]</span><br><span class="line"><span class="keyword">let</span> end = valley.forEach(<span class="function">(<span class="params">current, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(current, index, array)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>forEach</td><td>cb , this [第二个参数可有可无]</td><td>否</td><td>无</td></tr></tbody></table><ul><li>2 map</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> valley = [<span class="string">'Canada'</span>, <span class="string">'Zealand'</span>, <span class="string">'Mexico'</span>]</span><br><span class="line"><span class="keyword">let</span> end = valley.map(<span class="function">(<span class="params">current, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(current, index, array)</span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>map</td><td>cb , this [第二个参数可有可无]</td><td>否</td><td>有 返回值为数组</td></tr></tbody></table><ul><li>3 filter</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singer = [<span class="string">'灿灿'</span>, <span class="string">'希小白'</span>, <span class="string">'伦桑'</span>]</span><br><span class="line"><span class="keyword">let</span> end = songs.filter(<span class="function"><span class="params">item</span> =&gt;</span>  item.length &gt; <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// ['希小白']</span></span><br></pre></td></tr></table></figure><p>filter 筛选符合条件的元素 返回数组</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>filter</td><td>cb , this [第二个参数可有可无]</td><td>否</td><td>有 返回值为数组</td></tr></tbody></table><ul><li>4 every</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singer = [<span class="string">'岑岑'</span>, <span class="string">'白止'</span>, <span class="string">'老干妈'</span>]</span><br><span class="line"><span class="keyword">let</span> end = singer.every(<span class="function"><span class="params">item</span> =&gt;</span> item.length &lt; <span class="number">2</span> )</span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>遍历数组中元素 当每一个元素在callback中返回为TRUE  则最后才返回TRUE</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>every</td><td>cb , this [第二个参数可有可无]</td><td>否</td><td>Boolean</td></tr></tbody></table><ul><li>5 some</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singer = [<span class="string">'宁采臣'</span>, <span class="string">'李逍遥'</span>, <span class="string">'小八'</span>]</span><br><span class="line"><span class="keyword">let</span> end = singer.some(<span class="function"><span class="params">item</span> =&gt;</span> item.length &gt; <span class="number">2</span> )</span><br><span class="line"><span class="built_in">console</span>.log(end) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>遍历数组中元素 当有一个元素在callback中返回为TRUE  则可才返回TRUE</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>some</td><td>cb , this [第二个参数可有可无]</td><td>否</td><td>Boolean</td></tr></tbody></table><ul><li>6 reduce</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> math = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> end = math.reduce(<span class="function">(<span class="params">current, next</span>) =&gt;</span> current + next)</span><br><span class="line"><span class="built_in">console</span>.log(end)</span><br></pre></td></tr></table></figure><p>从左到右依次进行元素的累加</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>reduce</td><td>cb , origin [初始值 第二个参数可有可无]</td><td>否</td><td>累加之和</td></tr></tbody></table><ul><li>7 reduceRight</li></ul><p>从右到左依次进行元素的累加</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>reduceRight</td><td>cb , origin [初始值 第二个参数可有可无]</td><td>否</td><td>累加之和</td></tr></tbody></table><ul><li>8 find</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> singer = [<span class="string">'萧忆情'</span>, <span class="string">'小义学长'</span>, <span class="string">'李蚊香'</span>]</span><br><span class="line"><span class="keyword">let</span> end = singer.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="string">'李蚊香'</span>)</span><br><span class="line"><span class="keyword">let</span> end2 = singer.find(<span class="function"><span class="params">item</span> =&gt;</span> item === <span class="string">'Can'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(end, end2) <span class="comment">// 李蚊香 , undefined</span></span><br></pre></td></tr></table></figure><p>遍历数组 返回 第一个 使callback 为TRUE的元素  如果没有 则返回undefined</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>find</td><td>cb , thisArg [第二个参数可有可无]</td><td>否</td><td>元素 或者 undefined</td></tr></tbody></table><ul><li>9 findIndex</li></ul><p>类似于 find 不过返回的是符合条件的元素的位置 如果所有成员都不符合条件，则返回-1</p><table><thead><tr><th>方法</th><th>参数</th><th>原数组是否变化</th><th>返回值</th></tr></thead><tbody><tr><td>findIndex</td><td>cb , thisArg [第二个参数可有可无]</td><td>否</td><td>元素下标 或者 -1</td></tr></tbody></table><h4 id="find-filter"><a href="#find-filter" class="headerlink" title="find filter"></a>find filter</h4><p>在数组中查找符合某种条件的元素 可以使用 filter 或者 find</p><p>filter 将会遍历所有元素 返回值为数组<br>find 一直遍历到第一个符合条件的 返回值是 该元素</p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>继承</title>
      <link href="/2016/12/10/%E7%BB%A7%E6%89%BF/"/>
      <url>/2016/12/10/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>文章导读</p><p>1 如何更改原型上的属性或者方法</p><p>2 call</p><p>3 实现继承的几种方式</p><h3 id="更改类的原型上的属性或者方法"><a href="#更改类的原型上的属性或者方法" class="headerlink" title="更改类的原型上的属性或者方法"></a>更改类的原型上的属性或者方法</h3><p>1.1 通过直接 修改类的prototype</p><p>1.2 通过修改实例的 <strong>proto</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.protype.push=&#123;&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ary1.__proto__.push=&#123;&#125;</span><br></pre></td></tr></table></figure><p>在所有浏览器下，禁止用户批量修改，实例上的公有属性和方法；</p><p>IE中不允许使用<strong>proto</strong>修改属性方法，可以通过 类.prototype 个一个的修改。</p><p>标准浏览器中可以使用<strong>proto</strong> 以及  类.prototype 可以一个一个的修改原型的属性方法。</p><h3 id="关于构造函数"><a href="#关于构造函数" class="headerlink" title="关于构造函数"></a>关于构造函数</h3><p>2.1 构造函数中的this 都是当前实例</p><p>2.2 构造函数中都是私有的变量方法, 类.prototype 上是公有的属性方法</p><p>2.3 若是类.prototype  赋值一个对象,则自带的属性constructor 一定会发生变化</p><p>3 call()<br>call 的作用就是改变this指向</p><p>obj1.call(obj2)<br>将obj1中的this 指向到后面的那个对象obj2<br>call的第一个参数：改变call点前面的函数中的this指向；<br>call的第二个参数开始，对函数中的形参从左往右的赋值；</p><h3 id="继承的几种方式"><a href="#继承的几种方式" class="headerlink" title="继承的几种方式"></a>继承的几种方式</h3><h4 id="call-继承"><a href="#call-继承" class="headerlink" title="call() 继承"></a>call() 继承</h4><p>继承原理  父级的私有属性方法 继承给子级元素的私有属性方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'tom'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="冒充继承"><a href="#冒充继承" class="headerlink" title="冒充继承"></a>冒充继承</h4><p>通过for in 循环</p><p>继承原理  父级的私有以及公有属性方法 继承给子级元素的私有属性方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'tom'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say= fucntion()&#123;<span class="built_in">console</span>.log(<span class="string">'hello'</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> p1)&#123;</span><br><span class="line">        <span class="keyword">this</span>[attr] = p1[attr]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sun1 = <span class="keyword">new</span> Sun();</span><br><span class="line">sun1.say(); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h4 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h4><p>继承原理  父级的私有以及公有属性方法 继承给子级元素的公有属性方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'tom'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">23</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Sun.prototype = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> sun1 = <span class="keyword">new</span> Sun();</span><br></pre></td></tr></table></figure><h4 id="拷贝继承-call继承-extend继承"><a href="#拷贝继承-call继承-extend继承" class="headerlink" title="拷贝继承 call继承+extend继承"></a>拷贝继承 call继承+extend继承</h4><p>继承原理</p><p>父级的私有属性 -》子级元素的私有属性　　call() 继承</p><p>父级的公有属性 -》子级元素的公有属性        extend继承</p><p>1 先写一个extend的封装函数,将obj1中的属性方法通过for in 全复制一份到Obj2中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj1,obj2</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> obj1)&#123;</span><br><span class="line">   obj2[attr] = obj1[attr]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> obj2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 call 继承父级私有属性 + extend 继承公有属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Per</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'tom'</span></span><br><span class="line">&#125;</span><br><span class="line">Per.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello'</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Per.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">extend(Per.prototype,Sun.prototype);</span><br><span class="line"><span class="keyword">var</span> sun1 =<span class="keyword">new</span> Sun()</span><br></pre></td></tr></table></figure><h4 id="关于属性的几种方法"><a href="#关于属性的几种方法" class="headerlink" title="关于属性的几种方法"></a>关于属性的几种方法</h4><p>判断属性是否在对象上，属性名一定要加引号，否则，会把他当做变量，报错</p><p>5.1  hasOwnProperty</p><p>obj.hasOwnPorperty(‘say’)<br>判断say是不是obj的私有属性或者方法</p><p>5.2 isPropertyOf</p><p>obj1.isPropertyOf(obj2)<br>判断 前者是不是在后者的原型链上</p><p>5.3 in</p><p>console.log( ‘say’ in Person )<br>判断属性是不是所写类的属性或方法,包括公有和私有,返回true或者false</p><p>5.4 for in</p><p>循环自定义属性,公有加私有</p><p>5.5  propertyIsEnumerable</p><p>只能遍历对象身上自定义的私有属性和方法</p><p>6 other</p><p>6.1 写一个方法,判断属性是不是公有属性hasPubProperty</p><p>思路：该属性是对象上的属性 &amp;&amp; 该属性不是对象的私有属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fucntion hasPubProperty(attr,obj)&#123;</span><br><span class="line"> <span class="keyword">return</span> attr <span class="keyword">in</span> obj &amp;&amp; !obj.hasOwnProperty(attr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.2 链式操作</p><p>关注的是前一个函数执行完成的“返回值”，返回的是个数组，后续就跟数组的方法，返回的是个数字，后续就跟着数字的方法</p>]]></content>
      
      
      <categories>
          
          <category> es5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
