<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[上传文件到七牛]]></title>
    <url>%2F2019%2F04%2F18%2F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E4%B8%83%E7%89%9B%2F</url>
    <content type="text"><![CDATA[上传图片到七牛 服务端进行上传服务端将图片源传递到七牛，这种方式的流程是 1 前端将图片传到自己的服务器2 在server将文件传递到七牛 API 前端需要注意，要使用 formData 格式进行文件上传， 关于 formData 12345678910111213141516171819202122document.querySelector('input').onchange = () =&gt; &#123; const file = document.querySelector('input').files[0] const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = function (e) &#123; const urlData = this.result; // 构建上传对象 let formData = new FormData() // base64ToBlob - 转blob 下文有提到 这里暂时不展开了 formData.append('img', base64ToBlob(urlData)) // fetch调用接口 fetch(path, &#123; body: formData, credentials: 'same-origin', method: 'POST' &#125;) &#125;&#125; server 接口部分 基本参数 1234const bucket = 'cancan'const accessKey = '2LC7KPjwnYdxxxc'const secretKey = 'SXrxxx'const domain = 'http://pq3xxxdn.com' 获取token 1234567function get_token () &#123; const mac = new qiniu.auth.digest.Mac(accessKey, secretKey); const policyParams = &#123; scope: bucket &#125; const putPolicy = new qiniu.rs.PutPolicy(policyParams); const uploadToken = putPolicy.uploadToken(mac); return uploadToken&#125; 拿到文件path之后进行七牛上传 1234567891011121314151617181920212223async function uploadFile(localFile, key) &#123; const uploadToken = get_token() const config = new qiniu.conf.Config(); // 空间对应的机房 config.zone = qiniu.zone.Zone_z0; const formUploader = new qiniu.form_up.FormUploader(config); const putExtra = new qiniu.form_up.PutExtra(); return new Promise((resolve, reject) =&gt; &#123; // 文件上传 formUploader.putFile(uploadToken, key, localFile, putExtra, function (respErr, respBody, respInfo) &#123; if (respErr) &#123; reject('error') &#125; if (respInfo.statusCode == 200) &#123; const &#123; key &#125; = respBody resolve(`$&#123;domain&#125;/$&#123;key&#125;`) &#125; &#125;); &#125;)&#125; 接口 12345678910111213router.post('/upload', async (ctx) =&gt; &#123; // 获取到上传到服务器的文件信息 const &#123; img &#125; = ctx.request.files // path 拿到临时文件地址 const &#123; path &#125; = img // key 是给图片的命名 const key = Math.random() * 100 + '.png' const result = await uploadFile(path, key) ctx.body = result&#125;) 遇到的问题 post 接口 始终无法解析到file参数 后来发现是因为 中间件只使用了 koa-bodyparser， 一般图片上传使用的是 koa-multer，可以使用 koa-body来代替这两个 参考文章 临时文件占用大量磁盘空间 可以看到，在将文件上传到服务器的时候，会创建一个临时文件- 接口中解析的那个 path 对于服务器，可以写一个定时的脚本去清除这些文件。或者我们在脚本增加一段逻辑，在成功上传到七牛之后，手动将临时文件进行删除 1234fs.unlink(path, (err) =&gt; &#123; if (err) throw err; console.log('文件已删除', path);&#125;) git地址 - server git地址 - html 前端直接上传项目中的例子涉及到的图片上传，都是将文件上传到服务器然后再去传到七牛空间，这种操作方式，相当于在自己的服务器做了一层中转站。开发者可以在中转站对图片做一些处理然后在传到七牛空间。但是有一些缺点 内存占用量增大 临时文件占用磁盘空间，需要每次上传之后需要进行文件删除 如果开发中不需要中转站，可以考虑直接从前端将图片上传到七牛空间 参考七牛的API文档，基本可以涉及到的是 上传凭证的生成 前端文件上传 区域 上传策略参数设置 获取上传凭证 token1234567891011router.get('/qiniu', async (ctx, next) =&gt; &#123; const bucket = 'activity' const accessKey = '2LCxxxrxxx' const secretKey = 'SXrdqdvxxx' const mac = new qiniu.auth.digest.Mac(accessKey, secretKey); const policyParams = &#123; scope: bucket &#125; const putPolicy = new qiniu.rs.PutPolicy(policyParams); const uploadToken = putPolicy.uploadToken(mac); ctx.body = uploadToken&#125;) 前端上传代码 base64转 blob 1234567891011function base64ToBlob(dataurl) &#123; var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while (n--) &#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123; type: mime &#125;); &#125; 基本参数 12345678910111213// 这个token 就是 server接口返回的tokenconst token = '2LC7KTxxx'const config = &#123; useCdnDomain: true, region: qiniu.region.z1&#125;;const putExtra = &#123; fname: "", params: &#123;&#125;, mimeType: [] || null&#125;; 核心上传 1234567891011121314151617181920212223const inputTarget = document.querySelector('input')inputTarget.onchange = (data) =&gt; &#123; const imgfile = inputTarget.files[0] const reader = new FileReader(); reader.readAsDataURL(imgfile); reader.onload = function (e) &#123; const urlData = this.result; const blobData = base64ToBlob(urlData) // 这里第一个参数的形式是blob const observable = qiniu.upload(blobData, 'filename.png', token, putExtra, config) const observer = &#123; next(res) &#123;console.log(res)&#125;, error(err) &#123;console.log(err)&#125;, complete(res) &#123;console.log(res)&#125; &#125; // 注册observer 对象 observable.subscribe(observer) &#125; &#125; 文件就可以被传到七牛了 可以看到这里返回的是一个hash和key，图片最后完整的访问路径，是你的七牛上配置的域名+key 在七牛创建一个新空间的话，会提供一个30天的免费域名可以使用 git地址 - server git地址 - html 遇到的问题 cdnUphost 解析失败 原来是把 1234const config = &#123; useCdnDomain: true, region: 'qiniu.region.z0'&#125; 这里的region 写错了，不应是字符串，就是一个七牛的变量 1234const config = &#123; useCdnDomain: true, region: qiniu.region.z0&#125; 这个参数是取决于你的空间存储区域选择的是哪里 对照文档 区域 进行z0 z1的选择 图片上传之后却无法读取，显示已损坏 是因为第一次的时候，直接将 input的files[0] 值上传, 这里与文档要求的参数格式不一致 文档里对这个参数的要求是blob，所以记得这里需要转化一下文件格式 以前的demo写的一直失败就搁置了，今天重新跑了一次，再次吐槽七牛的文档，写的真是让人头大 编写 webpack 上传七牛的插件在开发中，有使用一个webpack的配置， qiniu-webpack-plugin 参照这个的使用方式，另外写一个上传plugin 涉及到的一些文档 webpack plugin API webpack plugin config plugin 使用12345678910// 这个是编译文件编译到的文件夹const filePath = path.resolve(__dirname, 'public')new QiuniuUploadPlugin(&#123; bucket, accessKey, secretKey, domain, path: filePath&#125;) 类的实现这个的逻辑大部分和从后端直接上传到七牛有重合，这里只把另一部分写出来 大致实现 12345678910111213141516171819202122232425262728class QiuniuUploadPlugin &#123; constructor () &#123;...&#125; uploadQn (filename) &#123;...&#125; apply (compiler) &#123; const pluginName = 'QiuniuUploadPlugin' // 事件钩子 compiler.hooks.run.tap(pluginName, compilation =&gt; &#123; console.log("webpack 构建过程开始！") &#125;); // afterEmit - 生成资源到 output 目录之后将触发 异步钩子 - tapPromise compiler.hooks.afterEmit.tapPromise(pluginName, (compilation) =&gt; &#123; let &#123; assets &#125; = compilation // assets 这里拿到的assets是一个对象 key是文件名 value是相关关参数 我们只需要key // assets --&gt;&gt;&gt; &#123; 'index.js' : xxxx &#125; // 遍历所有的文件名 进行七牛的上传 const allUplaod = Object.keys(assets).map((item) =&gt; &#123; return this.uplaodQn(item) &#125;) return Promise.all(allUplaod) &#125;) &#125;&#125; git - webpack git - plugin具体实现]]></content>
      <tags>
        <tag>七牛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0415]]></title>
    <url>%2F2019%2F04%2F16%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920415%2F</url>
    <content type="text"><![CDATA[workPUSH消息 lifegql 《clean code》ppt本周初稿必须完成 本周浏览 Content-type的几种常见类型 算法 如何优雅地书写JavaScript forEach 学习CSS网格布局]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa源码解析]]></title>
    <url>%2F2019%2F04%2F14%2Fkoa%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[koa2 源码分析 koa 核心源码使用1234567891011const Koa = require('koa')const app = new Koa()const port = 3333app.use(() =&gt; &#123; console.log('middle');&#125;)app.listen(port, () =&gt; &#123; console.log(port)&#125;) 分析koa 是一个类，创建其示例后， listen方法 开启一个http服务，并且执行中间件函数 实现1234567891011121314151617181920212223const http = require('http')class Koa &#123; constructor () &#123; this.middles = [] &#125; use (cb) &#123; this.middles.push(cb) &#125; listen (port, cb) &#123; // 开起服务 http.createServer((req, res) =&gt; &#123; // 遍历中间件 this.middles.forEach((item) =&gt; &#123; item() &#125;) &#125;).listen(port, cb) &#125;&#125; request.js 实现1234567let request = &#123; get url () &#123; return this.request.req.url &#125;&#125;module.exports = request 这里的get url 相当于 12345Object.defineProperty(request, 'url', &#123; get () &#123; return this.request.req.url &#125;&#125;) context 实现123const context = &#123; &#125;module.exports = context context 就是 ctx 1let ctx = Object.create(this.context); 在使用koa过程中，我们经常直接在ctx对象上获取属性，比如 123ctx.path ctx.query 这些属性的实现是通过 1234567891011121314151617const context = &#123; &#125;// context.url = context.request.url// 自定义获取器， 代理function defineGetter(property, name) &#123; context.__defineGetter__(name, function () &#123; return this[property][name] &#125;)&#125;// context 获取 url 的时候 实际获取的是 context.request.urldefineGetter('request', 'url')// pathdefineGetter('request', 'path')module.exports = context 这里涉及到一个代理的功能，在原生koa使用的是 Delegator 库 里面有这样的代码 123proto.__defineGetter__(name, function()&#123; return this[target][name];&#125;); 关于 defineGetter response.js 实现response 最主要的是 koa的返回值, 使用的时候是 1ctx.body = '123' response.js 模块，实现，包括设置和获取两个 1234567891011const response = &#123; set body (value) &#123; this._body = value &#125;, get body () &#123; return this._value &#125;&#125;module.exports = &#123;&#125; 而 response.body 实际是可以直接在 ctx 中获得的, 所以还要在 context.js 中添加一层代理 123456789// 代理 body ctx.body -&gt; ctx.response.bodydefineSetter('response', 'body')// 属性定义期 代理function defineSetter(property, name) &#123; context.__defineSetter__(name, function (value) &#123; this[property][name] = value &#125;)&#125; 这样当我们使用 ctx.body = xxx 就能相当于写的 ctx.response.body = xxx 中间件使用1234567891011app.use(async (ctx, next) =&gt; &#123; console.log('middleware1'); next() console.log('middleware1 - next');&#125;)app.use(async (ctx, next) =&gt; &#123; console.log('middleware2'); next() console.log('middleware2 - next');&#125;) 分析每次调用use函数，都在koa的中间件数组中增加一个函数 执行next 代表了 去调用‘下一个’中间件元素 重写 生成中间件数组 此时还不需要ctx，暂时就认为没有传递ctx参数 12345678910111213141516const middles = []const use = (cb) =&gt; &#123; middles.push(cb)&#125;use((next) =&gt; &#123; console.log('middleware1'); next() console.log('middleware1 - next');&#125;)use((next) =&gt; &#123; console.log('middleware2'); next() console.log('middleware2 - next');&#125;) 先看一下中间件数组现在是什么 12// console.log(middles)[ [Function], [Function] ] 按顺序执行中间件数组 构建 executing 函数，用于执行中间件，参数是中间间元素的 index 1234567891011const executing = (index) =&gt; &#123; // fnItem 是中间间函数 const fnItem = middles[index] // 获取当前的 ‘下一个’ 中间件 const nextItem = middles[index + 1] // 执行此函数 并且需要 将下一个传入 fnItem(() =&gt; &#123; executing(index + 1) &#125;)&#125;executing(0) 其实这里一个点需要注意，一开始写的时候，总是认为，这里应该传的是 下一个中间件，比如 123fnItem(() =&gt; &#123; middles[index + 1]&#125;) 但是其实这个 应该传递的时候一个 执行下一个的函数，也就是 executing 添加一个条件 -》什么时候终止 executing 1234567const executing = (index) =&gt; &#123; // 当index 已经是 中间件数组长度了 则终止函数执行 if (index == middles.length) return const fnItem = middles[index] fnItem(() =&gt; executing(index + 1))&#125;executing(0) other git地址 参考文章 - KOA2框架原理解析和实现]]></content>
      <categories>
        <category>koa</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日英文]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%AF%8F%E6%97%A5%E8%8B%B1%E6%96%87%2F</url>
    <content type="text"><![CDATA[每日英文 0414 js问题地址个人理解 有一个button按钮，点击展示图片。点击图片本身则消失, 代码如下，但是没有起作用 12345678910function show_image(onclick) &#123; var img = document.createElement("img"); img.onclick = onclick; show_image('delete()')&#125;function delete() &#123; style.display = 'none';&#125; answer其实没有看懂他的代码的含义, 看上面的img标签好像是动态生成的，但是并没有 append 到文档中 12&lt;button onclick="toggle_display('block')" &gt; show img &lt;/button&gt;&lt;img onclick="toggle_display('none')" src='./border.png' /&gt; 123456&lt;script&gt; const img = document.querySelector('img') function toggle_display (display) &#123; img.style.display = display &#125; &lt;/script&gt; 0415 html问题地址个人理解正在写作业，作业需要遵循以下标准：设计一个基本的html 表单，根据用户交互行为可以读写cookie 1 包含一个 text 输入框 接受数据 （去写入cookie）2 包含button 按钮 ， 将 text 数据 写入cookie3 包含一个js 验证， 如果第二步点击了button，但是 text 输入框没有内容，则需要alert 一个提示4 包含一个button按钮，用于从cooki中读取信息，并且以alert形式展示5 包含一个button 去删除cookie 内容 我尽我所能写了 function 函数，我也创建了button 按钮，但是到目前，没有出现一个 alert 提示。 我不了解js，一直在这里思考 这是我写的function 123456789101112131415161718192021&lt;script&gt;function saveCookies() &#123; if (document.userData.field1.value == "") &#123; alert("Please Fill In All Form Values!"); return; &#125; else &#123; cookievalue1 = escape(document.userData.field1.value); document.cookie = cookievalue1; alert("The Following Data Has Been Saved To a Cookie:\n" + "\nFirst Name = " + cookievalue1); &#125;&#125;function showCookies() &#123; alert("First Name: " + cookievalue1)&#125;function clearCookies() &#123; document.cookie = "username=; expires=Thu, 01 Jan 1970 00:00:00 GMT";&#125;&lt;/script&gt; 0416 nodeAddress个人理解怎么用一个不同端口的服务器去链接本服务器 我正在用数据库写一个简单的站点，它使用json-server启动，有点类似于我在YouTube上发现的这个 我出现的问题是，我不知道在两台服务器之间如何交流，在node方面我是一个新手，希望有人可以帮助我，不胜感激 这个json-server启动并且运行在 http://localhost:3000/posts 而另一个站点运行在 http://localhost:5000 。。。。是一堆代码，这里不做展示 我希望可以使用 http://localhost:5000/api/posts 预览到db.json 的数据，而不是通过”http://localhost:3000/posts&quot;。请问有什么解决方案吗 分析他这里可以在 5000的服务器上，直接请求3000的数据接口，然后展示，所以只需要调整 post.js 就可以了 给予回复You can fix the post.js 1234567891011const express = require('express');const router = express.Router();const urllib = require('urllib')const endpoint = "http://localhost:3000/posts";router.get('/', (req, res) =&gt; &#123; urllib.request(endpoint, function (err, data, res) &#123; const result = data.toString() res.send(result); &#125;);&#125;); Urllib can help us get data from “http://localhost:3000/posts&quot; Actually you should console.log the data and change result according to the format you want 0417 RegExpquestion个人理解如何用正则提取字符和数字 以下是例子 123"Name &amp; Name (Font 2)""Name (Font 15)""Name ~ Name + String (Font 3)" 我想要获取两组数据 第1组，在”(Font” 之前的字符，匹配示例 123"Name &amp; Name""Name""Name ~ Name + String" 第2组，数字，匹配示例 1232153 answer123456789const arys = ['Name4 &amp; Name (Font 112)', 'Name4 (Font 12)']const str1 = arys.map((item) =&gt; &#123; return /(.+)\(Font (\d+)\)/g.exec(item)[1]&#125;)const numbers = arys.map((item) =&gt; &#123; return /(.+)\(Font (\d+)\)/g.exec(item)[2]&#125;) 0418 jsQuestion个人理解如何正确复制一个对象 我记得可以用扩展用算符来创建对象, 不过现在我意识到 如果我修改一个对象的值，另一个也会变动，然后使用 Object.assign 也是这样 总而言之，题主想要如何实现一个深拷贝 #### 这个题主的例子首先是错的，使用 扩展运算符 和 Object.assign 虽然也是浅拷贝，但是他的属性是基本数据类型, 比如 123456const obj1 = &#123; name: 'tom' &#125;const obj2 = &#123; ...obj1 &#125;const obj3 = Object.assign(&#123;&#125;, obj1)obj1.name = 'no tom'console.log(obj1, obj2, obj3)// &#123;name: "no tom"&#125; &#123;name: "tom"&#125; &#123;name: "tom"&#125; 如果其中的属性是引用数据类型，就会有问题 1234const obj1 = &#123; name: 'tom', books: &#123; title: 'book1' &#125; &#125;const obj2 = &#123; ...obj1 &#125;obj1.books.title = 'book3'console.log(obj1, obj2) 关于深浅拷贝的文章已经太多了，直接贴一个别人的链接吧JavaScript专题之深浅拷贝 0419 jsquestion个人理解正在尝试让用户进行文件上传，使用的koa2搭建的服务 但是中间件是 koa-body进行文件上传的时候，文件没有扩展名 并且使用的是一串随机字符值表示，如何才能使用文件原始名称和扩展名呢 分析其实可以从name拿到这个真正的名称 回答I uesd the koa-body and could get actually name by 12345router.post('/stream', async (ctx) =&gt; &#123; const &#123; file &#125; = ctx.request.files const &#123; path, name &#125; = file ctx.body = name&#125;) you could add some attribute for formidable in the middleware config like 123456789101112131415app.use(bodyparser(&#123; multipart: true, formidable: &#123; keepExtensions: true, onFileBegin: (name, file) =&gt; &#123; console.log(name) // get the file extension const ext = name.split(&apos;.&apos;).pop() console.log(ext) &#125;, &#125;,&#125;)) you can console.log the name]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件下载那点事]]></title>
    <url>%2F2019%2F04%2F10%2F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[文件下载 Content-Disposition / Content-TypeContent-Dispositionhttp 头部的 Content-Disposition字段，规定了返回的内容用什么形式展示 value 含义 是否默认 inline 以网页或者页面的一部分 是 attachment 以附件的形式下载并保存到本地 否 1234http.createServer((req, res) =&gt; &#123; res.setHeader("Content-Disposition", "attachment") res.end('123 - 321 - 1234567') &#125;) 前端需要使用window.open 形式访问 此路由就可以实现文件的下载 1window.open(xxxx) 或者使用 H5新属性 a 标签 1&lt;a type='download' href=xxx&gt; 点击下载 &lt;/a&gt; Content-Type1234http.createServer((req, res) =&gt; &#123; res.setHeader("Content-Type", "application/octet-stream") res.end('123 - 321 - 1234567') &#125;) 同上前端使用 open 或者 a标签进行处理 备注： 如果使用普通的请求，是不可以的，比如使用ajax window.openwindow.open 可以下载文件的原因是，浏览器遇到无法解析的文件就是执行下载 当使用浏览器打开文件时， 如果它无法解析，那么就会把该文件下载下来 1234http.createServer((req, res) =&gt; &#123; const data = fs.readFileSync('./Zip.zip') res.end(data) &#125;) 拿到的data是一个buffer 对象，那么直接写一个Buffer可以实现下载么 1data = new Buffer('我是谁，谁是我') 尝试后发现，koa是可以的。但是原生直接这么写是不行的 1234http.createServer((req, res) =&gt; &#123; const newBuf = new Buffer('我是谁，谁是我') res.end(newBuf) &#125;) 通过接口拿到数据之后进行下载在实际项目中，文件下载可能出现的场景 对于已经在服务器存在的文件进行下载，比如图片资源 将一些查询数据导出到本地， 比如mysql查询结果导出csv 对于已存在的资源，可以直接使用 上面说的 winodw.open 或者 a 标签进行下载，那么对于不是以文件形式存在的资源呢 data URI经常见到使用 data URI scheme 的是图片, 一般为了减少http请求，会将图片直接以base64的形式展示在html中 1&lt;img src='data:image/png;base64,xxxxxx'/&gt; 也可以应用到文件下载中 ···js router.get(‘/download’, async (ctx, next) =&gt; { const newBUf = new Buffer(‘我是谁，谁是我’) ctx.body = newBUf}··· 1234567axios.get(`$&#123;path&#125;`).then(function (&#123;data&#125;) &#123; let a = document.createElement('a'); a.href = "data:text/plain;charset=utf-8," + data; a.download = "myfilename.png"; a.click();&#125;) BlobBlob 是表示一个类文件对象，可以用它来表示一个文件 server 部分 123456789http.createServer((req, res) =&gt; &#123; res.setHeader("Access-Control-Allow-Origin", "*"); let end = '' if (req.url.includes("/down")) &#123; const newBUf = new Buffer('我是谁，谁是我') end = newBUf &#125; res.end(end)&#125; 前端 12345678910111213141516 const xhr = new XMLHttpRequest(); xhr.open('GET', path); xhr.responseType = 'blob'; xhr.onload = function () &#123; const blob = xhr.response; const url = URL.createObjectURL(blob); // 通过a标签去下载 const link = document.createElement('a'); link.href = url; link.download = fileName; link.click(); URL.revokeObjectURL(url); &#125;;xhr.send(); 尝试用 window.open 方式，发现不可以 目前常用的各个请求库也支持返回内容为blob格式123axios.get(`$&#123;path&#125;`, &#123; responseType: 'blob'&#125;) 或者 fetch 1fetch(path).then(res =&gt; res.blob().then(blob =&gt;&#123; ... &#125;) window.URL createObjectURL 用 blob 对象来创建一个 object URL(它是一个 DOMString)，我们可以用这个 object URL 来表示某个 blob 对象，这个 object URL 可以用在 a 标签的 href属性上，然后触发点击事件，就可以下载文件了 revokeObjectURL 为了避免避免内存泄漏，需要手动释放创建的 object URL 缺点 构建完 blob 对象后才会转换成文件 从代码就能看出，需要先将返回内容转为blob才进行下载操作，如果用户操作的是一个很大的资源，在等待文件正式下载前，还需要一段时间等待格式的转化 实例将mysql数据 导出 csv这边直接用数据模拟mysql查询结果, 在网上查到两种拼接方式，肯定有其余的方案 第一种 1234567891011121314151617const result = [ ['id', 'oreder', 'name', 'status' ], [1, '201904120201', '正在加载', '已完成'], [18, '201904120204', '测试189', '待付款'], [22, '201904120209', '蓝田日暖', '待付款'],]// 可以看到 result 数组的第一组是 csv的各个字段标题 const data = csvData.reduce((cur, next) =&gt; `$&#123;cur + next.join(',')&#125;\n`, '')const blob = new Blob([data]);const url = URL.createObjectURL(blob);var a = document.createElement('a');a.href = url;a.download = filename;a.click();window.URL.revokeObjectURL(url); 第二种 1234567891011121314151617181920const result = [ [1, '201904120201', '正在加载', '已完成'], [18, '201904120204', '测试189', '待付款'], [22, '201904120209', '蓝田日暖', '待付款'],]// result 就是正常的数据格式 // 解决乱码问题 let dataType = '\uFEFF' // 添加表格的头子段 dataType += ([' 订单编号', '用户', '动态ID'].join(',')) dataType += '\n' csvData.forEach(item =&gt; &#123; dataType += ([item.id, item.order, item.name, item.staus].join(',')) dataType += '\n' &#125;) const blob = new Blob([dataType], &#123;type: 'text/csv'&#125;) 如果有几段流文件，前端需要下载拼接成一个完整文件，如何实现肯定是在 server端进行文件的拼接操作，然后返回到前端下载 大致过程 12345const content1 = '这里是第1段文件内容'const content2 = '这里是第2段文件内容'ctx.body = &#123; code:200, data: content1 + content2 &#125; 前端就是上文中的blob 下载方式了]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>文件处理</tag>
        <tag>资源下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0408]]></title>
    <url>%2F2019%2F04%2F08%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920408%2F</url>
    <content type="text"><![CDATA[work广告 lifekoa中间件 clean code PPT 写完 本周浏览 浏览器工作原理 Virtual DOM mysql 模糊查询 面试]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0401]]></title>
    <url>%2F2019%2F04%2F01%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920401%2F</url>
    <content type="text"><![CDATA[workpush 消息处理 本周浏览 vscode plugin]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GraphQL 初探]]></title>
    <url>%2F2019%2F03%2F26%2FGraphQL%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[gql 基本概念操作类型gql 有三种操作类型 query、mutation 或 subscription, 用于描述你打算做什么类型的操作 GraphQL 的操作类型可以是 query、mutation 或 subscription，描述客户端希望进行什么样的操作 query 查询：获取数据，比如查找，CRUD 中的 Rmutation 变更：对数据进行变更，比如增加、删除、修改，CRUD 中的 CUDsubstription 订阅：当数据发生更改，进行消息推送 schemaGraphQL 服务都会定义一套类型，用以描述你可能从那个服务查询到的数据。每当查询到来，服务器就会根据 schema 验证并执行查询 GraphQL schema 中的最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段 比如获取一个用户信息 12345type Person &#123; id: Int!, name: String!, friends: [String]&#125; Person 是一个普通对象 id name friends 是 Person 类型上的字段, 那么再使用 Person 的时候 只能返回这三个字段值 String! 这个值这里，添加叹号 表示这个字段是非空的 schema 的特殊类型一个 schema 内有两个特殊类型： Query 与 Mutation Query 定义了每一个 GraphQL 查询的入口 123type Query &#123; getName (id: Int) : String&#125; 变量类型gql 有几种自带的变量类型 Int String Float Boolean ID - -ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键 枚举 enum 12345enum Teachers &#123; MAN, WOMAN&#125; 这个就表示 Teachers 的两种类型是 MAN 或者 WOMAN 接口 Interfaces接口的存在用于给另外的对象使用 【感觉这个和ts中的接口含义类似】 123456789interface Teachers &#123; book: String&#125;type LiTeaches implements Teachers &#123; book: String, school: String&#125; resolver]]></content>
      <tags>
        <tag>gql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0325]]></title>
    <url>%2F2019%2F03%2F25%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920325%2F</url>
    <content type="text"><![CDATA[work粉丝订单管理 退款单添加逻辑 lifekoa 源码解析 本周阅读 轻量级易部署Node性能监控工具：Easy-Monitor pm2 log pm2 dom -diff 文件上传服务器 从零开始手写Koa2框架 四种常见的 POST 提交数据方式]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法系列1]]></title>
    <url>%2F2019%2F03%2F23%2F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%971%2F</url>
    <content type="text"><![CDATA[从0开始学算法 一些基本的数学知识向上 下取整 向下取整 数学符号⌊⌋表示 ⌊x⌋ 向上取整 数学符号⌈⌉表示 ⌈x⌉ 1⌊x⌋ = m iff m&lt;= x &lt; m +1 iff 表示 if and only if ⌈x⌉ - ⌊x⌋ 是 0 或者 1 数列1,2,3 .. n+1 第一项 a1 对数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0318]]></title>
    <url>%2F2019%2F03%2F19%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920318%2F</url>
    <content type="text"><![CDATA[work粉丝订单管理 life算法前两节 本周浏览 记一次尴尬的评论翻车事件 Nodejs教程24：Stream流 你不知道的CORS跨域资源共享 nginx配置杂记 nginx 配置 下半年计划 clean code 分享 gql 新后台 electron 或者 koa 每天一个英文问题]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一练第五期]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[copy 基本数据类型与引用数据类型在存储上的区别]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0311]]></title>
    <url>%2F2019%2F03%2F11%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920311%2F</url>
    <content type="text"><![CDATA[work主播标签 直播推流 lifeclass 本周浏览 异步操作和Async函数 30秒 CSS 中文版]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0304]]></title>
    <url>%2F2019%2F03%2F04%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920304%2F</url>
    <content type="text"><![CDATA[work两个广告提测 粉丝通处理反馈 lifeelectron 多喝水，保护嗓子 es6 本周浏览 Web 性能优化： 使用 Webpack 分离数据的正确方法 感冒了脑壳疼，怎么在家忽然感冒，鼻子现在都不想要了，呼吸之间都是在冒火]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程]]></title>
    <url>%2F2019%2F03%2F01%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[观后感系列《流浪地球》]]></title>
    <url>%2F2019%2F02%2F25%2F%E8%A7%82%E5%90%8E%E6%84%9F%E7%B3%BB%E5%88%97%E3%80%8A%E6%B5%81%E6%B5%AA%E5%9C%B0%E7%90%83%E3%80%8B%2F</url>
    <content type="text"><![CDATA[流浪地球这部末日求生的电影，非常有中国的感觉，– 落叶归根 中国人自古就有这种故土难离的思想，最有代表性的就是特别讲究 叶落归根。所以在即使到了世界要毁灭的那天，中国人做的不是逃离地球，而是带走地球 这部片子中还挺有感触的一点是，重机械感，庞大 坚固 重工机械，人类更加渺小。机械化，自动化肯定是未来社会的发展方向]]></content>
      <tags>
        <tag>观后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0225]]></title>
    <url>%2F2019%2F02%2F25%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920225%2F</url>
    <content type="text"><![CDATA[work广告 life 流浪地球读后感 clean code promise 源码 electron 添加共享功能 本周浏览的一些网页 StuQ 技能图谱 phodal 微软前端练习 程序员盲打练习 本周小练习 连字符转驼峰 123456const str = 'get_users_info'const reg = /(_.&#123;1&#125;)/gstr.replace(reg, ($1) =&gt; &#123; const newCode = $1[1].toUpperCase() return newCode&#125;)]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-数值]]></title>
    <url>%2F2019%2F02%2F22%2Fmysql-%E6%95%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[mysql float 操作mysql数据库的时候，有一列是金额，设置的字段类型是 float。 然后有一个SUM求和的方法，发现SUM 之后的结果有问题， 小数点的位数不是预期的两位。 这个的操作和js一样处理的，在js中浮点数相加，也是有位数不准确的问题 网上找到两个处理方案 将float字段改为 decimal(16,6) decimal 类型是数值的一种类型 decimal（M, D） ·M是数字的最大数（精度）。其范围为1～65，M 的默认值是10。 ·D是小数点右侧数字的数目（标度）。其范围是0～30，但不得超过M。 使用binary关键字解决 select sum(binary 字段名(float类型)) 1select sum(binary(money)) as total]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布订阅模式与redux]]></title>
    <url>%2F2019%2F02%2F22%2F%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E4%B8%8Eredux%2F</url>
    <content type="text"><![CDATA[redux 发布订阅模式发布订阅模式比较简单 1234567891011121314151617181920212223242526class Target &#123; constructor () &#123; this.list = &#123;&#125; &#125; // 订阅 listen (type, fn) &#123; if (this.list[type]) &#123; this.list[type].push(fn) &#125; this.list[type] = [fn] &#125; // 发布 trigger (type, ...arg) &#123; this.list[type].forEach(element =&gt; &#123; element(...arg) &#125;) &#125;&#125;const tar = new Target()tar.listen('sing', (name) =&gt; &#123; console.log('you are sing', name)&#125;)tar.trigger('sing', 'xiaohun') 观察者模式观察者和发布订阅有点类似 1234567891011121314151617181920212223242526272829303132333435// 被观察者class Subject &#123; constructor () &#123; this.data = [] &#125; attch (tar) &#123; this.data.push(tar) &#125; going () &#123; this.data.forEach(ele =&gt; &#123; ele.rang() &#125;) &#125;&#125;// 观察者class Observer &#123; constructor (name) &#123; this.name = name &#125; rang () &#123; console.log('rang, i am', this.name) &#125;&#125;const target = new Subject()const person1 = new Observer('tom')const person2 = new Observer('tom2')target.attch(person1)target.attch(person2)target.going() redux 中的观察者redux中有使用到 观察者模式, 来分析一下他的简单实现 使用 创建对象 1const store = createStore(reducer) store.getState() store.subscribe() store.dispatch() 实现 createStore 接收参数 reducer 返回一个对象 1234function createStore (reducer) &#123; -- something -- return &#123; getState, subscribe, dispatch &#125;&#125; getState 返回 state 123const getState = () =&gt; &#123; return state&#125; subscribe 订阅, 接受函数, 用于在 dispatch的时候执行 123const subscribe = (cb) =&gt; &#123; listens.push(cb)&#125; dispatch 分发Action, 参数是 action 1 去执行 reducer -》 更新 state 2 执行之前的订阅数组 123456const dispatch = (action) =&gt; &#123; state = reducer(state, action) listens.forEach(item =&gt; &#123; item() &#125;)&#125; 果然redux 和 react 没有什么关系， 完全可以脱离react使用]]></content>
      <categories>
        <category>开发者模式</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划0218]]></title>
    <url>%2F2019%2F02%2F18%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%920218%2F</url>
    <content type="text"><![CDATA[work退款单提测，测试反馈 广告处理 other blog 手写 Promise redux 源码 读书笔记 - clean code 流浪地球 - 观后感]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[electron开发笔记]]></title>
    <url>%2F2019%2F02%2F12%2Felectron%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[electron electron主进程 &amp;&amp; 渲染进程渲染进程像是一个普通的web组件,主进程中一看就是偏向 node 风格 运行 package.json 里 main 脚本的进程被称为主进程。在主进程运行的脚本可以以创建 web 页面的形式展示 GUI - 相当于一个 Chrome的浏览器 由于 Electron 使用 Chromium 来展示页面，所以 Chromium 的多进程结构也被充分利用。每个 Electron 的页面都在运行着自己的进程，也就是渲染进程。主进程管理所有页面和与之对应的渲染进程。每个渲染进程都是相互独立的，并且只关心他们自己的网页。 进程通信electron中的主进程和渲染进程进行通信的时候，就需要用到ipc这个特性。而ipc又分为ipcMain和ipcRenderer两个方面，分别用于主进程和渲染进程 主进程 主进程中，使用 ipcMain 只能接受消息， 但是 ipcMain 没有提供在主进程中发送消息的方法 1234567891011const electron = require('electron'); //electron 对象的引用const &#123; app, ipcMain &#125; = electron;// 接受信息ipcMain.on('checkVersion', function(event, arg) &#123; // 发送信息 event.sender.send('send back', "主进程接受到消息了')&#125;// 发送信息mainWindow.webContents.send('message', message); 如果主进程想要给渲染进程主动通信，可以使用两种方法 1 ipcMain 回调中的event 对象 2 借助 webContents 渲染进程 渲染进程 中通过 ipcRenderer 来接受消息和发送消息 1234567891011const &#123; ipcRenderer &#125; = require('electron')const ipcRenderer = electron.ipcRenderer// 接受信息ipcRenderer.on('newversion', function (event, message) &#123; console.log('newversion')&#125;)// 发送信息ipcRenderer.send('checkVersion'); electron-vueelectron-vue 是一个结合 vue-cli 与 electron 的项目，主要避免了使用 vue 手动建立起 electron 应用程序，很方便。 electron-packager vs electron-builder提供了两种打包方式 electron-packager 针对个人系统选择打包之后的结果是 electron-builder electron-upadter打包之后可以进一步实现自动更新 这里有个需要注意的问题，upadter 功能处理自动更新的时候，需要使用应用签名 对于 Mac而言，要先具备 Apple Developer 中开发者资格 才能在本机创建相关 签名 Electron 打包Mac安装包代码签名问题解决方案 更换了查询更新的方案，通过服务器上的接口进行通信，将版本信息写入服务器的静态文件来判断 个人应用之前用vue写了一个本地开启服务器demo，git 地址 核心思路是在server端直接开启一个启动shell脚本的子进程。本来想丢到服务器给大家用，这样不用每次都去翻服务器配置文件了。 核心代码为 然而，组内大佬过来看了两眼就发现问题了：开启登录服务器的那个进程是在server端处理的，那么项目如果部署到服务器之后，怎么能开启用户自己的 终端去登录服务器呢？ 大佬建议使用electron包裹一层，也就是把开启终端的那个部分的逻辑放到electron操作 而不是在server中处理 赞！ 项目之前是vue版本的，刚好vue 有一套配合electron的轮子可以直接用。 项目安装 vue init simulatedgreg/electron-vue vvbuild 开发入口文件在 oackage.json 中的main参数 是electron的入口文件 （ 主进程 ） 1"main": "./dist/electron/main.js", electron运行package.json中的main字段标明脚本的进程称为主进程 在主进程创建web页面来展示用户页面，一个electron有且只有一个主进程 electron使用Chromium来展示web页面，每个页面运行在自己的渲染进程中 不过上面的那个路径是编译后的，我们自开发的时候，主进程文件地址是 src/main/index.js 这里面的配置已经由轮子创建了好了，对比直接使用electron，多了一些环境配置 功能基本配置用于进行展示列表数据 个人服务器配置信息都在本地 /tmp/config 文件中 直接从这里读取 1234567mounted() &#123; // 读取用户本地有没有 /tmp/ const isEixst = fs.existsSync(configRoot); if (!isEixst) return; const result = JSON.parse(fs.readFileSync(configRoot, 'utf-8')); this.tableData = result;&#125;, 后期增加了数据共享功能，通过接口将数据写入mysql数据库中，因此页面中增加了分组配置展示部分 用户本地 /tmp/config.json 其实在这里存储有一个不好的地方 – 一旦关机 此文件就会被清除 开启进程 12345678handleClick() &#123; const content = `#!/bin/bash \n \n $&#123;server&#125; $&#123;address&#125;`; fs.writeFileSync(shRoot, content); // 2 给脚本增加运行权限 exec(`chmod +x $&#123;shRoot&#125;`, &#123; silent: true &#125;); // 3 打开一个新的终端去执行这文件 exec(`open -a Terminal $&#123;shRoot&#125;`)&#125; 由于electron 提供了node环境 可以直接打开终端 electron 中可以使用shell，比如开启一个网页 123import &#123; shell &#125; from 'electron';shell.openExternal('http://www.baidu.com') 遇到的问题eslintelectron-vue 默认开启 eslint检查 开发中一旦不遵守规则就会报错 非常不友好 后期调整了eslint配置 涉及的文件有三个，都位于目录.electron-vue/下，分别是： 123.electron-vue/webpack.main.config.js.electron-vue/webpack.renderer.config.js.electron-vue/webpack.web.config.js 由于在 webpack中加入了eslint-loader检测 所以会有编译检查 可以直接注释掉 build 停滞开始使用的是 npm 去执行build 但是在 这里就一直停止不动 等了好久 后面尝试了 删除 node_modules 重新来依旧不动 最后换成yarn 重新来就可以了 1yarn build:darwin 打开开发者工具在开发过程中 这个app使用快捷键可以打开开发者 但是一旦编译 就打不开了 在build -&gt; electron.js 中 添加代码如下 1mainWindow.webContents.openDevTools(&#123; mode: 'left' &#125;); 相当于自动打开APP的开发者工具 编译之后的APP 打开出错前一天可以编译成功的APP 今天忽然就不可以了 本地启动是可以的 尝试解决方案 删除 node_modules 重新安装 跨域处理渲染进程中有涉及多个接口请求，但是会有跨域问题，electron提供了一个参数可以处理 123mainWindow = new BrowserWindow(&#123; webPreferences: &#123;webSecurity: false&#125;,&#125;) 完全不需要设置服务端，非常方便 无法使用复制粘贴mac 在开发中是可以是用复制粘贴功能的，但是一旦打包编译，就会发现快捷键失效，需要开发者自行实现这种功能 主进程中配置 12345678910111213141516171819202122232425import &#123; Menu &#125; from 'electron'const template = [ &#123; label: 'Application', submenu: [ &#123; label: 'Quit', accelerator: 'Command+Q', click: function () &#123; app.quit() &#125; &#125; ] &#125;, &#123; label: 'Edit', submenu: [ &#123;label: 'Copy', accelerator: 'CmdOrCtrl+C', selector: 'copy:'&#125;, &#123;label: 'Paste', accelerator: 'CmdOrCtrl+V', selector: 'paste:'&#125; ] &#125;]Menu.setApplicationMenu(Menu.buildFromTemplate(template)) 莫名其妙的问题遇到奇奇怪怪的问题，一律尝试 删除node_modules 重新 yarn 安装 参考文章 Electron-vue开发实战1——Main进程和Renderer进程的简单开发]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hi,2019]]></title>
    <url>%2F2019%2F02%2F11%2Fhi-2019%2F</url>
    <content type="text"><![CDATA[看来新年睡到自然醒的这个愿望依旧不会实现，不过今年是被楼下的钢琴声敲醒的。 hi, 2019。再见，2018。 回顾年终总结总要先回顾一下18年的flag有没有完成 18年中5个flag中 其中的23完成度有80% 其余的都是60%勉强到及格线 感觉人对于习惯的培养是最困难的，18年中由于工作或者生活或者纯粹的个人爱好说要注意一下个人习惯的养成，比如旅游的时候要写一篇游记，看电影要写一篇感悟，都因为各种各样的原因，一推再推然后就没影了， 工作18年的主要项目组发生了两次变动，更换项目组之后有短期的不适应，由于业务方向的不同，需要侧重的技术点也不一样，相对于之前，更加注重用户体验，在某些考虑到体验的细节方面要比在功能开发上占用的时间更多。 新的项目组在和同事交接过程出现了一些问题，导致项目维护出现了极大的困难，干脆就直接重构了。 后面也是在某些地方挖了坑，导致之后又浪费了大量的时间精力去修补，这个是18年工作中感觉出现最不应该的一个问题，当时的个人心态也是简直要崩，一方面是自我怀疑 一方面是问题处理的压力。后面是在各个部门同事协调下终于把这件事情结束了。 那段时间简直是乌云盖顶，记得那天晚上回去之后和舍友说，终于结束了。心里简直放下了一个大石头。 这段经历最大的收获就是作为开发者对于自己代码的把控，还有当发现问题之后与同事之间的合作沟通。 个人 入职之后一直在用react以及它的各种全家桶，但是没有好好看过它的核心源码，19年要读一读react源码 生活 博客 18年写的博客主要在掘金发布，其中个人感觉最有意思的是关于 jwt 和 Linux 这两篇，前者在于评论的沟通中查询了很多文章，Linux则是因为这个是阅读笔记，时间很长，因为初期根本看不下去，果然还是之前缺失的，生活总会让你补回来。计算机基础不熟悉，Linux这本书读起来超级头痛 读书 18年读的书大部分是工作相关的 Linux私房菜、webpack解读、react全栈、深入浅出webpack 、工程师的自我修养、前端架构设计 19年阅读计划，目前手上有的两本是关于代码风格的书是组内同事推荐的，《代码整洁之道》和 《重构》。 预计在 6月结束 生活 18年遇到一些很棒的陌生人。 第一位，楼下练习钢琴的人。 是在大概6，7 月份搬到这里的，自从搬来之后，楼下的钢琴声就一直没有断过。 作为一个对钢琴一窍不通的旁听者来说，这位的钢琴水平已经不错了， 7月份的时候大概在一直重复一首曲子的某一些章节在弹，至少听起来已经挺流畅了，这个曲子很熟悉，不过听了好久我们都没有听出来是哪一首。 到现在，她已经开始练习弹奏指法比较复杂的曲子了，之所以觉得指法比以前复杂，是因为每一个音符之间变的非常紧密，就像我有时候听到非常快的rap一样，简直跟不上节奏无法呼吸。 她每天的练习时间非常长，我觉得平均下来和我们上班时间差不多了，一般在上午大概 9 或者 10点左右开始，到中午大概11点，然后下午2或者3点开始 到下午5点左右结束，晚上有时候也在弹，有段时间在晚上9点左右还在弹。 她好像没有上学，因为周一周五都有琴声（ 我和舍友是上班党，但是偶尔有事请假在家的时候可以听到 ），她好像没有假期，因为周末也有琴声。 一首曲子百次千次的练习，在这种重复重复再重复的枯燥乏味的练习中，每次不断进步不断变的更加熟练更加优秀。这种非常强大的自控力和忍耐力让我非常敬佩。 而且可能是因为我们搬来的时候她已经形成了这种习惯，所以并没有听到有父母在一旁监督训斥，或者小孩子忍受不了要哭的声音。（ 可能不是小孩子了 ） 所以优秀的人之所以优秀，在看不到的背后有多少汗水真的难以想象。 第二位，思想的启发者。 18年的时候，偶尔看到了两三个很棒的公众号，这些博主从各个方面鼓励女性如何去思考，去生活，文章传递出的价值观非常棒，有的是讲为什么要与传统割裂，有的是讲怎么在现在要更好的独立自主 我觉得她们就像夜里燃烧的火把，告诉大家，不要做睁眼瞎，除了以前那种生活方式，还有另外的路可以选择。就像历史上各种改革的浪潮，推翻被灌输的那些不合理的认知，重新思考。 2019年的计划 读书计划 技术-《代码整洁之道》《重构》 读书 这是一个动词，18年我做了两次分享，发现有一个很大的问题，我的嗓子在开场20分钟之后，就开始变得沙哑无力， 每天念书10分钟，争取改善这种问题 习惯 老调重弹，不要熬夜不要熬夜，买一个日历，哪天熬夜了就画一个圈圈，用直观的刺激希望可以丢掉这个坏毛病]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>love</tag>
        <tag>告别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode使用指北]]></title>
    <url>%2F2019%2F01%2F25%2Fvscode%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[vscode 使用笔记 #### 打开控制面板 F1 / cmd + shift + p shell在shell中直接输入 code -r 。 就可以打开这个项目了 光标位置回到上一个光标的位置，Cmd+U 在不同的文件之间回到上一个光标的位置 Control + - (你改了a文件，改了b文件之后想回到a文件继续编辑，mac使用controls+-) 选中文本选中单词 Cmd+D 代码踢动Option+上下方向键 代码移动的同时按住shift就可以实现代码复制 Option+Shift+上下 注释注释有两种形式，单行注释和块注释(在js中，单行注释//,块注释/**/) 单行注释 Cmd+/ （win Ctrl +/）块注释 Option+Shift+A 代码缩进单个文档进行缩进调节， 使用Cmd+Shift+P打开命令面板，输入缩进,然后选择相应的命令 other合并代码行，多行代码合并为一行，Cmd+J 行排序，将代码行按照字母顺序进行排序，无快捷键，调出命令面板，输入按升序排序或者按降序排序 Cmd+P 输入你要打开的文件名,回车打开 . 选中你要打开的文件后，按Cmd+Enter,就会在一个新的编辑器窗口打开 行跳转如何快速跳转到某一行 Ctrl+g 输入行号 如果你想跳转到某个文件的某一行，你只需要先按下 “Cmd + P”，输入文件名，然后在这之后加上 “:”和指定行号即可。 f12跳到函数的定义处 Cmd+f12(win Ctrl+f12)跳转到函数的实现处 插件使用 Polacode 代码截屏 参考文章文章来源 markdown 中表格自动化快捷键 - option + shift + f clicke me]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次shell手误的修复]]></title>
    <url>%2F2019%2F01%2F17%2F%E4%B8%80%E6%AC%A1shell%E6%89%8B%E8%AF%AF%E7%9A%84%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[手误之后 基本命令失效 在shell中 变量的设置是 1name=123 变量的追加是 1name=$name:9090 之前在使用 umi 创建项目的时候 为了解决出现的问题 在 ~/.zshrc 中添加了一个 PATH 路径 应该是 1export PATH=$PATH:/Users/zhengzaijiazai/.nvm/versions/node/v8.11.2/bin 但是第一次写的时候 没有加 $PATH 1export PATH=/Users/zhengzaijiazai/.nvm/versions/node/v8.11.2/bin 保存之后 source 使其生效 然后，基本命令不可用了 最常用的ls vim 都不可用了 这下想重新打开 zshrc 重新修改也没法了 解决方案 定义临时变量 1export PATH=/usr/bin:/usr/sbin:/bin:/sbin:/usr/X11R6/bin 这个相当于定义了一个局部的 PATH 变量 然后基本命令可以使用了 重新vim 调整 zshrc 就可以了]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react状态管理]]></title>
    <url>%2F2019%2F01%2F16%2Freact%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[redux saga dva 科普篇 redux最基础的就是使用 redux 来处理 这里是展示组件结构 12345678910111213141516171819202122232425import &#123; connect &#125; from 'react-redux'import &#123; valueAdd, valueReduce &#125; from './redux/action'class Main extends Component &#123; render () &#123; return ( &lt;div className="App"&gt; &lt;header className="App-header"&gt; &lt;p onClick=&#123;() =&gt; this.props.valueAdd()&#125; &gt; 点击 + 1 &lt;/p&gt; &lt;p onClick=&#123;() =&gt; this.props.valueReduce()&#125; &gt; 点击 - 1 &lt;/p&gt; &lt;div&gt; i am &#123;this.props.number&#125; &lt;/div&gt; &lt;/header&gt; &lt;/div&gt; ) &#125;const MainBox = connect( (state) =&gt; &#123; return &#123; number: state.number &#125;&#125;, dispatch =&gt; &#123; return &#123; addNumber: () =&gt; &#123; dispatch(valueAdd()) &#125;, reduceNumber: () =&gt; &#123; dispatch(valueReduce()) &#125; &#125; &#125;)(Main)export default MainBox 借助 bindActionCreators 调整一下 12345678910111213141516171819202122import &#123; connect &#125; from 'react-redux'import &#123; bindActionCreators &#125; from 'redux'import * as action from './redux/action'@connect( (&#123;number&#125;) =&gt; (&#123;number&#125;), dispatch =&gt; bindActionCreators(action, dispatch))class Main extends Component &#123; render () &#123; return ( &lt;div className="App"&gt; &lt;header className="App-header"&gt; &lt;p onClick=&#123;() =&gt; this.props.valueAdd()&#125; &gt; 点击 + 1 &lt;/p&gt; &lt;p onClick=&#123;() =&gt; this.props.valueReduce()&#125; &gt; 点击 - 1 &lt;/p&gt; &lt;div&gt; i am &#123;this.props.number&#125; &lt;/div&gt; &lt;/header&gt; &lt;/div&gt; ) &#125;&#125;export default Main redux-saga文档阅读 常用API 方法 建议 takeEvery 监听派发的动作，如果action type匹配的话，会执行对应的函数 put 派发Action， 可以理解成为redux中的dispatch函数 call 调用函数执行，阻塞 fork 调用函数执行，不会阻塞 使用方式对比于 redux，使用saga的时候只需要调整一下store的生成 123456789101112import &#123; applyMiddleware, createStore &#125; from 'redux';import createSagaMiddleware from "redux-saga";import rootSaga from "./saga" //引入rootSagaimport reducer from './reducer'let sagaMiddleware = createSagaMiddleware()export const store = createStore( reducer, applyMiddleware(sagaMiddleware),);sagaMiddleware.run(rootSaga); // 开始执行rootSaga 添加一个 saga 文件 123456789101112131415161718function * add () &#123; // 派发Action yield put(&#123; type: ACTION_ADD &#125;)&#125;function * reduce () &#123; yield put(&#123;type: ACTION_REDUCER&#125;)&#125;function * watchAdd() &#123; // 监听派发给仓库的动作，如果动作类型匹配的话，会执行对应的监听生成器 yield takeEvery(ACTION_ADD_SAGA, add) yield takeEvery(ACTION_REDUCER_SAGA, reduce)&#125;export default function * rootSaga() &#123; yield watchAdd()&#125; saga 有三种，做工作的 进行监听的 以及 rootsage 1 worker saga 做具体的工作，如调用API，进行异步请求，获取异步封装结果 2 watcher saga 监听被dispatch的actions,当接受到action或者知道其被触发时，调用worker执行任务 3 root saga 启动saga的唯一入口 dvadva 可以视为内部封装了redux-saga 安装 1npm install -g dva-cli 使用dva生成项目 1dva new xxxname dva 项目结构 dva 的文件结构命名有点奇怪， 比如这个 routes 文件夹 其实不是路由处理，里面是组件，（与该路由对应的组件） models 则是将 action reducer action_type 编写到一起了 入口文件 index.js在index.js 实现一些配置 比如 定义默认state 添加中间件 引入model= 1234567891011121314151617import dva from 'dva';import &#123;createLogger&#125; from 'redux-logger';// 1. Initialize const app = dva(&#123;&#125;);// 2. Plugins// app.use(&#123;&#125;);// 3. Modelapp.model(require('./models/main').default);app.model(require('./models/users').default);// 4. Routerapp.router(require('./router').default);// 5. Startapp.start('#root'); 可以设置的全部属性参数为 123456789101112const app = dva(&#123; history, // 路由控制 initialState, // 基础state 优先级高于 model 中的 state onError, // effect 执行错误或 subscription 通过 done 主动抛错时触发，可用于管理全局出错状态 onAction, // 在action被dispatch时触发，用于注册 redux 中间件。支持函数或函数数组格式 onStateChange, // 顾名思义，在state变动的时候触发 onReducer, onEffect, onHmr, extraReducers, extraEnhancers,&#125;) app.use 可以添加中间件 app.model 所有的model都要通过这个方法挂载到app app.router 挂载定义的路由 app.start 启动app 核心部分 models1234567export defult &#123; namespace: '', state: '', reducers: &#123;&#125;, effects: &#123;&#125;, subscriptions: &#123;&#125;&#125; key 含义 namespace model 的命名空间，是在全局 state 上的属性 state state 初始值 reducers 唯一可以修改 state 的地方，由 action 触发 effects 用于处理异步操作和业务逻辑，不直接修改 state。由action 触发， subscriptions 用于订阅一个数据源，然后根据需要 dispatch 相应的 action 感觉如果项目决定使用 redux-saga 可以考虑直接使用 dva umi 呜咪 （和喵喵并没有什么关系） 1npm i -g umi 创建文件 1mkdir project &amp;&amp; cd project &amp;&amp; yarn create umi &amp;&amp; cnpm i 这个没什么好说的，就一个项目创建脚手架，可以包含测试 编译 部署等流程 就像使用种组装了一辆汽车 而用户来选择需不需要加车窗 轮子等部件 参考文章 dav 基本使用]]></content>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个登陆的shell脚本]]></title>
    <url>%2F2019%2F01%2F15%2F%E4%B8%80%E4%B8%AA%E7%99%BB%E9%99%86%E7%9A%84shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[编写一个shell脚本，不用每次都查询服务器地址了 项目涉及到好多关于登陆的shell命令，比如登陆服务器，链接redis等 编写一个shell脚本，不用每次都查询服务器地址了 shell脚本格式 第一行是 #!/bin/bash 因为我们使用的是bash， 已 #!/bin/bash 开头声明文件语法是用的是bash语法。 当程序被执行的时候，会加载bash相关环境配置文件 如果不写的话，系统可能无法判断程序需要什么shell来执行 #相当于注释 除了在 #!/bin/bash 行出现的 # ，其余的在开头的 都表示的此行代码被注释 通过命令输入变量可以编写命令行直接输入变量值 命令与变量的对应是 12某一条命令 xxx xxx$0 $1 $2 比如 写一个输入变量的shell脚本 1echo i am variable &apos;$1&apos;, $1 执行一下 12sh variable.sh mxtx// i am variable $1, mxtx 还有一些特殊的变量含义 $# 表示后面有几个参数 与用户交互 readread 命令可以获取到键盘输入信息 1read [-pt] variable 其实感觉和创建了一个本地变量的概念类似 比如执行 123read name // 命令行进入等待状态i am tom // 回车结束输入 然后输出一下这个 name 的变量值 1echo $name // i am tom 使用 -p 编写一个带有提示的命令 1read -p &quot;please enter your name:&quot; if 语句123if [ 条件 ]; then 条件成立时候要执行的操作fi 这个格式必须这么固定 最后一行就是 fi 表示结束if 语句了 写一个例子，当输入的第一个变量值是 1 就输出 boy 就输出 否则 为 girl 12345if [ $1 == 1 ]; then echo boyelse echo grilfi 如果是多个条件 12345if [ 条件1 ]; then 条件1成立时候要执行的操作elif [ 条件2 ]; then 条件2成立时候要执行的操作fi shell脚本的调试脚本写完之后不一定保证写的正确，可以先进行一个语法的检查 1sh -n youshell.sh 有三个参数可以使用 参数 含义 n 不执行脚本 只检查语法 v 执行前将脚本内容输出 x 将使用的内容输出 编写脚本123456789101112131415161718read -p "enter your choice: " choice# 定义变量test='work@xxxx'master='work@xxx'redis='xxxxxxx'echo $choice# 根据输入值 进行条件判断if [ $choice == test ]; then ssh $testelif [ $choice == master ]; then ssh $masterelif [ $choice == redis ]; then redis-cli -h $redisfi 项目编写根据添加的配置信息 生成shell脚本]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-refs]]></title>
    <url>%2F2019%2F01%2F08%2Freact-refs%2F</url>
    <content type="text"><![CDATA[refs react 中通过设置ref可以获取react元素 直接使用ref createRef 123456789101112131415class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; values () &#123; const val = this.myInput.current &#125; render() &#123; return &lt;div&gt; &lt;div ref=&#123;this.myRef&#125; /&gt; &lt;input ref=&#123;this.myInput&#125; /&gt; &lt;/div&gt; &#125;&#125; refs and the dom]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue初探]]></title>
    <url>%2F2018%2F12%2F28%2Fvue%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[vue 初探 安装vue的文件编译差不多也是react那一套 大概在loader会有不同 因为重点在熟悉Vue 而不是webpack 没有做单独的配置 直接使用vue-cli 生成 1cnpm i vue-cli router 的使用12345678910111213141516171819import Vue from 'vue';import Router from 'vue-router';Vue.use(Router); //挂载属性//创建路由对象并配置路由规则let router = new Router(&#123; routes: [ //定义路由对象 &#123; path: '/', component: Tabs &#125;, &#123; path: '/article', component: Article &#125;, ]&#125;);// 在创建 vue实例的时候 要传入routernew Vue(&#123; el: '#app', //让vue知道我们的路由规则 router: router, //可以简写router&#125;) 使用router进行参数传递1&lt;router-link :to="&#123;name:'detail',params:&#123; id: id, title: title &#125;, query :&#123;author&#125;&#125;"&gt;detail&lt;/router-link&gt; 子页面做解析 1&lt;h3&gt; &#123;&#123;$route.params.title&#125;&#125; &lt;/h3&gt; 有一个奇怪的问题，就是进入子页面刷新，子页面数据就没有了， 为了确定这个现象，在组件的 mounted 生命周期 log 一下 参数 123mounted: function () &#123; console.log(this.$route.params.title)&#125; 初次进入是有的，但是刷新的话的确是没有的。 目前没有看懂为什么会这样 解析router 属性 含义 $route.path 对应当前路由的路径 $route.params key/value 对象 $route.query 传参对象 $route.hash 当前路由的 hash 值 (不带 #) $route.fullPath 完成解析后的 URL，包含查询参数和 hash 的完整路径 $route.matched 数组格式，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象 $route.name 当前路径名字 404vue有一个有意思的功能 页面404 直接在路由页面中添加 1234&#123; path: '*', component: Error&#125; 当用户访问的路径不存在时，就会展示这个组件 vue 生命周期vue 几个常用的生命周期函数 ) 相对于react 来说， vue的生命周期函数要多一些，而且有的看起来，性质差不多，比如 create 和 mounted 无法从字面感受有什么区别 在组件里打几个log看一下 beforecreated：el 和 data 并未初始化 created:完成了 data 数据的初始化，el没有 beforeMount：完成了 el 和 data 初始化 mounted ：完成挂载 组件引入子组件1234components: [ Table, Model] 组件之间的数据传递 子级组件使用父级组件的方法 父级通过 v-on 绑定 1&lt;Form v-if=&quot;isShow&quot; v-on:hideForm=&quot;hideModal&quot; &gt;&lt;/Form&gt; 子级通过 $emit 触发 1&lt;el-button @click="$emit('hideForm')"&gt;取消&lt;/el-button&gt; UI库vue的比较常用的UI库 有element 样式 引入第三方css 提供了三种方式 1 入口js文件引入 1import 'swiper/dist/css/swiper.css' 2 写到 html 模板文件中 3 组件中引入 1@import 'swiper/dist/css/swiper.css']]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mock数据]]></title>
    <url>%2F2018%2F12%2F26%2Fmock%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[前端可通过 Mockjs 模拟数据 独立与后端开发 安装12cnpm i mockjs -Dimport mock from 'mockjs' 语法Mock.mock(template) mock 接受一个模板，将根据定义的模板生成对应格式的数据 数据模板template 可以是一个数据对象 – 属性名、生成规则、属性值 1'name|rule': value 比如生成一个长度为 3 的数组 1234let data = Mock.mock(&#123; 'id|3': [1]&#125;)// &#123; id: [ 1, 1, 1 ] &#125; ‘name|min-max’: value value格式 作用 string 重复string生成结果，重复次数区间[min, max] number 生成整数, 区间[min, max]。 也就是这里的 value 并没有什么意义 object 随机选取 object 中 min 到 max 个属性 生成新对象 array 重复属性值 array 生成一个新数组，重复次数区间[min, max] 12'name|1-3': '中文' // name: '中文中文中文' 'id|1-3': 18 // id: 3 ‘name|count’: values value格式 作用 string 重复string生成结果，重复次数 count object 从对象 object 中随机选取 count 个属性 array 重复属性值 array 生成一个新数组，重复次数区间[min, max] 1234567'users|2': &#123; name: 'tome', age: 20, habit: 'listen'&#125;// users: &#123; age: 20, habit: 'listen' &#125; // users: &#123; name: 'tome', habit: 'listen' &#125; other ‘name|1’: boolean 随机生成一个布尔值, true/false 的概率各为50% 数据占位符 @占位符template 可以是一个占位符 Mock.Random 是一个工具类，用于生成各种随机数据。Mock.Random 的方法在数据模板中称为“占位符”，引用格式为 @占位符(参数 [, 参数]) 这里简单列举几个常用的占位符 比如生成 长度为5 的字符 12Mock.mock('@string(5)') Mock.mock('@csentence(5)') // 中文 生成 图片 1Random.image('200x100', '#50B347', '#FFF', 'Mock.js') 具体点击查看文档 应用获取文章列表数据 比如 主要的参数为 id img title 123456789101112let getArticles = (tabId = 1) =&gt; &#123; let data = Mock.mock(&#123; 'articles|10': [ &#123; 'id|+1': 0, img: Random.image('200x100', '#f1f1f1', '#FFF', 'ARTICLE BANNER'), title: tabId + '@csentence(3, 10)' &#125; ] &#125;) return data&#125; 点击git查看 参考文章 Mock.js - 模拟数据生成器]]></content>
      <categories>
        <category>第三方插件使用</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>mockjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react源码解析]]></title>
    <url>%2F2018%2F12%2F25%2Freact%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[react 源码分析第一章节 写一个简单的react组件 123&lt;div className="App"&gt; react box&lt;/div&gt; 我们在babel中看一下，代码将会被编译为 1234567"use strict";React.createElement( "div", &#123; className: "App" &#125;, "react box"); 添加一个子元素 1234&lt;div className="App"&gt; react box &lt;p className='p' data-age='1123'&gt; i am p &lt;/p&gt;&lt;/div&gt; babel的转义结果 123456789101112"use strict";React.createElement( "div", &#123; className: "App" &#125;, "react box", React.createElement( "p", &#123; className: 'p', 'data-age': '1123' &#125;, " i am p " )); 我们在组件中log一下这个结果是什么 12345678910111213import React from 'react'const end = React.createElement( "div", &#123; className: "App" &#125;, "react box", React.createElement( "p", &#123; className: 'p', 'data-age': '1123' &#125;, " i am p " ));console.log(end, 'end') 简单概括为 12345678props: &#123; children: [ 子元素A, 子元素B ], className: '本元素的类名', 本元素的其他属性名: '本元素对应的其他属性值',&#125;,type: '本元素的标签名' 这个 ReactElement 类型的js对象就是React组件了 也就是 react 将这种对象最后 render 到html文件中的 看下流程图 createElement 方法看下react 的 createElement 源码 源码 12345678910111213141516171819function createElement(type, config, children) &#123; .... return ReactElement(...)&#125;function ReactElement(...) &#123; var element = &#123; $$typeof: REACT_ELEMENT_TYPE, type: type, key: key, ref: ref, props: props, _owner: owner &#125; ... return element&#125; 使用方式 12345678910// React.createElement(// type,// [props],// [...children]// )React.createElement( div, &#123;className: 'ele'&#125;, null) 实现 createElement 方法 1234567891011121314151617class React &#123; constructor (type, props) &#123; this.type = type this.props = props &#125;&#125;class createElement &#123; constructor(type, props, ...content) &#123; // 因为 props 和 content 都会变为 React 对象的 props 属性值 let allProps = Object.assign(&#123;&#125;, props, &#123; children: content&#125;) return new React(type, allProps) &#125;&#125;let ele = new createElement('div', &#123; className: 'ele' &#125;, 'i am div', new createElement('p', &#123;&#125;, 'i am p'))console.log(ele)]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章阅读笔记-技术杂谈]]></title>
    <url>%2F2018%2F12%2F24%2F%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[在阅读文章的时候，一些有意思的知识点 css Chrome - 调试技巧 $ console.table 当想要输出的对象是一个数组的时候 可以用这个以表格形式查看 h 隐藏、显示元素 选中元素后 按一下’h’来轻松隐藏你在元素面板中选择的元素。再次按下’h’可以使它出现 run commend qconf qconf 启动中报错 处理共享内存]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[img在flex布局中的表现]]></title>
    <url>%2F2018%2F12%2F21%2Fimg%E5%9C%A8flex%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[奇奇怪怪 最近在进行css布局调试的时候，发现一些flex布局的有趣现象 html 结构如下 1234&lt;div&gt; &lt;p&gt; something &lt;/p&gt; &lt;img src="xxx" alt=""&gt;&lt;/div&gt; css 为flex 布局 12345678910div &#123; background: #ccc; width: 400px; padding: 20px; display: flex;&#125;p &#123; padding: 10px; background: #fff; &#125; 效果为 灰色块为div部分 这里的图片可以看到是超出了div盒子 我的预期是图片可以被缩小，不会超出盒子 然后不用图片，换成普通元素 1234&lt;div&gt; &lt;p&gt; something &lt;/p&gt; &lt;section&gt; xxxx &lt;/section&gt;&lt;/div&gt; 123456section &#123; padding: 10px; background: #000; margin-left: 10px; color: #fff;&#125; 可以看到 右侧的section并没有发生像图片那种超出盒子的现象 而且即使给 右侧元素添加一个超大的width值，其样式并不会变化 也就是对于图片没有做像文字这种折行处理，也没有按照预想的进行缩小处理 要想实现这种图片占满剩余空间的效果，需要给图片添加指定宽度 1img &#123; width: 100%; &#125; 为什么出现这种问题呢？ 对于有默认大小的元素 图片本身是有大小的，不像 div p span 这些标签。那用input 尝试一下 和图片的表现一样 width &amp;&amp; min-width 一个元素 同时设定width 和 min-width 值 其真正展示的效果是按照这里面的最大值 1&lt;div class='width'&gt; width or min-width &lt;/div&gt; 指定这个元素的 min-width 高于 width 1.width &#123; width: 100px; min-width: 300px; color : #fff; &#125; 最后呈现出来的元素是 300px 的效果 图片本身有宽度，就相当于有一个 min-width 值呢 来模拟一个 div 123&lt;div class='min'&gt; &lt;p&gt; a b c &lt;/p&gt;&lt;/div&gt; 子元素 同时设置 width 和 min-width 12345div &#123; display: flex; &#125;.basis p &#123; width: 100%; min-width: 300px;&#125; 也是超出了盒子大小 参考文章 深入理解 flex 布局以及计算]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程]]></title>
    <url>%2F2018%2F12%2F21%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-node%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%2F</url>
    <content type="text"><![CDATA[第二章 模块规则 commomjs 模板规范 模块标识 1require('xxx') 模块标识 就是传递给require的参数 它必须是符合小驼峰命名的字符串 可以没有后缀js node的模块实现node 引入模块的步骤 路径分析 -&gt; 文件定位 -&gt; 编译执行 node的模块分类： 核心模块 文件模块 核心模块 在node进程启动的时候 部分核心代码就被加载在内存中， 文件模块则是在运行动态加载， 需要进行完成的 以上三个步骤 优先缓存 第七章 网络编程 OSI 七层模型OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层） 每一层实现各自的功能和协议，并完成与相邻层的接口通信。 物理层 网线 数据链路层 比如网卡，处理与物理设备做交互 网络层 ip 协议什么的，基础的网络 数据在网络中分组传输，网络层处理这些分组数据 传输层 tcp 协议什么的 处理端口之间的通信 会话层 表示层 处理数据安全等 应用层 http https 处理网络数据和应用程序的交互 平时有用过的那个 nginx 是处理的7层，http协议部分 在四层中（数据链路层 、网络层、 传输层、应用层）运行的协议，称之为 TCP/IP协议族 TCP/IP协议族 数据传输的时候 在每一层会做加工处理 通过上图可以看出来，这七层，每一层都可以做的事情 1 将上层传递数据包装为满足该层协议的数据包 2 将下层的数据解析为满足该层协议的数据包 3 与其余层的数据交互 看一下常见的协议与七层的关系 端口TCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。 端口是传输层的东西 在同一台计算机，两个不同的进程 （pid为进程的标识） 之前进行数据传递，可以通过共享内存等方式。那如果是不同计算机的两个进程呢，需要借助另外的方式处理 — 借助 端口（全称是协议端口号 (protocol port number)，简称端口） 套接字概念 ： IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：「ip地址＋协议＋端口号」唯一标示网络中的一个进程 这就是说，虽然通信的重点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的端口，剩下的工作就由 TCP 来完成了 IP协议 （Internet Protocol）按层次分,IP(Internet Protocol)网际协议位于网络层。 TCP/IP 协议族中的 IP 指的就是网际协 议,协议名称中占据了一半位置,其重要性可见一斑。可能有人会把“IP”和“IP 地址”搞混,“IP”其实是一种协 议的名称。IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里,则需要满足各类条件。其中两个 重要的条件是 IP 地址和 MAC 地址(Media Access Control Address) IP 地址指明了节点被分配到的地址,MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配 对。IP 地址可变换,但 MAC 地址基本上不会更改 ARP 协议 IP 间的通信依赖 MAC 地址。在网络上,通信的双方在同一局域网(LAN)内的情况是很少的,通常是经过多台计算机和网络设备中转才能连接到对方。 而在进行中转时,会利用下一站中转设备的 MAC 地址来搜索下一 个中转目标。这时,会采用 ARP 协议(Address Resolution Protocol)。 ARP 是一种用以解析地址的协议, 根据通信方的 IP 地址就可以反查出对应的 MAC 地址。 tcp按层次分,TCP 位于传输层,提供可靠的字节流服务。 字节流服务(Byte Stream Service) 为了方便传输,将大块数据分割成以报文段(segment) 为单位的数据包进行管理。而可靠的传输服务是指,能够把数据准确可靠地传给对方。一言以蔽之,TCP 协 议为了更容易传送大数据才把数据分割,而且 TCP 协议能够确认数据最终是否送达到对方。 三次握手 为了准确无误地将数据送达目标处,TCP 协议采用了三次握手(three-way handshaking)策略。用 TCP 协议把数据包送出去后, TCP 不会对传送后的情况置之不理,它一定会向对方确认是否成功送达 服务端 12345678910111213141516171819let net = require('net')let server = net.createServer(function (socket) &#123; console.log('服务端：收到来自客户端的请求') socket.on('data', function (data) &#123; console.log('服务端：收到客户端数据，内容为&#123;' + data + '&#125;') // 给客户端返回数据 socket.write('你好，我是服务端') &#125;) socket.on('close', function () &#123; console.log('服务端：客户端连接断开') &#125;)&#125;)server.listen('8124', 'localhost', function () &#123; console.log('服务端：开始监听来自客户端的请求')&#125;) talnet 可以和服务器进行对话 udpudp 和 tcp 同属于网络传输层 创建udp套接字 12let dgram = require('dgram')let server = dgram.createSocket('udp4') server 既可以做为客户端发送数据 也可以作为服务端接受数据 dgram模块用于创建基于UDP协议的网络服务，创建不分客户端不分客户端、服务器端，在一端使用dgram.createSocket即可发送数据也可以接收数据。 DNS (Domain Name System)DNS 服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务 (也可以逆向从 IP 地址反查域名 的服务) http 首先作为发送端的客户端在应用层(HTTP 协议)发出一个想看某个 Web 页面的 HTTP 请求。接着,为了传输方便,在传输层(TCP 协议)把从应用层处收到的数据(HTTP 请求报文)进行分割,并在 各个报文上打上标记序号及端口号后转发给网络层。在网络层(IP 协议),增加作为通信目的地的 MAC 地址后转发给链路层。这样一来,发往网络的通信请求 就准备齐全了。接收端的服务器在链路层接收到数据,按序往上层发送,一直到应用层。当传输到应用层,才能算真正接收 到由客户端发送过来的 HTTP 请求。 三次握手 12 请求报文 1234GET /life/index HTTP/1.1Host: 127.0.0.1:9997User-Agent: curl/7.43.0Accept: */* 参数 含义 GET 表示请求访问服务器的类型 /life/index 请求的资源对象 HTTP/1.1 客户端使用的 HTTP 协议 这段请求内容的意思是:请求访问某台 HTTP 服务器上的 /life/index 资源 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。 相应报文 1234567HTTP/1.1 200 OKContent-Type: text/html; charset=utf-8Content-Length: 13976Date: Thu, 27 Dec 2018 12:32:38 GMTConnection: keep-alive&lt;!doctype html&gt;html .... 参数 含义 HTTP/1.1 服务器使用的 HTTP 协议 200 ok 请求的处理结果的状态码(status code)和原因短语(reason-phrase) 响应报文基本上由协议版本、状态码(表示请求成功或失败的数字代码)、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[mocha + chai 单元测试 单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作 可以理解为对功能的基本验证 目前node中的测试框架，一般使用的是 mocha + 断言库 chai 安装 123npm install mocha -gnpm install mochanpm install chai mocha &amp;&amp; chaimocha APIdescribe describe 是一个 用例测试集， 他可以进行嵌套 123describe('进行首页的测试', function() &#123; // ....&#125;) it一个it对应一个单元测试用例 123it('测试接口xxx', function() &#123; // ....&#125;) only skiponly – 在当前的父describe块下，只执行该单元的测试 skip – 在当前的父describe块下，跳过该单元的测试 12345describe('Array', function() &#123; describe.only('父describe块下只执行该测试单元', () =&gt; &#123; it.skip('跳过的测试单元', () =&gt; &#123; &#125;); &#125;)&#125;) describe 和 it 都可以使用这两个方法 timeout - 设超时测试集合上定义超时时间，会对这个测试集合中所有的测试用例和测试集合起作用 1234567const sleep = time =&gt; new Promise(resolve =&gt; setTimeout(resolve, time)) it('timeout', async function () &#123; this.timeout(1000) await sleep(3000) expect(true).to.be.ok &#125;) hooks提供了几个函数，在特定的事件发生时被触发 before()、after()、beforeEach()、afterEach() 同一个describe下的执行顺序为before、beforeEach、afterEach、after before, after 执行一次 beforeEach，afterEach 每一个测试用例都会触发一次 123456before(() =&gt; console.info('首页测试开始'))after(() =&gt; console.info('首页测试结束'))beforeEach('check check check ', function() &#123; console.log('i am check')&#125;) chai APIchai有三种断言风格，expect，should，assert, 我的项目使用的是 expect expect列出几个常用的方法 方法 含义 equal 相等（严格比较） not 取反 include 包含 判断数据类型 123expect('username').to.be.a('string')expect(false).to.be.a('boolean')expect(obj).to.have.property('foo') 异步测试项目中的大部分函数为异步的，这个需要借助 done 来处理 1234it(`处理异步请求`, (done) =&gt; &#123; // ... done()&#125;) 异步函数在函数内部手动调用done()表示测试成功，done(err)表示测试出错 async await 可以不使用done 12345it('更新用户对于文章的态度', async () =&gt; &#123; const result = await updateAttitude(&#123; articleId: 123, userId: 131, status: 0&#125;) expect(result).to.be.a('number')&#125;) 最常见的接口测试 123456789it('获取某一个频道下的所有文章列表', async function () &#123; const result = await chai .request(app) .get('/articles/3/1') .then((res) =&gt; &#123; return res.body &#125;) expect(result).to.have.property('data')&#125;) 测试结果检查测试报告生成测试报告使用的是 mochawesome 模块 1"mocha:report": "mocha --reporter mochawesome" 会自动在项目创建 一个 mochawesome-report 目录, 测试覆盖率简单来说，就是判断你的测试用例对于函数的覆盖程度 1npm install -g istanbul 生成测试率覆盖报告 1istanbul cover _mocha -- -R spec 注： 这里是 _mocha 不要丢掉这下划线 会在项目中自动创建 coverage 文件夹 在浏览器中打开 1open coverage/lcov-report/index.html other 是否所有的函数都要编写测试用例 接口是肯定需要编写测试用例的，至于是否需要对函数做处理，个人感觉可以对重要的函数进行测试 参考文章 Chai.js–API]]></content>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用操作]]></title>
    <url>%2F2018%2F12%2F06%2Fgit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[git 撤销commit1 查看每一commit的版本号 git log 2 代码恢复 git reset –hard commit_id 完成撤销,同时将代码恢复到前一commit_id 对应的版本。 3 git reset commit_id – 取消commit 完成Commit命令的撤销，但是不对代码修改进行撤销，可以直接通过git commit 重新提交对本地代码的修改 撤销 merge1 查看版本号 git reflog 2 代码恢复 git reset –hard xxx fetch 分支git fetch origin 分支名称 强行pushgit push origin master -f git 提交commit格式feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）test：增加测试chore：构建过程或辅助工具的变动]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack升级v4]]></title>
    <url>%2F2018%2F11%2F02%2Fwebpack%E5%8D%87%E7%BA%A7v4%2F</url>
    <content type="text"><![CDATA[webpack4 最近项目在做重构，刚好把webpack升级到V4 基本配置 123456789const webpackConfig = &#123; watch, optimization, entry, output, module, plugins, resolve&#125; plugins CleanPlugin MiniCssExtractPlugin 代替 V3 中经常使用的 extract-text-webpack-plugin]]></content>
  </entry>
  <entry>
    <title><![CDATA[Node中包的查找机制]]></title>
    <url>%2F2018%2F10%2F26%2FNode%E4%B8%AD%E5%8C%85%E7%9A%84%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[模块查找 项目中引用的模块Node中的模块可以分为三类，根据模块类型不同，其使用方式也有差别 核心模块 自定义模块 文件模块 核心模块是Node本身就提供的模块，会在Node源码编译时就编译为二进制执行文件并在Node进程启动时加载进内存 自定义模块和文件模块从加载形式上可以分为一类，都是在运行时动态加载，区别在于文件查找的策略不同 Node对引入过的模块都会缓存，每一次引入模块时都会首先检查缓存，如果不存在，则进入模块查找流程 查看模块缓存 1console.log(require.cache) 对于每一个被加载的文件模块 都在创建的时候 会自动携带一个path属性 是根据当前文件路径计算的 可以输出一个module.paths 会得到问文件的查找路径 一般是在当前文件目录下查找node_modules 目录 然后进入父级目录的node_modules 最后会查找到根级目录node_modules 看一个模块的查找路径 1console.log(module.paths) 层级逐渐向上 scripts在package.json中一般会配置项目一些启动方式 1234scripts: &#123; "start": "nodemon index.js", "build": "webpack --config webpack.config.js"&#125; 那么这里所需的 nodemon 或者是 webpack 模块加载机制，并不是上面那种逐级向上查找的方式了 每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。 这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径 看下这里 .bin 文件里有什么命令可被执行 1vim node_modules/.bin 如果全局和本地都安装了webpack 那么使用的是哪一个呢 使用本地，如果本地没有，获取查找全局 命令行直接输入命令在项目中，如果直接在命令行输入执行命令，则其使用全局的模块还是本地的模块 全局会判断本地是否有此模块，有就使用本地，没有就使用全局 如果本地和全局都有安装 会使用本地模块 本地没有安装，只有全局有 使用全局模块 文章参考 《Node的模块与包管理机制》 《npm scripts 使用指南》]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1030一期文章分享]]></title>
    <url>%2F2018%2F10%2F25%2F1030%E4%B8%80%E6%9C%9F%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[文章阅读 1207 第七期cache1123 第五期JavaScript 复杂判断的更优雅写法文章分类: 奇淫技巧 文章点评: 条件判断是很常见的逻辑，当需要处理大量判断条件的时候，可以改变逻辑方式。虽然文章中的方案在代码直观理解方面不如基本写法，但是合理的代码注释可以弥补这个不足 危险的 target=”_blank” 与 “opener”文章分类: 奇淫技巧 文章点评: 处理一个a标签的点击可能带来的哪些风险 1116 第四期React Profiler 介绍文章分类: 工具 文章点评: 需要react 16.5 版本支持，可以看到每一个组件的渲染，从性能分布图可以找到哪一个组件耗费时间最长并做出调整 CSS Grid带来的新单位：分数单位fr文章分类: CSS 文章点评: Grid 中出现的计算单位 fr， 但仅限于 Grid 使用 1109 第三期如何写一个通用的README规范文章分类: 文档规范 文章点评: readme 可以看做是与项目沟通的重要文档，是不可缺少的一个文件。 一个没有readme的仓库让人痛苦。写好reademe，造福你我他。 大前端神器安利之 Puppeteer文章分类: 工具 文章点评: Puppeteer 是很棒的爬虫工具，API很强大，网上的参考资料也很多，十分钟 就可以写demo了 1102 第二期TypeScript 2.8下的终极React组件模式文章分类: 框架 文章点评: react几种组件的开发方式都有提到。里面附带的编译工具可以方便的体验TS，省去之前麻烦的环境搭建流程。文章有的地方翻译的有些生硬，理解就好不必强求 sequelize文章分类: API 文章点评: 非常全面的 sequelize 使用介绍，在使用sequelize-typescript之前可以按照这个系列文章敲一敲代码，如果全部理解可以很轻松的过渡到TS 《作为前端你拿什么证明网站体验》文章分类: 用户体验，性能优化 文章点评: 1 关于数据请求 文章中提到的数据请求方面的优化，采用的是预判用户行为加载数据 – 当鼠标滑动到tab组 未点击时 就进行数据请求 不过对于移动端页面，以电商首页为例，无法借鉴这种优化方式 由于分类列表数据变动次数不是非常频繁，采用的优化方式为 在用户点击了本次频道后，将数据保存到本地，当二次请求的时候，不在做数据请求 2 补充文章 《css加载会造成阻塞吗》 《阿里巴巴iconfont怎么是正确的使用方式？》 《前端异常监控》文章分类：前端监控 文章点评: 使用过的第三方的关于前端监控信息处理 1 最基本的页面异常上报 blued-et 监控页面error，需要去编写上报异常的router 2 听云 可以监控到各个页面解析渲染情况，比如页面耗时占比、访问量排序以及用户打开页面分析等 3 sentry (目前在用) 异常上报，可以设置邮件提醒，查看报错代码，设备型号等]]></content>
      <categories>
        <category>分享</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx使用指南]]></title>
    <url>%2F2018%2F10%2F22%2Fnginx%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sequelize入门篇]]></title>
    <url>%2F2018%2F10%2F21%2Fsequelize%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[ORM框架 — sequelize 用于将数据库的表关系映射到对象 mysql的一个表的数据结构如下 每一行其实是一个对象 12345&#123; id: 3, name: 'tom', password: 123&#125; 这个就是 ORM 框架做的事情 ORM使我们读写的都是JavaScript对象，Sequelize帮我们把对象变成数据库中的行 储备知识本地安装 mysql网上提供了两种方式，文件安装或者使用 homebrew，先使用文件安装，之后一直无法启动。后来删除之后使用brew重新安装 有的Mac可以直接使用 1brew install mysql 但是我的一直安装失败，查阅资料发现，是因为系统没有升级，所以不能这么处理 需要指定安装mysql的版本 12345brew search mysql // 查看有哪些版本可安装brew install mysql@5.7brew services start mysql@5.7 安装之后启动时mysql 1mysql.server start 关于其中会一直报错 命令找不到，需要调整 全局变量 修改了两个文件 1export PATH=&quot;/usr/local/opt/mysql@5.7/bin:$PATH&quot; 登录mysql 1mysql -u root -p 这个方式是需要输入 mysql 密码的，但是我并没有注意到安装mysql的时候 有提示密码是什么。。。 更换登录方式 1mysql -u root mysql 这个命令虽然可以登录，但是我们想使用sequel pro 本地连接，还是需要密码的，所以找了一个重置密码的方式 参考文章 123456789101112131415161718192021222324// 停止mysqlmysql.server stop// 进入安全模式sudo mysqld_safe --skip-grant-tables// 登录mysqlmysql -u root mysql// 切换数据库use mysql;// 修改 密码 -- 密码字段为 authentication_stringUPDATE mysql.user SET authentication_string=PASSWORD('mypassword') where User='root';// 刷新权限，使配置生效flush privileges;// 启动 MySQLmysql.server start 总结一下，就是修改 mysql 库的user表中 User 为 root 的 authentication_string 字段值 sequel pro 可视化工具链接mysqlmysql这种表结构一般使用 可视化工具方便查看信息 这里的host 不可以使用 localhost mysql普通的直接使用mysql链接 123456789101112131415161718192021222324252627282930const mysql = require('mysql')const mysqlConfig = &#123; host: ['127.0.0.1'], // 网址ip port: 3306, // 端口 user: 'root', // 用户 password: '5211314mxx', // 密码 database: 'activity', // 数据库 key: 'mysql',&#125;const pool = mysql.createPool(mysqlConfig)let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; resolve( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125; sequelize Sequelize是一个关系型数据库ORM框架，它基于Promise构建。支持MySQL、PostgreSQL、MariaDB、SQLite和MSSQL几种关系型数据库，功能非常强大。 安装包 1npm i sequelize mysql2 sequelize 类对象，通过new关键字进行实例化，以连接池的形式连接到所使用的数据库 创建一个实例 1const sequelizeObj = new Sequelize(数据库， 用户名， 密码， 配置参数config ) sequelize 实例API define 定义模型 getDialect 返回数据库类型 models 返回所有模型 1sequelizeObj.models() import 导入模型 1sequelize.import(path) -&gt; Model query 执行SQL语句的查询 1sequelize.query(sql, [options=&#123;&#125;]) -&gt; Promise sync 同步模型到数据库 1sequelize.sync() drop 删除表* 链接mysql表1234567891011121314151617const Sequelize = require("sequelize")const sequelizeObject = new Sequelize('activity', 'root', '5211314mxx', &#123; host: 'localhost', port: '3306', dialect: 'mysql', pool: &#123; //连接池设置 max: 5, //最大连接数 min: 0, //最小连接数 idle: 10000 &#125;, define: &#123; underscored: false, // 驼峰命名 timestamps: true, // 时间戳 freezeTableName: true // Model 对应的表名将与model名相同 &#125;&#125;) 参数含义 属性 含义 host 数据库地址,默认本机 dialect 数据库 ‘mysql’ ‘mariadb’ ‘sqlite’ ‘postgres’ ‘mssql’ pool 连接池设置 logging 是否将SQL语句输出到命令行 define 定义一些其余属性 define 参数 含义 freezeTableName 在查询的时候，sequelize可能会使用复数的表名 比如 use-&gt; users , 设定为TRUE 则不会使用这种复数的表名 其实还可以将配置参数简写为一个 12new Sequelize('mysql://root:5211314mxx@127.0.0.1/activity', &#123;&#125;)&lt;!-- 数据库类型 用户名 密码 IP databases --&gt; 当实例化对象后，就可以通过其返回的sequelize实例定义Model、执行query查询 模型定义表结构 define 就是常见一个表模型 define 用于定义模型和表的映射关系 使用方式 obj.define(‘你的表名’, {字段配置 segConfig }, {设置其余信息 tableConfig}) 1234567891011// 定义模型const User = sequelizeObject.define('eyes_users', &#123; id: &#123; type: Sequelize.INTEGER, primaryKey: true &#125;, name: Sequelize.STRING(100), // 用户名 password: Sequelize.INTEGER(100) // 密码&#125;, &#123; timestamps: false&#125;) segConfig 常用参数 属性 属性值以及含义 type 当前字段类型 defaultValue 默认值 allowNull 是否可以为null primaryKey 是否是主键 autoIncrement 是否是自增 comment 相当于注释 unique 是否是索引 tableConfig 常用参数 属性 属性值以及含义 timestamps 是否添加时间戳, 启用该配置后会自动添加createdAt、updatedAt两个字段，分别表示创建和更新时间 underscored 自动添加的字段会在数据段中使用“蛇型命名”规则，如：createdAt在数据库中的字段名会是created_at paranoid 是否使用虚拟删除。启用该配置后，数据不会真实删除，而是添加一个deletedAt属性 常用的数据类型 Datatypes 类型 含义 STRING 字符串 最长255 STRING(123) 字符串 最长123 TEXT 文本格式 DATE 时间 FLOAT 浮点数 TIME 日期时间 ARRAY 数组 BOOLEAN 布尔类型 ENUM 枚举 123456789101112const User = sequelize.define('eyes_user', &#123; id: &#123; &lt;!-- 主键 --&gt; type: Sequelize.NUMBER, primaryKey: true &#125; registerTime: &#123; &lt;!--时间 默认值为创建时间--&gt; type: Sequelize.DATE, defaultValue: Sequelize.NOW &#125;,&#125;) model 常用APIsync 同步模型到数据库define 定义好了模型对象，这些表是无法自动在数据库中创建的，需要调用一下 sync 才能在对应数据库中创建这些表 1234567app.listen(port, async() =&gt; &#123; // force:true 表示首先删除表再重新创建表 await User.sync(&#123; force: true &#125;).then(() =&gt; &#123; cosnole.log('created') &#125;) console.log('the port is', port)&#125;) 关于 sync方法 Model.sync()只会同步当前模型到数据库中 sequelize.sync()会同步sequelize实例中定义所有模型 create find update destory常用的mysql使用 - 增删改查 查 方法 含义 findOne 检索一个元素 findAll 检索所有 findById 根据id检索 123456const user = await User.findOne(&#123; where: &#123; name &#125;, attributes: ['password']&#125;) 对应的sql语句 1select password from table where name = name limit 1 有的时候我们需要将检索出来的字段做命名处理 1select uid, user_age as age from table where id = 3 就可以写为 1234567user.findOne(&#123; where: &#123;id: 3&#125;, attributes: &#123; uid, [user_age, age] &#125;&#125;) 增 单条记录增加 1234await User.create(&#123; name, password: encodePwd&#125;) 对应SQL语句 1insert into table (name, password) values (name, encodePwd) 批量增加 1234await User.bulkCreate([ &#123;name: 'tom', birthday: '123'&#125;, &#123;name: 'tom2', birthday: '1234'&#125;,]) 修改 直接更新 123456await Info.update(&#123; brithday: 20180101, sex: 'boy'&#125;, &#123; where: &#123; name &#125;&#125;) 对应sql语句 1udpate table set brithday = 20180101, sex = 'boy' where name = name 有则更新 没有则创建 upsert 123456await Info.upsert(&#123; birthday, userId&#125;, &#123; fields: ['birthday']&#125;) SQL语句为 1INSERT INTO `eyes_info` (`userId`,`birthday`) VALUES ('1','2088') ON DUPLICATE KEY UPDATE `birthday`=VALUES(`birthday`); 感觉这个和replace into 作用一样 1replace into tabale (`userId`,`birthday`) values (1, 100) 删1234567await User.destroy(&#123; where: &#123;id&#125;&#125;).then(() =&gt; &#123; body = &#123; code: 200, message: 'success' &#125;&#125;).then(() =&gt; &#123; body = &#123; code: 500, message: 'failture' &#125;&#125;) 条件语句where基本使用 1234567User.findAll(&#123; where: &#123; id: [1, 2, 4], city: 'beijing', home: null &#125;&#125;) where 字段中的对象， key: value 格式， 彼此之间属于 and 条件，也就是 key1 = v1 and key2 = v2 key: null 意味着 key is null key: [] 意味着 key in () value 还可以是一个对象格式 可以进一步对字段进行约束，比如 &gt; like betweent 等 123456789id: &#123; $eq: 1 // = 1 $ne: 1 // != 1 $or: [ [1, 2, 3], &#123; $gt: 10 &#125; ] // id in (1, 2, 3) or id &gt; 10&#125; 操作符 含义 $eq = $gt &gt; $gte &gt;= $lt &lt; $betweent between 6 and 10 $notBetween not between 6 and 10 $like like ‘xxx’ $or or 12345where name != nullwhere age &gt; 18where uid in (134, 145) 其余常用方法 limit offset 1234User.findAndCountAll(&#123; limit: 20, offset: 10&#125;) order 做排序 123User.findAll(&#123; order: 'updateAt' &#125;)User.findAll(&#123; order: 'count DESC' &#125;) group 做分组 1User.findAll(&#123; group: 'uid' &#125;) count 统计元素个数 123Info.count()Info.count(&#123; where: &#123; id: &#123;$gt: 10&#125; &#125; &#125;) max min 1Product.min('id', &#123; limit: 30, offset: 10 &#125;) 表关系处理建立三个表 表 含义 User 用户注册表 每注册一个用户 则存放一条数据 Info 用户信息表 一个用户UID 存放一条数据 Group 用户组 一个用户UID 可以加入多个 组 一个组可以有多个用户UID 12345678910111213141516171819202122232425262728293031323334353637383940414243// 用户注册表const User = sequelizeObject.define('eyes_users', &#123; id: &#123; type: Sequelize.INTEGER, primaryKey: true &#125;, name: Sequelize.STRING(100), // 用户名 password: Sequelize.INTEGER(100) // 密码&#125;)// 用户信息表const Info = sequelizeObject.define('eyes_info', &#123; userId: &#123; type: Sequelize.INTEGER, primaryKey: true &#125;, birthday: Sequelize.STRING(100), // 生日 age: Sequelize.INTEGER(100) // 年龄&#125;)// 用户组 一组可以有多个UID 同一个UID可以进不同groupconst Group = sequelizeObject.define('eyes_group', &#123; groupId: &#123; type: Sequelize.INTEGER, primaryKey: true &#125;, uid: &#123; type: Sequelize.INTEGER(100), primaryKey: true &#125;&#125;)// vip 一个用户UID只能有一个vip等级const Vip = sequelizeObject.define('eyes_vip', &#123; vip: &#123; type: Sequelize.INTEGER, primaryKey: true &#125;, uid: &#123; type: Sequelize.INTEGER(100), primaryKey: true &#125;&#125;) 关系 一对一关系 指一个实体的某个数据与另外一个实体的一个数据有关联关系 比如 User 与 Info 表 一对多 一对多与多对一是一个概念 指一个实体的某个数据与另外一个实体的多个数据有关联关系 比如 Vip 与 User 表 多对多关系 一个实体的数据对应另外一个实体的多个数据，另外实体的数据也同样对应当前实体的多个数据 比如 User 与 Group 表 表连接以 Info 表和Vip表为例 内连接1234SELECT * FROM join_table[INNER] JOIN join_table2[ON join_condition]WHERE where_definition 只列出这些连接表中与连接条件相匹配的数据行。INNER可以不写，则默认为内连接。[ON join_condition]里面写的是连接的条件。 比如 检索 vip 为 2 的 所有用户年龄 1234567891011select tableA.uid, tableA.birthday, tableA.age from eyes_info as tableA join eyes_vip as tabeleB join vip = 2 and uid = userId+-----------------+----------+------------+| uid | birthday | age |+-----------------+----------+------------+| 12 | 01-10 | 22 || 137 | 08-9 | 18 |+-----------------+----------+------------+ 外连接左外连接(LEFT [OUTER] JOIN) 右外连接(RIGHT [OUTER] JOIN) 不仅列出与连接条件（on）相匹配的行，还列出左表table1(左外连接)、或右表table2(右外连接)、或两个表(全外连接)中所有符合WHERE过滤条件的数据行。一般都是用左连接或者外连接 其中，[OUTER]部分可以不写，(LEFT | RIGHT | FULL)部分要写其中一个 1234567SELECT … FROM join_table1(LEFT | RIGHT | FULL) [OUTER] JOIN join_table2ON join_conditionWHERE where_definition 左外连接：左表列出全部，右表只列出匹配的记录 右外连接：右表列出全部，左表只列出匹配的记录]]></content>
  </entry>
  <entry>
    <title><![CDATA[rem基本原理]]></title>
    <url>%2F2018%2F10%2F20%2Frem%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[移动端适配方案 什么是移动端适配 制作一套页面，在不同设备中，页面图片、文字、间隙大小会变化，但是在比例上保持一致。 Rem简单来说，将原来的px转为rem 需要判断根元素字体大小 每一个设备的根元素字体大小不同 设备根元素字体 1document.documentElement.style.fontSize 如何判断使用多大根字体 假设设计稿为640px 当设备宽度也为640px 则可完全按照设计稿进行布局 但是单位要使用rem 将根元素字体大小设置为100px 比较好算 123body&#123;font-size: 100px;&#125;p&#123;margin-top:0.3rem;&#125;// 相当于 X rem30px/X rem = 100; 求出X 为 0.3 关于变化的根元素 在设计稿640px 有一个元素宽度 20px 根元素字体大小100px 写为自适应 使用rem 单位 0.2 rem 在设备 320px 有一个元素宽度 20px 根元素字体大小？？？PX 使用rem 单位 0.2 rem 所以变化的是设备的根元素 求设备根元素大小当设计稿宽度为desW 设备宽度为 docW 设备宽度的缩放倍数 = 根元素字体大小缩放倍数 设计稿宽度/设备宽度 = 100/ X 123var desW = 750;// 设计稿宽度var winW = document.documentElement.clientWidth; // 设备宽度document.documentElement.style.fontSize = winW/desW*100+"px"; // 求出当前设备根元素大小 注意，求出当前设备宽度使用的是document.documentElement.clientWidth 其实这个是文档宽度 而由于在开头有写 1&lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/&gt; width=device-width 表明了将文档宽度设置为设备宽度 flex布局flex布局是Flexible Box的缩写 是弹性布局的意思 用来为盒状模型提供很大灵活性 所有的容器都可以指定为Flex布局 只要将其指定为 1div &#123; display: flex; &#125; 行内元素也可以flex布局 display设置为 inline-flex 即可 设为flex布局之后 子元素的float clear vertical-align 属性失效 基本概念采用Flex布局的元素称为Flex容器 其子元素为容器成员 称为项目 容器默认存在主轴【水平方向】和交叉轴【垂直方向】 主轴开始位置 mian start 结束位置 main end 容器默认沿着主轴排列 单个项目占据的主轴空间是main size 容器属性flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content 1 flea-direction 决定主轴方向 【项目的排列方向 默认是水平 起点左侧】 row 【默认值】 主轴为水平方向 左侧为起点位置reo-reverse 主轴为 水平 右侧是起点column 主轴是垂直 上为起点column-reverse 主轴是垂直 下为起点 2 flex-wrap 默认情况 项目排列为一条线 又称轴线 flex-warp 属性定义了如果在轴线排列不下的情况 如何换行 nowrap 【默认】 不换行wrap 正常换行 第一行在上wrap-reverse 换行 第一行在下方 3 flex-flow 这个属性其实是flex-direction和flex-wrap的简写形式 默认是 row nowrap 4 justify-content 属性定义了项目在主轴上的对齐方式 flex-start 【默认值】 左对齐flex-end 右对齐center 居中space-between 两端对齐 项目之间间隔相同space-around 每个项目两侧间隔相同 所以 项目之间的间隔比项目与边框之间的间隔大一倍 5 align-items 定义项目在交叉轴上 如何对齐 假设交叉轴为默认值 上到下 flex-strat 与交叉轴的起点对齐flex-end 与交叉轴终点对齐center 与交叉轴中点对齐baseline 项目的第一行文字的基线对齐stretch 【默认值】 如果项目没设置高度 或者设为auto 将沾满全部容器空间 6 align-content 定义多跟轴线的对齐方式 这里如果项目只有一根轴线 则设置无效 flex-startflex-endcenterspace-betweenspace-around 7 属于项目的属性 orderflex-growflex-shrinkflex-basisflexalign-self 7.1 order 定义项目排列顺序 数值笑的排位靠前 默认0 7.2 flex-grow 定义项目的放大比例 默认0 7.3 flex-shrink 定义项目缩小比例 默认为1 如果空间不足 项目按照比例缩小 7.4 flex-basis 在分配多余空间前 项目占据的主轴空间大小 默认为auto 7.5 flex 这个属性是flex-grow flex-shrink flex-basis的简写 默认是 0 1 auto 7.6 align-self 允许单个项目与其余的不同 可以覆盖align-items属性 默认为auto 继承父级元素的align-items属性 如果此元素并没有父元素 则等用于stretch]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript-react]]></title>
    <url>%2F2018%2F09%2F28%2Ftypescript-react%2F</url>
    <content type="text"><![CDATA[项目ts版做半重构 储备知识基本类型接口 TypeScript的核心原则之一是对值所具有的结构进行类型检查 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 定义属性 1234interface props &#123; readonly name: string habit? : string&#125; 定义一个函数所需的形状 1234567interface fnBox &#123; (len:number, cont: number): number[] &#125;let pushAry:fnBoxpushAry = function (len: number, cont: number) &#123; return new Array(len).fill(cont) &#125; 如果这里故意写错cont的类型，会有什么提示 可以定义无返回值的函数 1234interface props &#123; once(): void twice: () =&gt; void &#125; 类 &amp;&amp; 接口 implements 可以使类 具有接口的属性功能 1234567891011121314151617interface int2 &#123; once(): void, touchMore: (count: number) =&gt; void&#125;class Btn implements int2 &#123; once () &#123; console.log('once') &#125; touchMore (count: number) &#123; console.log('touchMore') &#125;&#125;const btns = new Btnbtns.once()btns.touchMore(9) 配置 tsconfig.json1 使用webpack搭建项目的时候，有配置alias参数 1'utils': path.resolve(__dirname, '../utils') 这样在组件中引入的时候，文件路径可以简化 1import &#123; log &#125; from 'utils/statistics' 不过在使用ts之后，会发现组件中有警告信息，表示找不到此模块 就需要另外在tsconfig中添加配置参数 12345"baseUrl": "./","paths": &#123; "components": ["./components/*"], "utils": ["./utils/*"],&#125; 2 noEmitOnError: true 当编译出错，则不输出编译后的文件 全局变量 window在访问页面的时候，server会反馈一些基本的用户信息，比如用户名，设备版本号等，将这些全部挂载在CONFIG变量中了 1234&lt;script type=&quot;text/javascript&quot;&gt; window.CONFIG = JSON.parse(decodeURIComponent(&apos;&#123;&#123;feConfig&#125;&#125;&apos;))&lt;/script&gt;const &#123;uid, version&#125; = window.CONFIG // 然后在组件中可以直接获取 但是在加入TS之后，会提示window中不存在属性CONFIG 这是因为 ts 不允许从未 处理方案 1 1234declare global &#123; interface Window &#123; CONFIG: any &#125;&#125;const &#123;uid&#125; = window.CONFIG 2 使用类型断言 1const &#123; apk &#125; = (window as any).CONFIG 泛型12345import * as React from 'react'class App extends React.Component&lt;props, state&gt;&#123; -- do something --&#125; 定义 泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性 比如写一个根据指定内容填充到指定长度的数组生成函数 getAry 123function getAry (len: number, cont: string | number): string[] | number[] &#123; return new Array(len).fill(cont)&#125; 参数 参数 含义 类型 len 指定长度 number cont 指定内容 string 或 number （使用联合类型处理） 由于不确定参数cont的输入类型，所以返回值使用了联合类型处理 这种需要 返回值类型和输入参数类型保持一致的情况，可以使用泛型T来处理 泛型是类型变量，一种用来表示类型的特殊变量 使用方式 在函数名后添加&lt;&gt; 12function createFn&lt;T&gt;function createFn&lt;string&gt; // 明确指定 T 是 string 类型的 其实泛型函数的类型与非泛型函数的类型没什么不同，只是多了一个类型参数在最前面 可以指定默认类型 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用 1function beConfusion&lt;T = boolean&gt; (name: string, isDone: boolean) &#123;...&#125; 泛型接口将上面那个函数使用接口来定义 1234567interface dealFn &#123; &lt;T&gt;(len: number, cont: T): T[] &#125;let getAry: dealFngetAry = function &lt;T&gt; (len: number, cont: T): T[] &#123; --do something-- &#125; 泛型类泛型类使用&lt;&gt;括起泛型类型，跟在类名后面 123456789class DealAry&lt;T&gt; &#123; value: T constructor (value: T) &#123; this.value = value &#125; deal () &#123; console.log(this.value) &#125;&#125; other 其余的一些泛型变量 虽然可以自己定义泛型变量结构，但是一般会使用已定义好的泛型 Promise 123456789async taobaoGoods = function (ids: number[]): Promise&lt;string&gt; &#123; return new Promise &lt;string&gt;((reslove, reject) =&gt; &#123; try&#123; reslove('success') &#125; catch &#123; reject('failture') &#125; &#125;) &#125; 可以有多个泛型变量 1class React.component 类的泛型变量打开 node_modules/@types/react 可以看到 component 类 简单概括就是 123456class Component&lt;P = &#123;&#125; , S = &#123;&#125; &gt; &#123; -- other -- readonly props: Readonly&lt;&#123; children?: ReactNode &#125;&gt; &amp; Readonly&lt;P&gt; state: Readonly&lt;S&gt; -- other --&#125; 可以看到 props 和 state 两个对象都是只读的 所以我们在写React组件的时候，要调整为 123456789101112interface BannerProps &#123; showUpdate(): void, clickOnce: (type: string, id: number) =&gt; void&#125;interface BannerState &#123; once: boolean&#125;export default class Banner extends React.Component&lt;BannerProps, BannerState&gt; &#123; --do something--&#125; 类型断言获取一个元素的某个属性 12345componentDidMount () &#123; new Swiper(findDomNode(this), Object.assign(&#123;&#125;, options, &#123; onInit: () =&gt; &#123;...&#125; &#125;)) &#125; ts提示有错误 类型断言（Type Assertion）可以用来手动指定一个值的类型 1&lt;类型&gt;值 或者 值 as 类型 在jsx中必须使用 第二种方式去处理 在不确定类型的时候就访问其中一个类型的属性或方法，可以使用类型断言 1234function getType (arg: string | boolean): boolean &#123; if ( arg.length ) return true return false&#125; 这种其实会报错的，如果输入是布尔值，则没有length 借助类型断言调整一下 12345function getType (arg: string | boolean): boolean &#123; if ( (arg as string).length ) return true // if ( (&lt;string&gt;arg).length ) return true return false&#125; 断言成一个联合类型中不存在的类型是不允许的 1if ( (arg as array).length ) return true // 报错 所以上面组件里 需要调整为 12345componentDidMount () &#123; new Swiper(findDomNode(this), (Object as any).assign(&#123;&#125;, options, &#123; onInit: () =&gt; &#123;...&#125; &#125;)) &#125; 掉坑记录获取DOM的style属性1234componentDidMount () &#123; const target = document.body.children const cont = target[0].style.height&#125; 需要调整为 1234componentDidMount () &#123; const target = document.body.children const cont = target[0]['style'].height&#125; ::写法1&lt;Banner once=&#123;::this.update&#125; /&gt; 这个主要是借助了爸bable 的 transform-function-bind ts不支持这种写法 必须要调整为 1&lt;Banner once=&#123;() =&gt; this.update&#125; /&gt;]]></content>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类以及继承]]></title>
    <url>%2F2018%2F09%2F26%2F%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[es6的继承 类es5中的类定义123456789101112function Move (left, end) &#123; this.left = left this.end = end&#125;Move.prototype.walk = function () &#123; do &#123; this.left++ console.log(this.left) &#125; while (this.left &lt; this.end)&#125;var move = new Move(2, 5)move.walk() 属性用来初始化新创建的对象的函数是构造函数 如 Move 通过构造函数的new操作创建的对象是实例对象 如 move 构造函数有一个prototype属性，指向实例对象的原型对象。同一个构造函数实例化的多个对象是具有相同的原型对象 123var move1 = new Move(1, 2)var move2 = new Move(2, 3)move1.__proto__ === move2.__proto__ // true 原型对象有一个constructor属性，指向该原型对象对应的构造函数 1Move.prototype.contructor === Move // true 由于实例对象可以继承原型对象的属性，所以实例对象也拥有constructor属性，同样指向原型对象对应的构造函数 12console.log(move1.constructor === Move, 'constructor') // trueconsole.log(move1.hasOwnProperty('constructor'), 'hasOwnPrototype') // false -- constructor 属性是继承自原型对象Move.prototype es6 的类定义123456789101112131415class Run &#123; constructor (left, end) &#123; this.left = left this.end = end &#125; running () &#123; do &#123; this.left += 10 console.log(this.left) &#125; while (this.left &lt; this.end) &#125;&#125;const run = new Run(0, 40)run.running() 定义一个 Run 类 具有 running 方法 类的所有方法都定义在类的prototype属性上面 相当于 1234Run.prototype = &#123; constructor () &#123;&#125; running () &#123;&#125;&#125; 而类的实例调用方法，就是在调用原型上的方法 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面 123456789101112131415161718class Run &#123; constructor (left, end) &#123; this.left = left this.end = end &#125;&#125;Object.assign(Run.prototype, &#123; running()&#123; do &#123; this.left += 10 console.log(this.left) &#125; while (this.left &lt; this.end) &#125;&#125;)const run = new Run(0, 10)run.running() constructorconstructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法 一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加 constructor方法默认返回实例对象（即this），也指定返回另外一个对象 Q: 当constructor 返回值被修改 ， 会有什么后果 实例对象实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上 123console.log(run.hasOwnProperty('left'), 'left') // trueconsole.log(run.hasOwnProperty('running'), 'running') // falseconsole.log(run.__proto__.hasOwnProperty('running'), 'running') // true 因为 left 和 end 属性都定义在实例自身 (this) 上, 所以 hasOwnProperty 可以找到此属性 静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法” 1234567class Run &#123; static stop () &#123; console.log('woow, stop it!!', this.name) &#125;&#125;Run.stop() // 'woow, stop it!!', Run 注意，如果静态方法包含this关键字，这个this指的是类，而不是实例 静态方法可以与非静态方法重名 12345678910111213class Run &#123; stop () &#123; this.left = 0 console.log(this.left, 'stop now, please') &#125; static stop () &#123; console.log('woow, stop it!!', this.name) &#125;&#125;const run = new Run(0, 10)run.running()run.stop() 静态属性 静态属性指的是 Class 本身的属性，而不是定义在实例对象（this）上的属性 12class Run &#123;&#125;Run.props1 = 'i am props1' 处于提案中的类的静态属性的写法 123class Run &#123; static props1 = 'i am props1'&#125; 实例的属性 处于提案中的实例属性的写法 123456class Run &#123; whoProps = 'i am whoProps' constructor () &#123; console.log(this.whoProps) // 'i am whoProps' &#125;&#125; 类的继承es5 的 继承继承 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)） es6 继承通过extends关键字实现继承 12345678class Walk extends Run &#123; constructor (left, end) &#123; super(left, end) &#125;&#125;const walk = new Walk(1, 20)walk.running() 子类必须在constructor方法中调用super方法，否则新建实例时会报错 ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法 123456789101112class Walk extends Run &#123; // constructor (left, end) &#123; // // super(left, end) // &#125;&#125;// 相当于class Walk extends Run &#123; constructor(...args) &#123; super(...args) &#125;&#125; 也就是你可以不写 constructor 但是如果写了 constructor 就必须写 super 实例对象同时是 子类 和 父类 的实例 1console.log(walk instanceof Walk, walk instanceof Run) 子类可以继承父类的静态方法 1234567891011class Run &#123; static stop () &#123; console.log('woow, stop it!!', this.name) &#125;&#125;Run.stop() // 'woow, stop it!!', Runclass Walk extends Run &#123;&#125;Walk.stop() // 'woow, stop it!!', Walk Object.getPrototypeOf 获取父类12const isP = Object.getPrototypeOf(Walk) === Runconsole.log(isP, 'isP') // true 可以使用这个方法判断，一个类是否继承了另一个类 super作为函数作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错 123456class Run &#123;&#125;class Walk extends Run &#123; back () &#123; super() // 报错 &#125;&#125; 作为对象 super作为对象时，在普通方法中，指向父类的原型对象 1234567891011121314151617class Run &#123; constructor (left, end) &#123; this.left = left this.end = end return this.left + 'left left' &#125; write () &#123; return this.left + ' write, write' &#125;&#125;class Walk extends Run &#123; constructor (left, end) &#123; super(left, end) console.log(super.write()) &#125;&#125;const walk = new Walk(1, 20) 在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例 在静态方法中，指向父类 123456789101112131415161718192021222324class Run &#123; constructor (left, end) &#123; this.left = left this.end = end return this.left + 'left left' &#125; stop () &#123; this.left = 0 console.log(this.left, 'stop now, please') &#125; static stop () &#123; console.log('woow, stop it!!', this.name) &#125;&#125;class Walk extends Run &#123; constructor (left, end) &#123; super(left, end) console.log(super.write()) &#125; static lay () &#123; super.stop() &#125;&#125;Walk.lay() // woow, stop it!! Walk 在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错 1console.log(super) // 这样是会报错的]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一练第七期]]></title>
    <url>%2F2018%2F09%2F17%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC7%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[copy Q: 什么是深拷贝和浅拷贝？如何实现深拷贝?个人理解拷贝相当于在堆内存中开辟一片新的空间，把源数组或者对象的每个属性都复制过来。而不是只是复制一个存放地址 Q: 原型是什么？原型链是什么？用你的语言把下面这张图讲解清楚]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一练第六期]]></title>
    <url>%2F2018%2F09%2F10%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC6%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[new + bind Q: js 中的new () 到底做了什么个人理解声明对象，将 类的prototype 赋值给 新对象 proto 属性 call改变类的this为新对象 返回该对象 ANSWERnew 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。当代码 new Foo(…) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建 使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 1234567let cat = new Animal("cat");new Animal("cat") = &#123; let obj = &#123;&#125;; obj.__proto__ = Animal.prototype; let result = Animal.call(obj,"cat"); return typeof result === 'object'? result : obj;&#125; (1）创建一个空对象obj （2）把obj的proto 指向Animal的原型对象prototype，此时便建立了obj对象的原型链： obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null （3）在obj对象的执行环境调用Animal函数并传递参数“cat”。 相当于 1let result = obj.Animal("cat") 当这句执行完之后，obj便产生了属性name并赋值为”cat” （4）考察第3步返回的返回值，如果无返回值或者返回一个非对象值，则将obj返回作为新对象；否则会将返回值作为新对象返回 Q 下面是一个bind方法的Polyfill,请逐句给别人讲解一下每一行代码的含义1234567891011121314151617181920Function.prototype.bind = function(oThis) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); &#125; let aArgs = Array.prototype.slice.call(arguments, 1), let fToBind = this let fNOP = function() &#123;&#125; let fBound = function() &#123; return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)) ); &#125;; if (this.prototype) &#123; fNOP.prototype = this.prototype; &#125; fBound.prototype = new fNOP(); return fBound;&#125;; Q : 移动端适配的解决方案,以及其优缺点个人理解 媒体查询 需要增加很多的不同分辨率的样式代码 rem 在变更屏幕大小之后，还需要重新刷新页面才生效 百分比 Q: 请说下this是使用1 this跟函数在哪里定义没有关系，函数在哪里调用才决定了this到底引用的是什么 2 this机制的四种规则 2.1 默认绑定全局变量,这条规则是最常见的，也是默认的。当函数被单独定义和调用的时候，应用的规则就是绑定全局变量。 2.2 隐式绑定 隐式调用的意思是，函数调用时拥有一个上下文对象，就好像这个函数是属于该对象的一样 2.3 显示绑定 学过bind()\apply()\call()函数的都应该知道，它接收的第一个参数即是上下文对象并将其赋给this。 2.4 new新对象绑定 如果是一个构造函数，那么用new来调用，那么绑定的将是新创建的对象 Q 请谈谈v8的垃圾回收机制在老生代中，以下情况会先启动标记清除算法： 1 某一个空间没有分块的时候2 空间中被对象超过一定限制3 空间不能保证新生代中的对象移动到老生代中 在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。 为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。 但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。 老生代算法老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。 在讲算法前，先来说下什么情况下对象会出现在老生代空间中： 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。 To空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。 V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[object-fit]]></title>
    <url>%2F2018%2F09%2F07%2Fobject-fit%2F</url>
    <content type="text"><![CDATA[object-fit 使用 这周在处理视频播放的问题，全屏播放，在css中将video宽高强制设置为100%，发现在某些手机中会有两侧黑边 并没有全屏，解决方案，使用一个CSS属性 1object-fit: cover; 但是为什么这个可以实现呢，今天来探究一下 替换元素 其内容不受CSS视觉格式化模型控制的元素,比如image,嵌入的文档(iframe之类),叫做替换元素 视觉格式化模型 可以理解为在视觉媒体上如何处理文档树。参考BFC,IFC CSS渲染模型不考虑替换元素内容的渲染。这些替换元素的展现独立于CSS。 object,video,textarea,input也是替换元素,audio和canvas在某些特定情形下为替换元素。 使用CSS的content属性插入的对象是匿名替换元素。 替换元素 替换元素通常有其固有的尺寸:一个固有的宽度,一个固有的高度和一个固有的比率 比如图片和视频有宽度和高度,是有自身宽高比率的 object-fit 参数 取值 fill 被替换的内容大小可以填充元素的内容框。 整个对象将完全填充此框。 如果对象的高宽比不匹配其框的宽高比，那么该对象将被拉伸以适应 contain 被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加黑边 cover 被替换的内容大小保持其宽高比，同时填充元素的整个内容框。 如果对象的宽高比与盒子的宽高比不匹配，该对象将被剪裁以适应 none 被替换的内容大小保持其宽高比，而且被替换的内容尺寸不会被改变 scale-down 内容的尺寸就像是指定了none或contain，取决于哪一个将导致更小的对象尺寸 各个浏览器支持情况 object-fit 的默认值为fill，完全填充 fill123456789img &#123; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120); object-fit: fill; width: 300px; height: 300px; margin: 100px; &#125; &lt;img src="https://www.bldimg.com/eshop/photos/1535623413_43938.jpg?imageView2/0/w/250" alt=""&gt; 从左到右展示， img空元素 原始图片 img按照fill填充了原始图片之后 可以看到，图片被强制填充整个Img盒子，完全变形了 contain123456789img &#123; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120); object-fit: contain; width: 300px; height: 300px; margin: 100px; &#125; &lt;img src="https://www.bldimg.com/eshop/photos/1535623413_43938.jpg?imageView2/0/w/250" alt=""&gt; 从左到右展示， img空元素 原始图片 img按照contain填充了原始图片之后 图片保持了原始宽高比 我们找一个宽高比小于1的图片看看 123456789img &#123; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120); object-fit: contain; width: 300px; height: 300px; margin: 100px; &#125; &lt;img src="https://web.bldimg.com/cblued/static/img.1cmoujbgofhbhi.png?imageView2/0/w/250" alt=""&gt; contain属性 会选择边比较长的那一个为准，另外的一个边会保持居中 宽高 结果 宽度 &gt; 高度 水平方向100% 垂直方向居中 宽度 &lt; 高度 垂直方向100% 水平方向居中 所以这个属性也可以用来处理图片居中问题了 比如这个，商品的图片居中 之前的css 12345img &#123; width: 6.06rem; display: block; margin: 0 auto;&#125; 限制宽度，高度自适应。 但是这样有一个问题，就是在做懒加载的过程中，由于没有固定盒子高度，导致在滑动页面的时候会有一种“跳”的感觉，用户体验不好。 但是如果固定高度，限制最大width，在遇到宽度比高度要大很多的长方形商品图，会变形 123456img &#123; height: 6.06rem; max-width: 100%; display: block; margin: 0 auto;&#125; 可以调整为 12345img &#123; width: 100%; height: 6.06rem; object-fit: contain; &#125; cover12345678img &#123; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120); object-fit: cover; width: 300px; height: 300px; margin: 100px; &#125; 从左到右展示， img空元素 原始图片 img按照cover填充了原始图片之后 图片的宽高比没变，但是多余的部分被裁剪掉了 none123456789img &#123; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120); object-fit: none; width: 300px; height: 300px; margin: 100px; &#125; &lt;img src="https://www.bldimg.com/eshop/photos/1535623413_43938.jpg?imageView2/0/w/250" alt=""&gt; 从左到右展示， img空元素 原始图片 img按照none填充了原始图片之后 被替换的内容大小保持其宽高比 并且尺寸不变 由于这里的图片源宽度(250px)是小于img的设置宽度(300px), 图片完整的展示到img盒子中 找一个图片源大于盒子本身大小的 从左到右展示， img空元素 原始图片 img按照none填充了原始图片之后 原始图片大小 576 x 636 none 好像是选取了原始图中一块 300 x 300的区域大小的资源块 填充到Img盒子 图片源和Img盒子大小对比 结果 图片源 &gt; Img盒子 选取图片源一块进行填充 图片源 &lt; Img盒子 完整展示 scale-down12345678img &#123; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120); object-fit: scale-down; width: 300px; height: 300px; margin: 100px; &#125; scale-down的表现形式取决于 图片源 与 Img盒子 的大小 如果 图片源 大于 Img盒子，其呈现结果和 contain 一样，保持图片源宽高比进行填充 如果 图片源 小于 Img盒子, 其呈现结果和 none 一样，直接展现图片 object-fit 的作用在使用了object-fit的img元素，就像一个盒子，根据object-fit的属性值，填充真正的图片源 也就是设置了 1234567img &#123; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120); width: 300px; height: 300px; margin: 100px; &#125; 这些大小的限制是对于 img盒子 1object-fit: xxx; 这个属性是用于处理真正展示的图片源，也就是控制最后呈现的图片源的样式 Object-positionObject-position 可以按照 background-position 理解，用来决定替换资源的展示位置 w3c 对于 background-position 的解释 可以简单理解为，你在Img盒子的哪个位置开始放置背景图 （相对于左上角） 12345678img&#123; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120); object-position: 150px 150px; width: 300px; height: 300px; margin: 100px 20px;&#125; object-position设置为img盒子的一半, 三个图片的展示样式 应用于video在处理video元素播放的时候，我们经常能看到视频会自动补充黑边 123456 &lt;div&gt; &lt;video controls src="。。。"&gt;&lt;/video&gt;&lt;/div&gt;&lt;div&gt; &lt;video controls src="。。。"&gt;&lt;/video&gt;&lt;/div&gt; 123456789101112div &#123; width: 350px; height: 500px; float: left; margin: 100px 20px; border: 10px solid rgb(207, 154, 94); background: rgb(143, 131, 120);&#125; video &#123; width: 100%; height: 100%;&#125; 虽然这里已经写了video元素设置为父级盒子大小，但是里面的视频源在播放的时候，并没有按照想要的占据全屏 加入object-fit属性处理一下 123video &#123; object-fit: fill;&#125; 参考文章 补充一些 video 的知识 video 和 audio在移动端的表现 阻止视频在移动端页面中全屏播放 半深入理解CSS3 object-position/object-fit属性]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件Video]]></title>
    <url>%2F2018%2F09%2F06%2Freact%E7%BB%84%E4%BB%B6Video%2F</url>
    <content type="text"><![CDATA[写一个很简单的video组件 之前的一篇文章讨论了 video元素 的使用 video 和 audio在移动端的表现 可以看到在iOS和Android两种系统对于video控件的支持很不一样，在展示控制组件的时候，两者差别很大 左侧为iOS, 其控件要比Android多 ISO有提供一个全屏播放的按钮，就是左上角的那个，当点击会进入下图右侧状态。当在点击关闭，会恢复到左侧状态 然后产品同学表示，希望可以实现设备同步 之后向其解释了video的展示样式是基于设备浏览器的，无法进行控制，比如关闭iOS的全屏按钮，于是就这么处理了 后面提测之后看这里的代码，因为需求不复杂，决定写个小组件，实现 播放，暂停，进度展示 这三个功能 组件结构1 video 2 底部控制条 1234&lt;div&gt; &lt;video/&gt; &lt;controller/&gt;&lt;/div&gt; video元素 不添加 controls 不展示本身的控件 事件控制onloadedmetadata在获取视频总时长的时候，一直拿到的空值 12345componentDidMount () &#123; const target = this.video const time = target.duration || 0 ...&#125; 怀疑是不是因为这个 target 对象 获取的是空, 然后在添加了console，在控制台是可以看到的，查阅资料有人说这个因为视频资源数据没有被加载 事件 触发机制 loadeddata 当当前帧的数据已加载，但没有足够的数据来播放指定音频/视频的下一帧时，会发生 loadeddata 事件 loadedmetadata 当指定的音频/视频的元数据已加载时，会发生 loadedmetadata 事件 音频/视频的元数据包括：时长、尺寸（仅视频）以及文本轨道 所以调整为 12345678componentDidMount () &#123; const target = this.video // 获取视频总时长 target.onloadedmetadata = () =&gt; &#123; this.setState(&#123; time: target.duration &#125;) &#125;&#125; ontimeupdate 事件 触发机制 timeupdate 在音频/视频（audio/video）的播放位置发生改变时触发 1234target.ontimeupdate = () =&gt; &#123; const &#123; currentTime, duration &#125; = target this.setState(&#123; move: currentTime, width: currentTime / duration &#125;)&#125; 这个事件用于处理展示视频进度 控制栏调整之后，iOS Android 在微信中的表现 只有进度条，播放按钮 但是进入浏览器环境，发现还是有那个控制组件, 虽然并没有使用controls属性，也会显示控件 后面查询文章，说在浏览器中无法处理这个问题 有的人想的办法是，将视频设置的大一点，把自带的控件放在屏幕之外，这样用户就看不到了 postervideo组件有设置 点击之后立即播放 12345// 播放视频export const videoPlay = () =&gt; &#123; const video = document.querySelector('video') video &amp;&amp; video.play()&#125; 但是这个执行的时候，能看到黑屏展示 给video元素添加一个poster属性, 这样会使用封面图填充缓冲时间 poster 属性指定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像 other项目Git地址 html5–移动端视频video的android兼容，去除播放控件、全屏等]]></content>
      <categories>
        <category>轮子</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment.js使用]]></title>
    <url>%2F2018%2F09%2F04%2Fmoment-js%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[moment.js 使用笔记 获取当前时间1234let now = moment()let date = now.date() // 或者 now.dates() 这个是当月哪一日let hour = now.hour() // 或者 now.hours()let minute = now.minute() // 或者 now.minutes() 时间日期进行格式化1let day = moment().format('YYMMDD') 输出什么样的格式可以之间在这里定义 1234YYMMDD 170315YY-MM-DD 17-03-15YYMMDD 20170315YYMMDD HH-mm-ss 170315 20:23:21 注意大小写是有区别的HH 这种形式的获取的是24小时的时间 hh是12小时制的 1YYMMDD hh-mm-ss 170315 04:23:21 获取相对时间有的时候项目考虑到时区问题或者数据展示 比如在每一天的00：00-05：00进行数据展示 展示的是昨天的数据 此时就需要一个时间参数来表示昨天 12let today = moment()let yesterday = moment().subtract(1,'day') 获取第二天 1let tomorrow = moment().add(1,'days') 时间戳转化时间转为时间戳 1moment('2018-09-01 22:00').unix() 获取当前时间的时间戳 123moment().format('X') moment().format('x') moment().valueOf() 时间戳转为时间 1moment.unix(时间戳).format('YYYYMMDD') 是否处于某个时间段内只有当用户注册时间在2017-3-10之间注册的才能参加 1let time = moment(user.loginTime).isBefore('2017-3-10 00:00:00') 是否相同 1moment().isSame('2010-10-20'); // true 是否之后 1moment().isAfter('2010-10-19 12:30:00'); // true 注意有坑 当前是第几周 1const week = moment().isoWeeks() 注意 文档里还有一个 获取周的API是 moment().week() 这两个API是有区别的，下面的 week 那个的一周 是从 周末到周六 算一周，和平时理解的一周不同 QUESTION 今日 12const yesterday = moment().subtract(1, &apos;days&apos;).format(&apos;YYYYMMDD&apos;)const day = moment().format(&apos;YYYYMMDD&apos;) 本周 1234567// 年份const year = moment().format(&apos;YYYY&apos;)// 当前周是第几周const week = moment().isoWeeks()const start = moment().isoWeekday(1).format(&apos;YYYYMMDD&apos;)const end = moment().isoWeekday(7).format(&apos;YYYYMMDD&apos;) 本月 1234const month = moment().format(&apos;YYYYMM&apos;)const start = moment().startOf(&apos;month&apos;).format(&apos;YYYYMMDD&apos;)const end = moment().endOf(&apos;month&apos;).format(&apos;YYYYMMDD&apos;)]]></content>
      <categories>
        <category>第三方插件使用</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一练第五期]]></title>
    <url>%2F2018%2F09%2F03%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[cookie + url + 优化 Q: 请说说cookie，localStorage，sessionStorage，indexDB 之间的区别的使用场景?个人理解cookie: 两种使用方式， 一种方法是把值保存在浏览器的变量中 , 当浏览器关闭时结束 , 另一种方法是保存在硬盘中 , 只要时间不过期 , 下次还可使用 localStorage: 关闭浏览器还会存在，除非清除 sessionStorage: 窗口级别的，关闭浏览器则清除 AnswerQ: 写一个函数find_missing(A, low, high)，给定一个范围[low,high]，寻找一个数组中缺失的元素。12345find_missing([10, 12, 11, 15], 10, 15) // [13,14]// 注: low=10 high = 15find_missing([1, 14, 11, 51, 15],50, 55) // [50, 52, 53, 54]// 注：low = 50, hight = 55 个人理解12345678910let find_missing = (ary, low, high) =&gt; &#123; let noAry = [] do &#123; if (!ary.includes(low)) &#123; noAry.push(low) &#125; low++ &#125; while (low &lt; high) return noAry&#125; Q：请说出从输入网址点击回城以后 浏览器发生了什么个人理解1 查询本地域名服务器 2 查找IP地址 3 根据IP地址访问服务器 4 获取资源 返回给浏览器 Answer 用户输入URL地址 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存） 浏览器将端口号从URL中解析出来 浏览器建立一条与目标Web服务器的TCP连接（三次握手） 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器返回一条HTTP响应报文 关闭连接 浏览器解析文档 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕 渲染的基本流程 HTML解析出DOM Tree CSS解析出Style Rules 将二者关联生成Render Tree Layout 根据Render Tree计算每个节点的信息 Painting 根据计算好的信息绘制整个页面 补充: 我们都知道，js脚本会造成页面解析和渲染的阻塞，那么CSS呢 css加载会造成阻塞吗 Q：谈谈你对前端资源下载性能优化的经验和思考?个人理解减少没必要的图片，JS，CSS以及HTML等，对文件进行压缩优化，开启GZIP压缩传输内容]]></content>
  </entry>
  <entry>
    <title><![CDATA[每日一练第四期]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC4%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[webpack + generator Q: 如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？个人理解确定是不是用户设备: 使用多个设备调试 确定浏览器: 清除浏览器缓存 换个浏览器尝试 Q: service workers 是什么个人理解AnswerQ: webpack 对于项目的优化个人理解1 可以处理按需加载 2 可以对图片，代码进行压缩 3 通过设置第三方库为全局引用，可以减少项目打包后的资源大小 4 抽取公共库 Answer 缩小文件搜索范围,配置比如resolve.modules,resolve.modules,resolve.mainFields,resolve.alias ,resolve.extensions ,module.noParse 配置 使用DllPlugin 要给 Web 项目构建接入动态链接库3.HappyPack 就能让 Webpack 做到这点，它把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程4.当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个个挨着压缩再输出， 但是 ParallelUglifyPlugin 则会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成5.可以监听文件的变化，当文件发生变化后可以自动刷新浏览器，从而提高开发效率。6.(Hot Module Replacement)的技术可在不刷新整个网页的情况下做到超灵敏的实时预览。 原理是当一个源码发生变化时，只重新编译发生变化的模块，再用新输出的模块替换掉浏览器中对应的老模块。7.Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码。它依赖静态的 ES6 模块化语法，例如通过 import 和 export 导入导出8.可以使用CommonsChunkPlugin 把多个页面公共的代码抽离成单独的文件进行加载9.Webpack 内置了强大的分割代码的功能去实现按需加载，可以用import实现路由按需加载。10.Scope Hoisting 可以让 Webpack 打包出来的代码文件更小、运行的更快， 它又译作 “作用域提升”11.可以使用可视化分析工具 Webpack Analyse等去分析输出结果，从页进行优化. 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩13.优化图片，对于小图可以使用 base64 的方式写入文件中 给打包出来的文件名添加哈希，实现浏览器缓存文件 Q: generator 的实现原理个人理解generator 其实就是一个迭代器生成函数 generator执行后返回的是一个 迭代器对象，通过调用next方法来改变指针位置，每次移动到yield位置处 Answer使用 * 表示这是一个 Generator 函数内部可以通过 yield 暂停代码通过调用 next 恢复执行 123456789function* test() &#123; let a = 1 + 2; yield 2; yield 3;&#125;let b = test();console.log(b.next()); // &gt; &#123; value: 2, done: false &#125;console.log(b.next()); // &gt; &#123; value: 3, done: false &#125;console.log(b.next()); // &gt; &#123; value: undefined, done: true &#125; 从以上代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344// cb 也就是编译过的 test 函数function generator(cb) &#123; return (function() &#123; var object = &#123; next: 0, stop: function() &#123;&#125; &#125;; return &#123; next: function() &#123; var ret = cb(object); if (ret === undefined) return &#123; value: undefined, done: true &#125;; return &#123; value: ret, done: false &#125;; &#125; &#125;; &#125;)();&#125;// 如果你使用 babel 编译后可以发现 test 函数变成了这样function test() &#123; var a; return generator(function(_context) &#123; while (1) &#123; switch ((_context.prev = _context.next)) &#123; // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; // 执行完毕 case 6: case "end": return _context.stop(); &#125; &#125; &#125;);&#125; Q: 什么是 IFC，IFC的作用是什么个人理解IFC则是表示盒子从左到右的水平排列方式 他的高度也许比包含在它内最高的盒子高 Q: 什么是跨域，如果处理跨域问题个人理解根据浏览器的同源策略，协议，域名，端口不一致的情况下，不可以调用彼此的对象数据等信息 常用的处理跨域的方式 1 JSONP 通过URL中添加回调函数 2 如果是子域名的关系，可以考虑设置cookie 来传递数据 3 CORS 需要服务端做处理]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的tips]]></title>
    <url>%2F2018%2F08%2F11%2F%E6%9C%89%E8%B6%A3%E7%9A%84tips%2F</url>
    <content type="text"><![CDATA[在阅读文章的时候，一些有意思的知识点 react中请求数据为什么在 componentDidMount 这个生命周期componentWillMount -&gt; render -&gt; componentDidMount 如果在 componentWillMount 中做请求，setState 不会引起重新render （如果强制render？） 并且在react16中，componentWillMount 可能会被调用好多次 overflow-yiOS中 使用overflow-y: scroll; 导致滚动卡顿 overflow-scroll scroll 回流 重绘 article reflow 123456789101112/* * 根据上面的结论 * 将 2d transform 换成 3d * 就可以强制开启 GPU 加速 * 提高动画性能 */div &#123; transform: translate(10px, 10px);&#125;div &#123; transform: translate3d(10px, 10px, 0);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>js</tag>
        <tag>ndoe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一练第二期]]></title>
    <url>%2F2018%2F08%2F06%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC2%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[cookie + xss + csrf Q: cookie电商网站A和电影票网站B合作，A的用户，可以通过A网站下单购买电影票，之后跳转跳转到B（不需要登录）去选座位。 如果A、B是同域名，比如 a.domain.com, b.domain.com 能不能共享cookie? 如果不同域如何处理？ 个人理解根据浏览器同源策略，同域名和同端口可以共享cookie。如果不设置 Domain 参数，则cookie只存在于当前URL的所在域名。 如果A、B是同域名，可以设置Domain 参数为ab的父级域名，这样就可以传递cookie了 如果a，b 不同域，可以在跳转到b网站的时候，携带A用户的某些信息，比如用户id，在跳转到B 的时候 根据用户id拿到该用户的某些信息。 Answer 怎么设置第三方cookie。比如在网站A，那么网站B的cookie如何进入 网站A去请求自己的服务端，为什么不可以携带网站B的cookie 其实请求网站B的一个图片资源或者接口，都有可能被写cookie。所以第三方很容易写入cookie。比如在服务端通过设置Header什么的。但是问题是，这个cookie写了是传不到A的网站上去的。 A, B如果同属于某一个父级的子级域名 设置一级域名的cookie 就可以被子级域名所复用 Q：什么是XSS攻击? 如何防御?A跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。 如何防御 最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义。 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。 我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。 通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP 只允许加载本站资源， 只允许加载 HTTPS 协议图片，加载任何来源框架 Q： CSRF攻击是什么，如何防御### Q: 如果发现在某个用户的电脑上，网站的静态资源打不开了，如何确定是CDN的问题还是那个用户机器、浏览器的问题？个人理解判断是否是设备问题非常简单，多次更换设备尝试即可。判断是不是CDN问题，可以直接出问题的资源，看看有没有什么报错提示。或者访问下其余使用这个CDN的资源是不是有问题。 Q: 请说说在 hybrid 端实现类似原生般流畅的体验，要注意哪些事项 资源加载 在后台先打开 离线静态资源下载]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一练第一期]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83%E7%AC%AC1%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[08-03 – flex Q: flex 布局和传统布局的不同传统布局，基于盒模型，依赖 display属性 、position属性 、float属性，而FLEX用来为盒状模型提供最大的灵活性,不强制要求子元素的大小,任何一个容器都可以指定为 Flex 布局,可以简便、完整、响应式地实现各种页面布局。 Q: 如何比较两个颜色的差值个人思路利用第三方插件 nodejs-color-model 将格式为十六进制需要转化为rgba格式，然后R G B 三个颜色通道的数值各自做减法 第三方库直接计算差值 nodejs-color-difference answer首先将颜色拆分成r/g/b三个值，如果是字符串的颜色如#aabbff或者rgb(255,128,100)可以用正则表达式取出对应的r/g/b值。对于16进制字符串，可以使用parseInt(‘0xaa’)转10进制整数。 然后对于两个颜色，可以使用距离 1Math.sqrt( (r1-r2) *(r1-r2) +(g1-g2)*(g1-g2)+(b1-b2)*(b1-b2) ) 进行比较， 距离近则相似。 当然可以用 1Math.hypot( r1-r2, g1-t2, b1-b2) 来简化上述运算 1Math.hypot() // 函数返回它的所有参数的平方和的平方根 Q: 单页面应用一个单页面应用，有6张页面，F、E、A、B、C、D。 页面ABCD构成了一个冗长的用户验证过程。目前A、B、C对应用户验证过程的第1步，第2步，第3步。 页面F是首页，E是某张业务相关页面。用户到达页面E后，系统发现用户没有认证，触发验证流程，到达页面A，然后开始A-&gt;B-&gt;C-&gt;D流程。 页面D是验证结果页面（验证成功页面）。 请问，如果到达页面D后，如何让用户点击返回可以返回页面F，而忽略中间流程（注：用户可能根本没有到达过F，比如微信分享直接进入了E 补充下： 场景是上述场景，最好能做到到达页面D后，浏览器自然返回是F，再按返回，单页面系统退出； 另外请思考下各个流程如何实现流畅切换，不会有中间闪烁的页面 个人思路这种单页面应用在react项目中非常常见也很容易处理，直接变更页面哈希值就可以实现页面回退并且用户体验非常好。 如果不是框架的话，又不确定刘浏览器中是否有首页历史记录，那只想到了页面重新刷新了。 而且两种方式都需要注意的是，在返回到首页的时候，已经完成了用户登录行为，所以要保存用户状态，可以考虑jwt来处理鉴权 Q: 算法一个无序正负项 数组， 1[3, -6, 123, -945, -231, 112] 找出其中的最大的连续子序列 有如下乱序数组 A1, A2, A3, A4,……..An, 求 i, j (1&lt;= i &lt;= j&lt;= n), 使得Ai + …. + Aj 和最大, 输出i j answer1）最简单也最暴力的解法：首先列出 所有的子序列，然后找出其中和最大的 即可；实现思路：一个 记录当前最大值的变量maxSum；一个 子序列开始和结束的游标 变量；一个 当前子序列的和 的暂存变量，我们称之为 currentSum 或者 tmpSum（下文中 使用currentSum）找到所有的 子序列 我们可以通过两层循环的方式来解决第一层循环 i 从 0~ length-1;第二层循环 j 从 i ~ length - 1;这样的循环里 就可以找到所有的子序列了下一步 我们是要计算出所有子序列的和最简单的办法 就是 第三层循环从 i ~ j 累加求出和 然后求出来的每个和 和 maxSum 去比较，如果比maxSum 大 就替换 伪代码： 1maxSum = maxSum &lt; currentSum ? currentSum : maxSum; 三层循环结束后 maxSum就是我们要 求的解return maxSum即可这个算法的时间复杂度是O(n^3); 2）简化解法：我们在第二层循环中，我们已经知道 当前的 i/j之前的方法是在第三层的循环中 计算 i ~ j 的和现在 我们在第二层中 在进入第二层之前 我们重置一下currentSum第一次循环 是 i ~ i 当前我们就把 i 的值 记录到 currentSum去跟 maxSum 对比 然后 maxSum = maxSum &lt; currentSum ? currentSum : maxSum;第二次循环 是 i ~ i + 1 我们就把 当前的 i+1 累加到currentSum 这时候的 currentSum就是 i ~ i+1 的值，再去跟maxSum去比 然后 maxSum = maxSum &lt; currentSum ? currentSum : maxSum;以此类推第二层的循环中 就可以 计算出 以当前 i 开头的子序列中 最大的子序列是多少现在我们看回 到 第一层循环 i 的取值 是从 0 ~ length-1 那么我们是不是 可以找到 i 从 0 ~ length-1 所有的子序列中和最大的 伪代码思路： 123456第一层 i (0 ~ length-1) currentSum 清零 第二层 j(i ~ length-1) currentSum 累加 maxSum = maxSum &lt; currentSum ? currentSum : maxSum;return maxSum; 算法的时间复杂度是 O(n^2) 3）demo数组：[-2, 1, -3, 4, -1, 2 , 1, -5, 4] 首先 我们可以简单的简化一下 这个数组把相邻的同 正负的数字合起来，因为同符号的连续数 一定会同时存在在最大子序列里比如 [-1, -2, -3, 1, 2, 13] 那跟 [-6, 16] 是没有区别的 1[-2, 1, -3, 4, -1, 2, 1, -5, 4] ==&gt; [-2, 1, -3, 4, -1, 3, -5, 4] 然后 我们从头开始看 -2 这是第一个元素 那么 我们认为 当前的 最大子序列和 就是 -2然后 发现了一个正数 1 那我们可以确定 -2 一定不包含在 我们的最大子序列中也就是说 数组开头 如果是负数 可以忽略过去 现在 我们的数组 变成了 [1, -3, 4, -1, 3, -5, 4] 同理 结尾的如果是 负数 也不需要考虑 现在我们的数组 变成了 [1, -3, 4, -1, 3, -5, 4] 我们继续，现在 第一个元素是 1 最大和 是1 然后下一个数是 -3那么 -3 对 1 这个数 起到了阻断作用 也就是说 -3 把 前边所有正数 积累的能量都磨平了 甚至还变成了一个负数 那么 -3 我们称之为 一个阻断 当前的 最大和 还是 1 现在 我们到了 4 那么现在的最大值 就是4我们继续向下看 下个数字是 -1 之前最大的和是 4 加起来之后是 3 影响并不大 我们继续带着他 向后看 下一个 是个正数 3 也就是 4 -1 3 这样的情况 我们是不是可以认为 这个 -1 虽然降低了 和 但是 他连接了左右的正数 让我们当前的最大值 变成了 6 更新最大值 继续看 下一个是-5 同理 之前的 6+ -5 和 还是1 也没有阻断 我们去看看 后边 有没有一个大数 拯救我 后边 一个数 是 4加上 我们刚才记录的 1 和是5 最后还是没有挑战成功 所以 最大的和 还是之前的 6 公式： nums是我们的源数组 nums[i] 就是我们的当前元素 currentMax[i] 记录 我们以 i 结尾的子序列里 最大的一个子序列 那么 1currentMax[i] = max(currentMax[i - 1] + nums[i], nums[i]) 这个公式被称之为 状态转移公式 我们的这种解法 称之为 动态规划解法 简称：PD 然后我们去遍历 currentMax 这个数组 里边的最大值 就是我们要找的 最大值 1234567891011121314151617var maxSubArray = function(nums) &#123; // 初始化源数组，初始化An为结束的最大值 let A = nums; let dp = []; let maxSum = A[0]; dp[0] = A[0]; for(let i = 1; i &lt; A.length; i++) &#123; //状态转移公式 dp[i] = max(A[i], dp[i-1] + A[i]) maxSum = dp[i] &gt; maxSum ? dp[i] : maxSum; &#125; return maxSum;&#125;function max(a, b) &#123; return a &gt; b ? a : b;&#125; 文章导读 一道递归算法题 Q: 如何处理函数节流与防抖函数节流： 指定时间间隔触发一次任务 函数防抖： 多次任务触发，但是只有任务触发的间隔大于某一个时间段才去执行此任务 个人思路处理节流： 全局变量flag 当符合条件变更flag 值为TRUE 开始执行任务 任务执行完毕 则flag 为false 并且在下次任务过来的时候 去判断flag 如果flag 为TRUE了 则return掉 不去执行之后的逻辑 处理防抖：全局时间点time 当第一次任务]]></content>
      <categories>
        <category>练习</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码规范]]></title>
    <url>%2F2018%2F07%2F31%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[项目组内有一套统一的代码规范非常有利与项目维护 个人vscode配置 在vscode中安装 eslint 插件 code - 首选项-设置置 1"eslint.autoFixOnSave": true 这样vscode可以在保存 （command+s）的时候自动修正代码规范 这里列出几个常用的配置 rules quotes 引号类型： 单引号 1console.log('hello there') no-unused-lets 不能有声明后未被使用的变量或参数 同一模块有多个导入时一次性写完 no-duplicate-imports 1234import &#123; myFunc1 &#125; from 'module'import &#123; myFunc2 &#125; from 'module' // ✗ avoidimport &#123; myFunc1, myFunc2 &#125; from 'module' // ✓ ok 默认配置项项目中eslintrc文件中有配置项 1extends: standard 表示已经使用了 eslint-config-standard 这个中配置的规则 使用两个空格进行缩进 123function hello (name) &#123; console.log('hi', name)&#125; 关键字后面加空格 12if (condition) &#123; ... &#125; // ✓ okif(condition) &#123; ... &#125; // ✗ avoid 函数声明时括号与函数名间加空格 12function name (arg) &#123; ... &#125; // ✓ okfunction name(arg) &#123; ... &#125; // ✗ avoid 始终使用 === 替代 == 12if (name === 'John') // ✓ okif (name == 'John') // ✗ avoid 字符串拼接操作符 (Infix operators) 之间要留空格 1234// ✓ oklet x = 2let message = 'hello, ' + name + '!'let msg = `hello, $&#123;name&#125;!` 逗号后面加空格 123// ✓ oklet list = [1, 2, 3, 4]function greet (name, options) &#123; ... &#125; 不允许有连续多行空行 每个 let 关键字单独声明一个变量 始终将逗号置于行末 123456789let obj = &#123; foo: 'foo' ,bar: 'bar' // ✗ avoid&#125;let obj = &#123; foo: 'foo', bar: 'bar' // ✓ ok&#125; 除非key包含 - 之类的特殊符号，否则一律不添加单引号 12345let obj = &#123; 'foo': 'foo', // ✗ avoid bar: 'bar', // ✓ ok 'key-2': 2 // ✓ ok&#125; 键值对当中冒号与值之间要留空白 1234let obj = &#123; 'key' : 'value' &#125; // ✗ avoidlet obj = &#123; 'key' :'value' &#125; // ✗ avoidlet obj = &#123; 'key':'value' &#125; // ✗ avoidlet obj = &#123; 'key': 'value' &#125; // ok 不要定义冗余的函数参数 1234567function sum (a, b, a) &#123; // ✗ avoid // ...&#125;function sum (a, b, c) &#123; // ✓ ok // ...&#125; 避免不必要的布尔转换 对象属性换行时注意统一代码风格 123456789101112const user = &#123; name: 'Jane Doe', age: 30, username: 'jdoe86' // ✗ avoid&#125;const user = &#123; name: 'Jane Doe', age: 30, username: 'jdoe86' &#125; // ✓ okconst user = &#123; name: 'Jane Doe', age: 30, username: 'jdoe86'&#125; 代码块中避免多余留白 123456789if (user) &#123; // ✗ avoid const name = getName()&#125;if (user) &#123; const name = getName() // ✓ ok&#125; 注释首尾留空格 12345//comment // ✗ avoid// comment // ✓ ok/*comment*/ // ✗ avoid/* comment */ // ✓ ok 检查 NaN 的正确姿势是使用 isNaN() 12if (price === NaN) &#123; &#125; // ✗ avoidif (isNaN(price)) &#123; &#125; // ✓ ok 不要使用分号 不建议使用var]]></content>
      <categories>
        <category>coding</category>
      </categories>
      <tags>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识typescript]]></title>
    <url>%2F2018%2F07%2F18%2F%E8%AE%A4%E8%AF%86typescript%2F</url>
    <content type="text"><![CDATA[typescript 概览 基础类型12345678910111213let isDone: boolean = falselet age: number = 2let yourname: string = 'who'let ary: number[] = [1, 2, 3]let ary2: Array&lt;string&gt; = ['1']let moreAry: any[] = ['', 2, true]let isUn: void = null 联合类型可以是 多种类型的一种 12345function data(arg: string | number) &#123; return `arg is $&#123;typeof arg === 'string' ? 'string' : 'number'&#125;`&#125;console.log(data(1), data('username')) 接口 对值所具有的结构进行类型检查 必须包含一个label属性且类型为string 123456789interface args &#123; label: string&#125;function explainUser(user: args) &#123; return user[&apos;label&apos;]&#125;explainUser(&#123;label: &apos;123&apos;&#125;) 比如编写一个 获取数据的函数 getData 123async function getData(url: string, data: object) &#123; return xxx&#125; 需要传递两个参数 url data 我们将其调整为 interface 形式 123456interface dataType &#123; url: string, data: object&#125;async function getData(dataValue: dataType) &#123;xxx&#125; 类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以 可选属性 添加一个 ? 表示这个属性是可选的 12345interface dataType &#123; url: string, data: object, uid?: number&#125; 函数 函数类型包含两部分：参数类型和返回值类型 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它 返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为void而不能留空 根据当前环境参数 返回config 123function (env: string, number: number): object &#123; return config[env][number]&#125; 可选参数必须跟在必须参数后面 123function (env: string, number: number, uid?: number) &#123; xxx&#125; 这里加了一个可选参数 UID, uid 放到必选参数后面 在所有必须参数后面的带默认初始化的参数都是可选的 123function (env: string, number: number, uid = 137722) &#123; xxx&#125; 这里的参数UID带有默认参数 所以它是可选的 类型断言123&lt;类型&gt;值 值 as 类型 比如我们需要在还没有确定类型的时候读取其值 1234567function getData (classify: string, page: number | string ): boolean &#123; if (page.length &gt; 1) &#123; &#125; else &#123; &#125;&#125; 这里肯定会有报错 所以需要处理为 1if ((&lt;string&gt;page).length ) 内置对象JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。 元组类TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。 public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 泛型Promise经常需要去构建promise处理方法 12345const info = (uid: number): Promise&lt;string&gt; =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(`$&#123;uid&#125; is success`) &#125;)&#125; 如果返回值不确定 可以写为 12345const info = (uid: number): Promise&lt;any&gt; =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; xxx &#125;)&#125; react中ts的应用]]></content>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全令牌JWT]]></title>
    <url>%2F2018%2F07%2F18%2F%E5%AE%89%E5%85%A8%E4%BB%A4%E7%89%8CJWT%2F</url>
    <content type="text"><![CDATA[安全令牌JWT: JSON对象的形式安全传递信息的方法 前段时间处理一个抽奖H5，测试过程中想到如果有用户抓到抽奖接口，比如 1https:xxx/lottery/userinfo 如果直接访问抽奖接口，可以直接进行抽奖动作。这里就涉及到处理验证用户身份的问题 之后的解决方式是 判断接口的cookie中是否包含 userInfo 等参数信息 不过还可以通过另外一种方式来处理– JWT 什么是JWT （JSON WEB TOKEN）JWT是通信双方之间以 JSON对象的形式安全传递信息的方法。 其实可以理解为使用非对称算法来进行前后端校验。 JWT 由三部分组成 头部 typ 声明类型 alg 声明加密的算法 然后按照此规则将头部信息进行base64编码，构成JWT第一部分 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9 payloadpayload 就是存放有效信息的地方 payload 中有一些参数字段是建议使用的 （仅列出几个） 参数 含义 iat jwt的签发时间 exp jwt的过期时间，这个过期时间必须要大于签发时间 nbf 定义在什么时间之前，该jwt都是不可用的 比如来定义一个payload 1234&#123; &quot;exp&quot;: Math.floor(Date.now() / 1000) + (60 * 60), &quot;name&quot;: &quot;John Doe&quot;&#125; payload 会进行base64编码，构成JWT第二部分 签证 可以看到，签证部分是由三个部分组成的 参数 含义 base64UrlEncode base64加密后的Header base64UrlEncode base64加密后的payload your-256-bit-secret 自定义的加密secret secret 相当于私钥，不可泄漏，如果客户端可以拿到secret，就可以自我签发JWT了 12var encodedString = base64UrlEncode(header) + &apos;.&apos; + base64UrlEncode(payload)var signature = HMACSHA256(encodedString, &apos;secret&apos;) signature 是JWT的第三部分 将以上三部分拼接起来，就是最后的JWT 第三方库jsonwebtoken如果自己在生成jwt,有点复杂。目前已经有很多开发的第三方库来支持JWT。比如 jsonwebtoken jsonwebtoken sign 用于生成 token verify 用于检验token koa-jwtkoa-jwt 用于验证接口中是否包含token信息 搭建了一个简易的server 来看下效果 项目Git地址 1234567891011121314151617181920212223app.use( jwtKoa(&#123;secret: SECRET&#125;) .unless(&#123; path: [/\/login/] // 不需要通过jwt验证的请求路径 &#125;))router.get(&apos;/login&apos;, async (ctx) =&gt; &#123; let token = jwt.sign(&#123; name: &apos;dva&apos; &#125;, SECRET) console.log(token, &apos;token&apos;) ctx.body = &#123; token &#125;&#125;)router.get(&apos;/try&apos;, async (ctx) =&gt; &#123; let token = ctx.header.authorization let result = jwt.verify(token, SECRET) ctx.body = &#123; result &#125;&#125;) /login 拿到token 1// &#123;&quot;token&quot;:&quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiZHZhIiwiaWF0IjoxNTMxMjgwMDg2fQ.Rh_vAKeytjAL2TbOk-MmXQWFesszjRU3Bzldrx5x17s&quot;&#125;% 如果不添加token 会被koa-jwt 拦截 添加 token 工作机制 图片来自于文章 《前后端分离之JWT用户认证》 登录拿到JWT 前端发起请求，Header中挂载JWT 项目实战由于我搭建的这个项目中有这种需要鉴权的接口比较少，所以并没有使用koa-jwt来处理。只是用了 jsonwebtoken 项目GIT地址 server端构建两个接口 login , lottery login 用来生成JWT 返回给前端 1234token = jwt.sign(&#123; name: &apos;who&apos;, exp: Math.floor(Date.now() / 1000) + (60 * 60), // 设置 token 过期时间 &#125;, SECRET) lottery 用来验证JWT，验证通过则进行抽奖动作 12345678910let token = this.headers.authorization // 解码 let decoded = jwt.verify(token, SECRET) // console.log(decoded, &apos;decoded&apos;) let &#123;name&#125; = decoded if (name != &apos;who&apos;) &#123; code = 403 return &#125; 前端 首页点击登录后 经返回的token信息存储起来 我这里拿到token之后将其写入了localStorage 1window.localStorage.setItem(&apos;token&apos;, token) 进入抽奖页面进行抽奖，每次请求的时候挂载Authorization 12345axios.get(`/$&#123;APP_NAME&#125;/win`, &#123; headers: &#123; Authorization: token &#125;&#125;) 如果传递错误的token 在server端JWT验证的时候就会报错 项目在线地址 总而言之，如果你的接口需要考虑鉴权问题，可以参考下JWT来处理。 Other jsonwebtoken jwt.io 项目git地址 资料1 资料2 问题回复这篇文章发布之后，很多同学提出了一些问题，这里一一回复。感谢各位的评论。 问题1： 关于base64处理 Header 和 payload其实JWT在处理Header 和 payload 的时候，只是很简单的进行了Base64编码。 如果拿到某一个token的话，是很容易就将其解码出来的。 123456789101112131415161718192021const base64url = require(&apos;base64url&apos;)let header = &#123; &apos;typ&apos;: &apos;JWT&apos;, &apos;alg&apos;: &apos;HS256&apos;&#125;let resultH = base64url(JSON.stringify(header))console.log(resultH, &apos;resultH&apos;)let payload = &#123; name: &apos;dva&apos;, exp: 1531410000&#125;let result = base64url(JSON.stringify(payload))console.log(result, &apos;result&apos;)// 解码payloadlet isP = &apos;eyJuYW1lIjoiZHZhIiwiZXhwIjoxNTMxNDEwMDAwfQ&apos;let getP = base64url.decode(isP)console.log(getP, &apos;getP&apos;) 所以不建议在payload中存放敏感信息，比如用户手机号，地址信息等 问题2 JWT怎么做续签更新查阅资料后总结，jwt的续签更新目前有以下处理方式，基本的原理就是在某一个时间点，server端发放新的token 每次客户端发起新的请求过来，server自动更新token，返回最新的token信息给客户端，客户端拿到token后需要再更新token 比如 在用户点击抽奖，发起请求的时候，server端每次更新一个token（我这里只更新jwt的有效期） 拿到新的token之后将其返回。下次发起抽奖动作的时候，挂载这个最新的token 但是这种处理方案有缺陷，如果用户两次请求的间隔时间超过了过期时间（比如20分钟），则接口过来的时候 首先会被判断为过期状态，请求终止（之后的代码不被执行，不会被下发新的token了）。用户会被强制退出到登录界面。 每次请求过来的时候，不去判断有效期 （当然此请求本身携带的token必须在有效期内，我的意思是不像第一种，判断距离过期还有多久） 直接下发新的token 问题3 处理注销可以说token比较重要的问题就是注销token。 比如我上面第二个jwt的项目，当用户点击退出登录的时候，仅仅在客户端做了token的删除。 但是实际上这个token还是处于有效期内的。如果用户保存了token值，在点击了退出登录之后，实际还可以使用此token值的。可以理解为伪注销。 传统的方式怎么处理用户的注销行为呢？– 删除数据库记录。当用户注销登录信息的时候，server会变更数据库信息 但是jwt是没有介入服务器来存储用户状态的。这就比较难处理了。我们希望token能够在用户注销后不可以被继续使用了 设置比较短的token 有效期，每次请求过来的时候，重新下发，不断更新token. 使用服务器存储token状态。当用户点击注销，将token置空。 问题4 JWT单点登录（强制退出用户登录,比如修改密码后,希望能让其他客户端登陆的地方全部强制登出）可以理解为如何让一个token立即失效（有点像上面的问题3） jwt + 数据库（比如 redis）+ 白名单 （这种思路是公司同事提出来的，特别感谢~） 每一位用户在设备A登录的时候，将UID和token对应关系存放起来 1myRedis.set(`$&#123;uid&#125;:token`, $&#123;tokenA&#125;) 用户换设备B登录的时候，将redis中的的token进行更新 1myRedis.set(`$&#123;uid&#125;:token`, $&#123;tokenB&#125;) 每次请求发起的时候，server端去验证该UID对应的token信息是否是最新的token， 这样 如果携带的不是redis中的token的话，拒绝请求。前端强制退出登录。 我将这个单点登录的逻辑加入到了项目中。 登录尝试 你可以在两台设备使用同一个用户名进行登录，尝试是不是可以将第一台设备的状态登出。 新增逻辑部分：将用户{name, token} 对应关系存放在文件中，每次发送抽奖请求的时候，判断文件最新的token与接口携带的token是否一致。不一致则反馈前端需要退出登录 缺点：需要保留每一位用户的 {user, token} 对应关系 jwt + 数据库（比如 redis）+ 黑名单 当用户点击退出登录，此token则被放入黑名单（比如存放在redis）。如果有请求此时携带了黑名单中的token，则不予处理 缺点：长此以往黑名单数据量增长 问题5 如何防范Replay Attacks （重放攻击） 重放攻击就是攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程 比如用户的token被获取，那么即使用户登出了系统，其他人还可以利用Token模拟正常请求，而服务器端则无法判断这种情况。 还是黑名单思路，每次token更新之后，或者用户登出之后，旧的token被放入黑名单。携带此token的请求一律不予处理 问题6 使用‘每一次发送请求就去更新token的方式’ 如果客户端有并发的请求，如何处理em，这个和上面的问题5有点矛盾，如果使用变化token的情况处理，那么肯定会有当请求并发状态下，第一个请求在处理完毕拿到新的token，后面的请求携带的token就变成了旧的token，请求会失败 查阅资料后发现，有些人在将token存到黑名单的时候，会同时添加一个“宽限时间” 。当请求中携带了一个黑名单中的过期token，则去判断去“宽限时间”，如果在期宽限之间之内，则予以通过。 不过我个人没想明白，这种处理方式是不是有问题，既然已经被放入黑名单了，那为什么又来一个“宽限时间”。为什么不直接设置一个长一点的有效时间。 以上是对各位的一些回答。欢迎留言讨论。 补充文章 JSON Web Token - 在Web应用间安全地传递信息 jwt 相关问题 有关JWT(Json Web Token)如何解决并发问题的思考 不要用 JWT 来做 Web 应用的会话管理]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器三大件的升级]]></title>
    <url>%2F2018%2F07%2F02%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%89%E5%A4%A7%E4%BB%B6%E7%9A%84%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[服务器以及其配置升级记录 升级版本为 npm v5.6.0 node v8.11.2 cnpm v5.2.0 pm2 v2.10.2 nvm 安装nvm安装 node1nvm i 8.11.2 以下三个升级请切换到root身份操作 升级npm1npm i -g npm@5.6.0 升级cnpm1npm i -g cnpm@5.2.0 升级pm21npm i -g pm2@2.10.2 pm2升级之后 work身份下需要执行 pm2 update 升级之后去查看pm2 list pm2 show xxx 需要DELETE 重新启动才可以，直接restart不行 在服务器创建新的身份以root身份登录到服务器之后 创建新的身份 1useradd vbird 这样就创建了一个新的角色 但此时尝试使用此身份登录服务器 1ssh vbird@xxx 会提示 1Permission denied, please try again 是权限错误，并不是密码错误 这是因为使用 useradd 新郑vbird 账号之后，在默认情况下，账号是暂时被封锁的。也就是无法登录的。 我们需要给vbird来设置密码 1passwd vbird 然后输入密码就可以了。此密码将会是使用新身份登录服务器的密码。 修改项目配置信息，以新身份去进行部署报错 – 无权限创建文件夹 看一下此文件夹的属性 可以看到 releases 这个文件夹的权限属性是 1drwxr-xr-x 4 root root 4096 May 21 21:10 releases 【文件夹】【可读可写可执行】【可读可执行】【可读可执行】【文件所有者root】【文件所属用户组root】 所以现在vbird的权限是 【可读可执行】 而创建一个文件夹属于 【写】的权限范围 处理方案： 变更文件夹权限 登录服务器 进入/home 然后修改work文件夹权限 1234cd /homechgroup work work // 变更文件所属组为 work组chown vbird work // 变更文件所有者为vbird 看些变更后的权限 work文件夹内部已经有我之前使用root身份部署的时候创建的项目文件夹，需要全部删除才可以部署成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>Linux</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划9]]></title>
    <url>%2F2018%2F07%2F02%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%929%2F</url>
    <content type="text"><![CDATA[work code review 国际公播排行榜 儿童节 study linux 升级三大件]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>work</tag>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器部署]]></title>
    <url>%2F2018%2F06%2F12%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[前段时间在公司部署项目的时候，运维同学说了一堆关于服务器的东西，顿时感觉不知所云，云里雾里。。。索性拿这个项目练习一下，简单了解项目部署到服务器的这个流程是怎么处理的 预备知识pm2pm2 是启动node进程管理工具 常用命令··· pm2 start app.js ： 启动服务，入口文件是app.js pm2 list 查看有哪些进程启动 pm2 show xxx 查看某一个服务的详情 npm restart [name or id] ： 重启服务 pm2 monit ： 对服务进行监控 ··· 一个项目的package.json 文件 平时启动服务我们可以使用 node run app.js 如果借助pm2 来启动服务 就可以输入 pm2 start app.js 在命令行输入 pm2 list 可以查看正在运行的项目 pm2支持配置文件启动 script 启动脚本路径 exec_mode 应用启动模式，支持fork和cluster模式 instances 应用启动实例个数，仅在cluster模式有效，默认为fork fork和cluster模式fork为单进程 cluster可以启动多个进程 在项目中新增一个pm2配置文件 pm2.config.json 123456789101112131415&#123; &quot;name&quot;: &quot;mxx-project&quot;, &quot;script&quot;: &quot;./index.js&quot;, &quot;error_file&quot;: &quot;./logs/err.log&quot;, &quot;out_file&quot;: &quot;./logs/out.log&quot;, &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm Z&quot;, &quot;instances&quot;: 3, &quot;merge_logs&quot;: true, &quot;exec_mode&quot;: &quot;cluster&quot;, &quot;node_args&quot;: &quot;&quot;, &quot;ignore_watch&quot;: [&quot;node_modules&quot;], &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;development&quot; &#125;&#125; 在命令行输入 1pm2 start pm2.config.json 则会有三个进程被创建 注： 如果你的服务器是多核的 那么很有可能在cluster 模式下 被创建多个进程 可以查看一下自己的服务器是几核的 shipitshipit 是自动化的服务器部署工具 一个简单的shipit配置文件 123456789101112131415161718module.exports = shipit =&gt; &#123; require(&apos;shipit-deploy&apos;)(shipit) shipit.initConfig(&#123; default: &#123; workspace: &apos;/tmp/myapp&apos;, deployTo: &apos;/var/myapp&apos;, repositoryUrl: &apos;你的GitHub地址&apos;, ignores: [&apos;.git&apos;, &apos;node_modules&apos;], keepReleases: 2, deleteOnRollback: false, key: &apos;/path/to/key&apos;, shallowClone: true, &#125;, staging: &#123; servers: &apos;你的服务器地址&apos;, &#125;, &#125;)&#125; 连接服务器购买服务器之后 得到IP地址 可以尝试登陆服务器 一般自己的服务器可以使用root身份登陆操作 1ssh root@ipipip 由于后面项目要部署到服务器中 建议可以先做ssh-copy-id 建立信任 这样就不用重复输入密码了 在服务器上配置环境一般来说 需要安装 npm cnpm node pm2 git nginx 安装npm 1yum install npm 安装 cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装pm2 1npm i pm2 安装node 1npm i n 安装git 1yum install git 启动一个简易服务我们来写一个简单的脚本 在服务器上， 我这里是在 /home/work 目录下新建了一个app.js (依次执行) 123cd homemkdir worktouch app.js 在app.js中 写一个最简单的服务 12345678const http = require(&apos;http&apos;)const port = 3389http.createServer((req, res) =&gt; &#123; res.end(&apos;Hello word!&apos;)&#125;).listen(port, () =&gt; &#123; console.log(port, &apos;port&apos;)&#125;) 启动app.js 1node app.js 然后打开浏览器，输入IP+端口号，就能在页面中看到hello word了 –补充– 1 这里使用的端口号是 3389 是因为我的服务器中 安全组中已经配置了 3389 这个端口号 如果你使用的是其余端口 要注意去查看有没有配置安全组 2 关于启动服务 如果使用的是node 那么一旦退出服务器，则无法再访问此服务 可以换成使用pm2 来启动 这样一旦启动 除非报错，将会一直有此进程存在 准备部署 准备项目 项目是用koa1 + React react的项目地址 点我查看GitHub地址 启动的端口号调整到3389 准备pm2启动文件 创建pm2文件夹 在其中写一个 production.json 用于启动pm2 在项目中创建一个 shipit.js 基本配置如下 12345678910111213141516171819202122232425262728293031module.exports = function (shipit) &#123; require(&apos;shipit-deploy&apos;)(shipit) require(&apos;shipit-cnpm&apos;)(shipit) require(&apos;shipit-pm&apos;)(shipit) shipit.initConfig(&#123; default: &#123; workspace: &apos;/tmp/deploy/your-project&apos;, deployTo: &apos;/home/work/your-project&apos;, repositoryUrl: &apos;https://github.com/youproject.git&apos;, ignores: [&apos;.git&apos;, &apos;node_modules&apos;], keepReleases: 2, deleteOnRollback: false, key: &apos;/path/to/key&apos;, shallowClone: true, cnpm: &#123; flags: &apos;--production&apos;, local: false, npm: &apos;cnpm&apos;, remote: true &#125;, pm: &#123; production: &#123; path: &apos;/home/work/your-project/current/pm2/production.json&apos; &#125; &#125; &#125;, production: &#123; servers: [&apos;root@你的IP地址&apos;] &#125; &#125;)&#125; 这里 pm2 使用的配置文件来启动 所以配置了 pm 参数 会根据这个文件路径来启动pm2 在项目的package.json中 添加两个字段 12&quot;deploy&quot;: &quot;shipit production deploy&quot;,&quot;rollback&quot;: &quot;shipit production rollback&quot;, 将项目push到GitHub中 执行 npm run deploy 项目部署完毕后，去服务器查看下项目进程 1pm2 list 打开页面 看下效果 到目前为止，算是部署完毕了 部署过程出现的问题 报错1 解决： 服务器上忘记安装git了 报错2 这个就很明显了，没有安装 cnpm 部署成功之后去服务器查看 项目并没有启动 原来部署完毕是 然后求助一位大神，发现是shipit配置文件中 没写 1require(&apos;shipit-pm&apos;)(shipit) [摔桌子！] 调整文件后重新上线 会启动三个进程 根据项目端口号配置阿里云如果你的项目启动时候端口号并没有在安全组中配置，需要在后台中添加安全组 在访问页面的时候 还需要输入端口号 3389。非常懒，不想输入端口号 在安全组中添加默认端口80，将启动文件app.js中端口调整为80。这样就不需要输入端口号了 那如果不想修改app.js文件怎么办，使用NGINX 配置NGINX 安装 nginx yum install nginx 查看NGINX配置文件 1cat /etc/nginx/nginx.conf 很简单的配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; 将项目入口文件app.js中端口号调整为 9999 处理Nginx.conf.js 最后调整为 （比较重要的是server 这里只展示server部分） 12345678server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://127.0.0.1:9999/; &#125; &#125; 启动Nginx 1nginx -s reload Nginx配置出现的问题 重启Nginx 在重启Nginx的时候 一直报错 查阅文章后处理 12nginx -c /etc/nginx/nginx.confnginx -s reload 搞定~ 欢迎访问 点我查看项目 参考文章 pm2 PM2使用技巧 pm2进程管理工具使用总结 使用shipit-deploy实现自动化的多服务器部署 使用 Shipit 来自动化部署 Node 应用 初识 Nginx 重启nginx后丢失nginx.pid，如何重新启动nginx]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>Linux</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh-copy-id]]></title>
    <url>%2F2018%2F05%2F26%2Fssh-copy-id%2F</url>
    <content type="text"><![CDATA[如何在本机中进行ssh-copy-id 在Linux中登录服务器可以使用 1ssh root@xxxxx 然后会让你输入密码 就可以登录了 可以通过shh-copy-id实现 无密码登录 相当于本机电脑与远程服务器之间建立信任关系 建立信任关系 1 先查看本机中用户主目录下是否有 .ssh目录 123cd /User/xxx/.sshls -a 可以看到 id_rsa和id_rsa.pub这两个文件 2 将 id_rsa.pub 中内容添加到git中 3 去执行ssh-copy-id吧 如果 本机中并没有 那两个文件呢 ssh-keygen 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 然后就生成那两个文件了 参考文章远程仓库]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝与浅拷贝]]></title>
    <url>%2F2018%2F05%2F15%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[先来复习一下几种数据类型 js基本数据类型： number string undefined null Boolean 引用数据类型 ： Array Object Regexp Function 等 没有嵌套对象的话,就没必要区分深浅拷贝了。只有在有嵌套的对象时,深拷贝和浅拷贝才有区别 比如 12345let obj1 = &#123; name: 'tom', age: [1, 4, 5]&#125; 由于age属性是对象 这里拷贝就应该区分深浅拷贝 最简单实现深拷贝的方法 1234567let a = &#123; name: 'tom', person: ['a', 'b']&#125;let b = JSON.parse(JSON.stringfy(a))b['person'].push(5)console.log(a, b); 但是使用这种方式 有缺点 拷贝出错 有一些特殊的对象比如 函数 正则 稀疏数组 在通过这种方式进行拷贝的时候 会出错 1234567891011var a = &#123; name: 'tom', arr: [1, 2, 3], fn: () =&gt; &#123;&#125;, isE: new Regexp('d'), newAry: new Array(3)&#125;let b = JSON.parse(JSON.stringify(a))console.log(b.fn) // undefinedconsole.log(b.isE) // &#123;&#125; -- 这里是正则会变为一个空对象console.log(b.newAry) // &#123;&#125; -- 这里是正则会变为一个空对象 会抛弃对象的constructor,所有的构造函数会指向Object 123456789101112class Parent () &#123; xxx&#125;let isP = new Parentlet obj = &#123; isTest: isP&#125;let newObj = JSON.parse(JSON.stringify(a))console.log(obj['isTest'].constructor) // [Function: Parent]console.log(newObj['isTest'].constructor) // [Function: Object] Object.assignObject.assign() 也是属于 浅拷贝 1234567let a = &#123; name: '1', ary: [1, 3]&#125;let b = Object.assign(&#123;&#125;, a)a['ary'].push(4)console.log(b['ary']) // [ 1, 3, 4 ] 可以看到 后面修改了数组 还是会影响b 所以这属于 浅拷贝 第三方提供的可以进行深拷贝的方法$.extend(true, {}, obj) loadsh12_.cloneDeep(obj)_.clone(obj,true) react 中 immutable.js]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack系列之-优化篇]]></title>
    <url>%2F2018%2F05%2F08%2Fwebpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E4%BC%98%E5%8C%96%E7%AF%87%2F</url>
    <content type="text"><![CDATA[优化篇将注重提高开发速度，优化项目体验 happypack项目构建过程有大量的文件需要解析和处理 涉及到大量的读写操作 而 webpack的运行的单线程的 【在node中运行】也就是webpack要一个一个的处理任务 无法同时处理 HappyPack 可以帮助webpack 将任务分解到多个子进程去并发执行 12345678910111213141516171819module.exports = &#123; module: &#123; rules: [ // js 文件的处理 交给 id 为 babel的happypack的实例 &#123; test: /\.js$/, use: ['happypack/loader?id=babel'] &#125;, ] &#125;, plugins: [ // 处理 js new HappyPack(&#123; id : 'babel', loaders : ['babel-loader?cacheDirectory'] &#125;) ]&#125; tree-shakingscope hoisting参考文章 happypack 原理解析]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack系列之-功能篇]]></title>
    <url>%2F2018%2F05%2F07%2Fwebpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E5%8A%9F%E8%83%BD%E7%AF%87%2F</url>
    <content type="text"><![CDATA[功能篇从代码分割和按需加载 两个方面来分析 代码分割为什么使用代码分割？ 我们的项目采用相同的一套技术栈 互相之间有很多相同的代码。如果每一个页面都不做任何处理 直接打包，会造成 1 相同的资源重复加载 很浪费流量 2 页面加载速度慢 用户体验不好 如果将多个页面的公共部分抽取成一个独立的文件 就能优化这些问题。 用户在访问A页面的时候 已经将代码缓存起来了 那么访问B的时候 有公共代码部分 就会直接读取缓存文件 一个规范的项目应该有如下三部分chunk chunk 含义 vendor.js 项目使用的技术栈 common.js 剔除技术栈之后的 所有页面都依赖的公共代码 [name].js 每一个网页各自独立的代码 commonschunkplugincommonschunkplugin 是webpack内置的插件 CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用 用来处理在多入口下提取公共模块 1234567891011entry: &#123; index: './index.js', main: './main.js'&#125;-- other --plugin: &#123; new webpack.optimize.CommonsChunkPlugin(&#123; name: 'bundle' &#125;)&#125; 会将 多个入口文件中都引入的公共模块打包到一个独立的文件中，以便在其他的入口和模块中使用 然而我们的项目全部都是单入口文件 为什么这里还配置了 CommonsChunkPlugin ？ — 因为有vendor 当我们在入口中加入 vendor 参数 12345entry: &#123; vendor: ['react', 'react-dom'], index: './index.js', main: './main.js'&#125; one.js 是 index 与 mian都引入的文件 在没有加入vendor的时候 文件编译结果为 如果添加 vendor 属性 文件编译之后 会发现 bundle 中提取的公共chunk 将会是空的 公共组件 one.js 并没有进入 bundle.js 中 而是在两个入口文件中存在着 所以这就涉及到 公共业务模块与类库或框架分开打包 的问题 公共业务模块与类库或框架分开打包12345678910111213module.exports = &#123; entry: &#123; vendor: ['react'], index: './index.js', main: './main.js' &#125;, -- -- plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: ['bundle', 'vendor'] &#125;) ]&#125; 但是这里有一个问题 如果项目中有 非 vendor 中的文件发生了重新编译 vendor 的文件也会被重新编译issure 可以看到虽然两次打包的结果大小相同 但是vender还是被处理了新的哈希值 vendor 哈希值一直变动问题manifest为了最小化生成的文件大小，webpack使用标识符而不是模块名称，在编译期间生成标识符，并映射到块文件名，然后放入一个名为chunk manifest的JS对象中。重点就在于！！当我们使用CommonsChunkPlugin分离代码时，被分离出来的代码（比如React库，被打包为vendor），会默认被移动到entry中最后一个入口进行打包（第一个入口是index.js。重要的是，chunk manifest将随着这些被分离出来的代码共同打包！！！ 由于我们更改源代码后，不但会更新app的hash值，还会生成新的映射，然后新的映射又会和资源代码一同打包，又由于chunkhash是根据内容生成hash的，那么加入了新的映射对象chunk manifest的资源代码被打包后，hash自然也会发生改变。这反过来，产生的新hash将使长效缓存失效。 那么接下来我们需要做的就是把 manifest分离出来 12345plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: ['vendor', 'manifest'] &#125;)] 添加一个entry中未用到的名称 就可以manifest分离出来了 这样每次文件变动的时候 manifest.js 会发生变动 而 vendor 不会再发生变动 NamedChunksPlugin根据文件内容进行打包 按需加载单页面应用中，如果所有一次性加载所有功能对应的代码，可能会导致网页加载缓慢，交互卡顿的现象。 处理方案： 最好用户需要什么功能 就加载对应的代码【按需加载】 require.ensure1234require.ensure([dependencies], function () &#123; require(‘./a.js)&#125;, chunkname) require.ensure 引入但是不执行 要在函数里面载 require一次才执行 动态加载 import12345if (lan === 'en') &#123; import(/* webpackchunkname: m1 */ './module1.js' )&#125; else &#123; import(/* webpackchunkname: m2 */ './module2.js' )&#125; 动态加载 一旦加载进来就会被执行 参考文章 什么是持久化缓存？]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-linux私房菜]]></title>
    <url>%2F2018%2F05%2F07%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-linux%E7%A7%81%E6%88%BF%E8%8F%9C%2F</url>
    <content type="text"><![CDATA[《Linux私房菜》阅读笔记整理 chapter 0计算机的五大单元 - 输入 输出 CPU内部的控制单元和算数逻辑单元 内存 CPU central processing unit 主要作用，管理和运算 （算数逻辑单元，控制单元） - 前者负责程序运算和逻辑判断 后者负责协调各个组件与各个单元之间的工作 CPU的重点在与 运算和判断，这些数据来自于内存. 内存则从输入单元传输进来，CPU处理完毕之后先传递给内存，再从内存传输到输出单元 目前主流的CPU是双核以上，原本的单核是指仅有一个运算单元，多核是指在一个CPU壳子里装了多个运算内核 CPU 的性能对比1 内部的微指令集 2 CPU的频率 – 每秒CPU的工作次数 这个数值越高 代表单位时间内可以做更多的事情 比如某款CPU频率 3GHZ 则其每秒可进行 3 x 10的9次方 工作 外频 倍频为了加速计算速度，CPU开发商就在CPU内部加上一个加速功能 外频 ： CPU与外部组件进行数据传输，运算的频率 倍频： CPU内部用来加速性能的一个倍数 两者相乘才是CPU的频率 超频 – 有人喜欢将CPU的倍频或者外频通过主板的设定更改为较高频率，但因为CPU的倍频一般在出厂的时候会被确定无法更改，所以一般修改的是外频 比如 3GHZ的CPU设置为超频 可以将外频 333HZ 调整到 400 MHZ 这样主板各个组件运行频率增高 CPU可以到达 3.6GHZ 但是可能造成死机 软件程序运行设计出一种人类能看懂的语言，然后创造一种“编译器”来将人类写的程序语言转换为机器语言，常见的编译器语言，c c++ 操作系统一组程序，用来管理计算机所有活动以及驱动系统中所有硬件 让CPU开始判断逻辑与运算数值，让内存开始加载数据 以上就是操作系统的内核 硬件由内核管理，那想要去开发软件，就需要去参考这个内核的先关功能，因此操作系统提供了一组开发接口出来 1 操作系统的内核是参考硬件规格写的，所以同一个操作系统不能在不同的硬件架构下运行 2 应用程序的开发是参考操作系统提供的开发接口，所以该应用程序只能在该操作系统中运行 123456789// 直接操作一个硬件设施音箱 -- 请播放音乐 “黑白格”// 使用内核function play (music) &#123; const target = '音箱' target.播放音乐(music)&#125; 比如，window的软件不能再Linux中运行 内核内核主要在于管理硬件，提供合理的资源分配，比如CPU资源 内存使用资源等 程序管理 多任务环境 — 一部计算机可能同时有很多工作在等待CPU运算处理，内核需要控制这些工作，让CPU做有效分配 良好的CPU调度机制（CPU先让那个工作开始运行），可以加快整体系统性能 内存管理 控制系统的内存 系统所有的程序代码和数据都必须要先放在内存里 文件系统管理 比如数据输入输出 I/O 如果内核不认识某个文件系统，则无法使用此格式的文件 设备驱动 内存CPU读取的数据都来自与内存，不管是软件程序还是数据，都要先读入内存才可以被使用 个人计算机的内存为 内存容量也很重要，因为数据要先存入内存中 一般内存越大 系统越快，因为不用释放内存内部数据 硬盘存储数据，实际的数据是写在具有磁性物质的盘片上 linux vs unixchapter 1什么是Linux linux 就是一套操作系统 计算机由一堆硬件设备组成，操作系统用户管理控制这些硬件资源（内核） 不止如此，为了程序员可以更好的开发软件，操作系统还提供了一组系统调用接口 Linux 提供了一个完整的操作系统中，最底层的硬件控制和资源管理的完整架构，这个是沿用Unix而来的，相当稳定且强大 Linux distributionslinux 是操作系统最底层的内核以及其提供的内核管理工具，任何都可以获取源码并执行这个内核程序 随着Linux使用者逐渐增多，可以在Linux上运行的软件也越来越多，Linux + 各种软件 就可以是一个相当完整的操作系统 为了让用户可以接触到Linux，有人将 Linux 与可运行的软件集成起来，加上 一个可以让用户以光盘或者网络直接安装或者管理Linux系统，我们称这一整套 可完全安装的系统为 Linux distribution — 可完全安装套件 常见的几个 Linux distribution red hat - 红帽子 ubuntu – 无班图 centos Linux distribution 使用的都是 www.kernel.org 中提供的Linux内核，各家使用的软件大同小异，最大的差别在于软件的安装模式 查看当前是什么 distribution 1lsb_release -a chapter 3每一个组件或者设备在Linux下都是一个文件 磁盘主要有 盘片 机械手臂 主轴马达组成 分区最简单的分区： 区分根目录 \ 与内存交换空间 swap 即可 稍微麻烦一点：将一些读写频繁的重要目录，与根目录独立出来，比如 /, /usr, /var 等 chapter4### 内存交换空间是指？ 当有数据被存放在物理内存中，但是这些数据不是常被CPU所取用，那么这些不常被使用的程序将会被丢到硬盘的swap交换空间中，而将速度较快的物理内存空间释放出来给真正需要的程序使用 所以如果系统不忙，内存又打，就不需要swap了 chapter 5基础命令的格式1commond [option] 区分大小写 按下enter之后开始执行命令 一些简单的命令 命令 含义 date 获取日期 cal 获取日历 bc 进入计算器模式 cal 只是输入 cal 是展示当前月份的日历 123cal // 当前月份cal 2018 // 2018的所有月cal 8 2018 // 2018 8月 bc 进入计算器模式 输入 quit 然后回车 可以自动退出计算器模式 重要的按键 tab 命令补齐 和 文件名补齐 ctr + c 终止当前命令 Linux在线求助 man page比如想查看关于date 命令的一些信息 1man date 看下第一行这里是个 DATE(1) 这里的数字含义是 （这里列几个常见的） 数字 含义 1 用户在shell环境中可操作的命令或者更可执行的文件 4 设备文件 5 配置文件或者是某些文件的格式 8 系统管理员可用的管理命令 Linux在线求助 info page另外一种在线求助命令 info page 基础命令关机 shutdown 数据同步写入硬盘 sync 重启 reboot halt poweroff 数据在计算机中运行的模式: 所有的数据都得要被读入内存后才能够被CPU所处理，但是数据又常常需要由内存写回硬盘当中(例如储存的动作)。 由于硬盘的速度太慢(相对于内存来说)，如果常常让数据在内存与硬盘中来回写入/读出，系统的效能就不会太好 因此在Linux系统中，为了加快数据的读取速度，所以在默认的情况中， 某些已经加载内存中的数据将不会直接被写回硬盘，而是先缓存在内存当中，如此一来， 如果一个数据被你重复的改写，那么由于他尚未被写入硬盘中，因此可以直接由内存当中读取出来， 在速度上一定是快上相当多的！ 不过，如此一来也造成些许的困扰，那就是万一你的系统因为某些特殊情况造成不正常关机 (例如停电或者是不小心踢到power)时，由于数据尚未被写入硬盘当中，会造成数据不正常啦！ 那要怎么办呢？这个时候就需要sync这个命令来进行数据的写入动作啦！ 直接在文字接口下输入sync，那么在内存中尚未被升级的数据，就会被写入硬盘中！所以，这个命令在系统关机或重新启动之前，最好多运行几次 目前的 shutdown/reboot/halt 等等命令均已经在关机前进行了 sync 命令 chapter 6 文件权限与目录配置 三种身份文件所有者、用户组、其他人 系统中所有的帐号与一般身份使用者，以及root的相关信息， 都是记录在/etc/passwd文件中，每个人的密码则是记录在/etc/shadow文件中，此外，所有的组群名称记录在/etc/group文件中 用户 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统 用户组 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建 ls -al 查看当前目录下文件的信息ls 显示文件的文件名和相关属性 al 列出文件详细的权限的属性 12-rw-r--r-- 1 zhengzaijiazai staff 66 4 25 10:21 .gitignoredrwxr-xr-x 2 zhengzaijiazai staff 68 4 25 11:32 dist drwxr-xr-x d rwx r-x r-x 按照 1 3 3 3 的格式进行拆分 命令 含义 d 第一个字符 代表这个是目录 文件 或者 链接文件等 rwx 文件所有者的权限 r-x 文件同用户组的权限 r-x 其他非本用户的权限 r （read）可读 w （write） 可写 x （execute）可执行 文件权限的意义对于文件r 代表是否能查看文件的内容w 代表能否对文件的内容进行操作，但是不能删除文件x 代表能否被系统执行 对于目录目录的主要内容是记录文件名列表 r 表示可以读取目录结构列表 w 表示具有更改目录列表的权限 w权限对于文件的含义 创建新的文件与目录 删除文件和目录（不管文件权限） 将已存在的文件与目录重命名 移动文件，目录位置 总而言之，目录的w权限与该目录下的文件名变动有关系 x 表示用户能否进入目录 比如cd 进入此目录 test time有一个目录权限为 1drwxr--r-- 3 root root ....... 当前系统账号为 userA userA不属于root组 那么 userA 对于这个账户有什么权限， 能切换到此目录中吗 answer userA 具有 读的权限 而进行目录切换是需要X的权限 所以不可以切换到此目录 修改文件的属性、权限 命令 含义 chgrp xxx filename 改变文件所属用户组 chown xxx filename 改变文件所有者 chmod xxx filename 改变文件的权限 chgrp (change group)要改的那个组必须在 /etc/group 中存在 否则会报错 1chgrp read.md groupB chown (change owner)要改的那个用户必须在 /etc/passwd 中有记录 否则会报错 1chown read.md userB chownchmod 改变权限 使用分数 使用分数也可以代表权限 命令 分数 r 4 w 2 x 1 rwx 7rw- 6r-x 5 使用符号类型 有三种身份，就用 u g o 代表三种身份的权限 身份 字符 用户 u 用户组 g 其他人 o 所有身份 a 命令 含义 + 增加 - 减去 = 设置 比如 需要设置一个文件的权限为 -rwxr-xr-x 则u 为rwx g/o 为 r-x 1chmod u=rwx,go=rx readme.md 12// 如果是给每一身份增加 w 权限chmod a+w read.md 文件种类任何设备都是文件 使用 ls -l 中第一个字符就是文件种类 分类 普通文件文件 ls -al 所显示出来的属性方面，第一个字符为 [ - ]，例如 [-rwxrwxrwx ]。另外，依照文件的内容，又大略可以分为：纯文本 二进制文件 数据格式文件 目录 链接文件 比如： 快捷方式 设备与设备文件 文件扩展名与 window中的有很大不同 在Windows底下， 能被执行的文件扩展名通常是 .com .exe .bat等等，而在Linux底下，只要你的权限当中具有x的话，例如[ -rwx-r-xr-x ] 即代表这个文件可以被执行 通常我们还是会以适当的扩展名来表示该文件是什么种类的。底下有数种常用的扩展名： 1 .sh ： 脚本或批处理文件 (scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成 .sh ； 2 .Z, .tar, .zip ： 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名 3 .html, .php：网页相关文件，分别代表 HTML 语法与 PHP 语法的网页文件 基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行 例如虽然有一个文件为可执行文件， 如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时， 那么ls就变成不能执行 目录配置标准 FHS为什么每套Linux distributions他们的配置文件啊、执行文件啊、每个目录内放置的咚咚啊，其实都差不多？ 原来是有一套标准依据的 Linux来开发产品或distributions的社群/公司与个人实在太多了，如果每一个人都按照自己的标准去配置文件目录，可能有管理上的困扰 FHS 用于规范每个特定目录下应该要放置什么数据 FHS针对目录树定义了三个目录下应该放置什么数据 目录 含义 / (root 根目录) 与开机系统有关系 /usr 与软件的安装、执行有关系 /var 与系统运作过程有关系 usr （UNIX Software Resource）Unix操作系统软件资源 FHS 定义（/）根目录下需要有以下目录 目录 文件内容 /bin 执行文件，在/bin 下的命令 可以被root和一般账号使用,比如 cat cp等 /etc 系统主要配置文件，例如账号密码文件，何种服务的启示文件 /tmp 正在执行的程序放置文件的地方 FHS建议在开机时将 /tmp下的数据删除 /usr 是系统默认的软件安装目录 下面比较常见的目录 目录 文件内容 /bin 用户可使用的命令 /var 在系统安装之后，会慢慢占用硬盘容量 Q: 请问在 /bin 与 /usr/bin 有什么不同 A: /bin是系统的一些指令 bin为binary的简写主要放置一些系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等 /usr/bin 是你在后期安装的一些软件的运行脚本 主要放置一些应用软体工具的必备执行档例如c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等 绝对路径与相对路径 绝对路径 由根目录开始写起的文件名或者目录 相对路径 相对于当前路径 ~ 代表当前用户的家目录 或者 使用cd 回车 也可以进入 / 代表根目录 chapter 7 目录相关特殊的目录 标志 含义 . 本层目录 .. 上一层目录 - 前一个工作目录 Q: 请问在Linux的根目录，有没有上层目录 （..） 的存在 A: 用普通用户身份看下 用root身份看一下 操作文件与目录 命令 含义 cd 切换目录 change directory pwd 显示当前目录 mkdir 创建新目录 rmdir 删除空目录 cp 复制 mv 移动 重命名文件与目录 创建目录 mkdir mkdir 只能一层一层的创建目录， 如何一次性创建多层目录 – 借助 -p 参数 1mkdir -p webpack/w1-code/dist 删除目录 1rmdir config 只能删除一个空目录 如果要强制删除一个非空目录及它下面的全部 1rm -r node_modules 查看目录 1ls -a // 显示全部，连同隐藏的文件 mv 1234// 将某一个文件移动到文件夹中mv mian.js newdir// 重命名文件夹mv oldDir newdir cp 复制 复制文件需要有 r (可读) 权限 12// 复制index 文件到 当前位置cp ./config/index.js . 默认条件中，cp的源文件与目的文件权限不同，目的文件的所有者是命令操作者本身 查阅文件内容file 查询文件类型判断文件是二进制文件？数据文件? which查询命令所在的文件 1which ifconfig which 默认查找的是 PATH 内的目录 cat （Concatenate 连续） 命令 含义 cat 查看内容 cat -n 查看内容 显示行号 cat -b 查看内容 显示行号 【空白部分不算行号】 nl 添加行号打印nl 可以将输出的内容自动加上行号 默认结果与cat -n有点类似 nl [-bnw] filename -b 命令 含义 a 空行也添加行号 t 空行不添加行号 -n 命令 含义 ln 行号在左侧显示 rn 行号在右侧显示 不加0 rz 行号在右侧显示 加0 123nl index.jsnl -b a index.js 空行也添加行号 more前面提到的nl cat 是一次性将所有内容展示到命令行 more 则是 有翻页功能 1more index.js -n 命令 含义 空格 向下翻一页 enter 或者 向下键 向下滚动一行 q 退出显示 查找功能 按下 / 然后输入 要查找的字符 [但是没有发现有任何高亮提示] lessless 的用法要比more 增加了向上翻页功能 1less index.js 查找功能 按下 / 然后输入 要查找的字符 [向下查询]按下 ? 然后输入 要查找的字符 [向上查询] 选择数据 head tail head 从前面开始展示 选取数据展示几行 1head [-n number] filename number 表示展示几行 默认展示前10行 tail 从后面开始展示 1tail [-n number] filename number 表示展示几行 默认展示最后10行 获取第 100 到 120 行 1cat filename | head -n 120 | tail -n +100 从 100 行开始 显示 50行 1cat filename | tail -n +100 | head -n 50 tail -n +100：从100行开始显示，显示100行以后的 文件的权限预设 umask当新建一个文件时，它的默认权限和umask有关系 umask是用来指定当前用户在新建目录或文件时的权限预设值，具体来说，umask值只是一个掩码，它从创建文件时的默认权限中掩去对应位置的权限 0022 以数字形式表示权限 可以看到这里有四组权限，第一组是特殊权限使用的，我们平时只需要后面三个就可以了 u=rwx 以符号类型表示权限 在默认权限的属性，文件和目录是不同的 用户创建一般文件，则默认取消可执行权限，即666（rw-rw-rw-） 用户创建目录文件，由于x与是否可以进入此目录有关，因此默认开放所有权限，即777（rwxrwxrwx） Q: 假设用户的umask是 003 则当其新建一个文件或者文件夹 的权限是什么 A： 也就是去掉的权限是 other的 写 w 与 x 文件 rw-rw-r– 文件夹 rwxrxwr– 设置 umask 1umask 002 查询文件 find1find [指定路径] [指定条件] [指定动作] 默认会查找当前目录及子目录，把查找结果输出到屏幕上 touch关于文件的三个时间参数 modification time (mtime)： 当该文件的『内容数据』变更时，就会升级这个时间！内容数据指的是文件的内容，而不是文件的属性或权限 status time (ctime)：当该文件的『状态 (status)』改变时，就会升级这个时间，举例来说，像是权限与属性被更改了，都会升级这个时间 access time (atime)：当『该文件的内容被取用』时，就会升级这个读取时间 (access)。举例来说，我们使用 cat 去读取 /etc/man.config ， 就会升级该文件的 atime 在默认的情况下，ls 显示出来的是该文件的 mtime ，也就是这个文件的内容上次被更动的时间 1ls -l —time=ctime test.conf 权限和文件的关系 用户能进入某目录成为可工作目录的基本权限是什么 条件 内容 可使用命令 cd等切换工作目录 目录所需权限 x 要有可执行的权限 用户在某一个目录可以读取一个文件的基本权限是什么 条件 内容 可使用命令 cat more less tail head 等 目录所需权限 x 要有可执行的权限 文件所需权限 r 要有可读的权限 让用户修改一个文件的权限是什么 条件 内容 可使用命令 vi vim 等 目录所需权限 x 要有可执行的权限 文件所需权限 r w 要有可读可写的权限 让用户新建一个文件的基本权限是什么 条件 内容 可使用命令 touch 等 目录所需权限 w x 要有可读可执行的权限 $PATH为什么在任何地方都可以执行 ls 这个命令呢 – 环境变量 PATH 系统会依照PATH的设置去每个定义PATH的目录下查询文件名为ls的可执行文件，如果在PATH定义的目录中含有多个文件名为ls的可执行文件，那么先查询的同名命令则先被执行 1 ls 是一个可执行文件2 根源在 /bin/ls （也就是执行ls 与执行 /bin/ls 是同样的效果）3 问题变为，为什么随时可以执行 /bin/ls 这个文件4 系统按照 PATH 的设置每一个 path的定义目录下 查询名为ls的可执行文件5 先找到的被执行 不同身份的 默认的path 不同，默认能够随意运行的命令也不同(如root与vbird) PATH是可以修改的 chapter 8 磁盘和文件管理 EXT2Linux最传统的磁盘文件系统(filesystem)使用的是EXT2 磁盘分区指的是告诉操作系统 这个磁盘在此分割槽可以存取的区域是由 A 磁柱到 B 磁柱之间的区块 如此一来操作系统就能够知道他可以在所指定的区块内进行文件数据的读/写/搜寻等动作了。 也就是说，磁盘分区意即指定分割槽的启始与结束磁柱 文件系统磁盘在做分区之后还需要格式化，这是因为每种操作系统所配置的文件属性/权限并不相同， 为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的文件系统格式 文件系统的运行 这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外， 通常含有非常多的属性 例如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中 另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等 属性 含义 inode 记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 block 号码 block 实际记录文件的内容，若文件太大时，会占用多个 block superblock 记录此 filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等 inodeinode 的内容在记录文件的权限与相关属性，至于 block 区块则是在记录文件的实际内容 而文件系统一开始就将 inode 与 block 规划好了，除非重新格式化，否则 inode 与 block 固定后就不再变动 Ext2 文件系统在格式化的时候基本上是区分为多个区块群组 (block group) 的，每个区块群组都有独立的 inode/block/superblock 系统 blockdata block 是用来放置文件内容数据地方，在 Ext2 文件系统中所支持的 block 大小有 1K, 2K 及 4K 三种而已。在格式化时 block 的大小就固定了 1 原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)2 每个 block 内最多只能够放置一个文件的数据3 承上，如果文件大于 block 的大小，则一个文件会占用多个 block 数量4 承上，若文件小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费) Q: 假设你的Ext2文件系统使用 4KB de block ，而该文件系统中有 10000 个小文件，每个文件大小均为 50 bytes， 请问此时你的磁盘浪费多少容量？ A: 4kb = 4 * 1024 bytes = 4096 bytes 所以每一个会浪费 4096 - 50 bytes 所以公共会是 4046 * 10000 bytes = 38.585666 = 38.6MB 与目录树的关系 文件目录 当我们在 Linux 下的 ext2 文件系统创建一个目录时， ext2 会分配一个 inode 与至少一块 block 给该目录 其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码 而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据 文件 当我们在 Linux 下的 ext2 创建一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件 例如：假设我的一个 block 为 4 Kbytes ，而我要创建一个 100 KBytes 的文件，那么 linux 将分配一个 inode 与 25 个 block 来储存该文件 inode 本身并不记录文件名，文件名的记录是在目录的 block 当中。 因此在第六章文件与目录的权限说明中， 我们才会提到『新增/删除/更名文件名与目录的 w 权限有关』 因为文件名是记录在目录的 block 当中， 因此当我们要读取某个文件时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码， 最终才会读到正确的文件的 block 内的数据 文件系统的操作所有的数据都得要加载到内存后 CPU 才能够对该数据进行处理 想一想，如果你常常编辑一个好大的文件， 在编辑的过程中又频繁的要系统来写入到磁盘中，由于磁盘写入的速度要比内存慢很多， 因此你会常常耗在等待硬盘的写入/读取上 为了解决这个效率的问题, Linux 使用的方式是透过一个称为异步处理 (asynchronously) 的方式 当系统加载一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据会被配置为干净(clean)的。 但如果内存中的文件数据被更改过了(例如你用 nano 去编辑过这个文件)，此时该内存中的数据会被配置为脏的 (Dirty)。此时所有的动作都还在内存中运行，并没有写入到磁盘中！ 系统会不定时的将内存中配置为『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性 由于内存的速度要比硬盘快的多，因此如果能够将常用的文件放置到内存当中，这样就会大大提升系统性能 Linux 系统上面文件系统与内存有非常大的关系: 1 系统会将常用的文件数据放置到主存储器的缓冲区，以加速文件系统的读/写2 承上，因此 Linux 的物理内存最后都会被用光！这是正常的情况！可加速系统效能3 你可以手动使用 sync 来强迫内存中配置为 Dirty 的文件回写到磁盘中4 若正常关机时，关机命令会主动呼叫 sync 来将内存的数据回写入磁盘内5 不正常关机(如跳电、死机或其他不明原因)，由于数据尚未回写到磁盘内， 因此重新启动后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁(非磁盘损毁) 挂载文件系统与目录树的结合操作称之为挂载 挂载点一定是目录 这样才能使用文件系统 磁盘和目录容量磁盘的整体数据是在 superblock 区块中，但是每个各别文件的容量则在 inode 当中记载的 命令 含义 df 列出文件系统的整体磁盘使用量 du 评估文件系统的磁盘使用量(常用在推估目录所占容量) df 由于 df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在 Superblock 内的信息， 所以这个命令显示结果的速度非常的快速 du 与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据 在默认的情况下，容量的输出是以 KB 来设计的， 如果你想要知道目录占了多少 MB ，那么就使用 -m 这个参数即可 连接文件hard id_link新建一个文件名 链接到 某个inode 号码 symbolic linkSymbolic link 就是在创建一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的文件名 123456ln [-sf] 源文件 目标文件// 不添加参数就是 hard link// 添加参数 -s 就是 symbolic link// f 如果目标文件存在 则先删除后再创建 chapter 10 vim 编辑器vi 文本编辑器 vim 程序开发工具 vivi 共分为三种模式，分别是『一般模式』、『编辑模式』与『指令列命令模式』 一般模式以 vi 打开一个档案就直接进入一般模式了(这是默认的模式) 编辑模式一般模式当中, 按下『i, I, o, O, a, A, r, R』等任何一个字母之后会进入编辑模式 指令列命令模式一般模式当中，输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一行 chapter 11 bash shell需要计算机输出音乐,这个过程需要什么支持呢 1 硬件 需要你的硬件有声卡芯片 2 内核管理 需要操作系统的内核可以支持这个芯片组 还有芯片的驱动程序 3 应用程序 需要用户输入播放声音的指令 以上三点是一个简单的输出声音的步骤。就是用户需要输出一个命令，硬件才会执行这个命令来工作。而硬件如何知道你所执行的命令呢，那就是内核的控制工作了 我们需要通过shell将输入的命令与内核进行通信，这样内核就可以控制硬件来工作 操作系统是一组软件，这组软件在控制硬件与管理系统的活动监测。如果这组软件能被用户随意操作会导致系统崩溃。 所以不能让用户随意去使用。因此产生了一种在操作系统上的应用程序-&gt;shell 其实shell的功能只是提供用户操作系统的一个接口，因此这个shell需要可以调用其他软件。 简而言之，只要能够操作应用程序的接口，都叫做shell Linux的shellLinux有多种shell， 可以看下 /etc/shells 各家的shell功能差不多，但是在某些语法执行方面不同。 Linux默认使用的是 bash 为什么我们系统上合法的 shell 要写入 /etc/shells 这个文件啊？ 这是因为系统某些服务在运行过程中，会去检查使用者能够使用的 shells ，而这些 shell 的查询就是藉由 /etc/shells 这个文件 我这个使用者什么时候可以取得 shell 来工作呢？还有， 我这个使用者默认会取得哪一个 shell ? 当我登陆的时候，系统就会给我一个 shell 让我来工作了。 而这个登陆取得的 shell 就记录在 /etc/passwd 这个文件内 bashbash 的几个优点 1 命令记忆功能 『上下键』可以追溯命令 ~/.bash_history 记录的是前一次登陆以前所运行过的命令， 而至于这一次登陆所运行的命令都被缓存在内存中，当你成功的注销系统后，该命令记忆才会记录到 .bash_history 当中 2 命令与文件补全功能 tab 键 3 命名别名设置功能 查询 alias 设置 alias lm=‘ls -al’ 4 作业控制，前台，后台控制 5 程序脚本 当登录到Linux后，会依据/etc/passwd 文件的设置来给一个shell（默认bash） 然后就可以依据上面的命令操作 shell type内部命令：由 bash 内置的命令 外部命令：来字外部的命令，非 bash 内置 查询一个命令是外部的还是bash内置的呢？ – type 可以看到 cd 这个命令是bash的内置命令 shell 的变量功能Linux是多用户，多任务的环境，每个人在登录之后都会有一个bash。 显示当前使用的shell，可以输入： echo $SHELL 影响bash环境变量的操作 那么由于在 Linux System 下面，所有的线程都是需要一个运行码， 『真正以 shell 来跟 Linux 沟通，是在正确的登陆 Linux 之后』这个时候你就有一个 bash 的运行程序，也才可以真正的经由 bash 来跟系统沟通 而在进入 shell 之前，也正如同上面提到的，由于系统需要一些变量来提供他数据的存取 (或者是一些环境的配置参数值， 例如是否要显示彩色等等的) ，所以就有一些所谓的『环境变量』 需要来读入系统中了！这些环境变量例如 PATH、HOME、MAIL、SHELL 等等 读取变量变量在显示的时候，前面必须带着 $ 符号 123echo $PATHecho $&#123;PATH&#125;cd $work 设置变量1workdir=&apos;workapce/mxx&apos; 变量的设置规则 变量名称只能是字母与数字，但开头不能为数字 双引号内的特殊字符可以保留原特性，比如$ 可正确读取字符串中的变量，单引号则不会 1234567name=&quot;my name is $USER&quot;echo $name// mu name is tom&lt;!-- 如果是单引号 --&gt;name=&apos;my name is $USER&apos;echo $name// mu name is $USER 取消变量1unset workdir Q: 设置一个 变量代表 工作目录 在父进程中定义的变量是无法在子进程中使用的，比如你定义了这个变量，然后再重新发开一个进程，是读不到这个变量的 不过通过export将此变量设置为环境变量就可以使用了 比如，定义变量 TRYPATH=/HOME/EORK 写一个脚本 1echo $TRYPATH, 123 然后在当前进程中执行 sh test.sh 控制台无输出 如果 export TRYPATH=/HOME/EORK 就有信息输出了 环境变量的功能查询当前有哪些环境变量，可以使用两个命令 env export env查询到目前shell环境下所有的环境变量 setshell不只是有环境变量，还有各种自定义的变量 set查询所有的变量 export环境变量和自定义变量两者的差异在于 是否可以被子进程使用 子进程会继承父级进程的环境变量，不会继承父进程的自定义变量 export 可以将自定义变量转为环境变量 123export// export WORKDIR=$WORKDIR:workspace/blued-shopping/blued-shop 可以看到目前所有的环境变量 父进程？子进程？当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，被称为 PID 的就是。 接下来你在这个 bash 底下所下达的任何命令都是由这个 bash 所衍生出来的，那些被下达的命令就被称为子程序了。 为什么子进程可以使用环境变量 1 当创建一个shell时候，操作系统会分配一个记忆块给shell使用，此内存的变量可以给子进程使用 2 在父进程使用了 export ，就可以将自定义的变量写到上面的那个记忆块中 3 当加载另一个shell的时候（启动子进程，要离开父进程了）子shell可以将父shell的那个记忆块导入自己的环境变量块中 ulimitLinux 主机里面同时登陆了十个人，这十个人不知怎么搞的， 同时开启了 100 个文件，每个文件的大小约 10MBytes ， 请问一下， 我的 Linux 主机的内存要有多大才够？ 1010010 = 10000 MBytes = 10GBytes … 内存占用量很大，所以可以限制这个大小 bash 可以限制用户的某些系统资源，比如文件打开数量，可用的CPU时间，可用内存总量等 ，这些通过 ulimit 进行设置 参数解析 含义 unlimited 无限制 0 无限制 history查看历史命令 123historyhistory 10history -w // 写入 ~./bash_history 历史命令的读取与记录是这样的： 以 bash 登陆 Linux 主机之后，系统会主动的由家目录的 ~/.bash_history 读取以前曾经下过的命令，那么 ~/.bash_history 会记录几笔数据呢？这就与你 bash 的 HISTFILESIZE 这个变量配置值有关了！ 假设我这次登陆主机后，共下达过 100 次命令，『等我注销时， 系统就会将 101~1100 这总共 1000 笔历史命令升级到 ~/.bash_history 当中。』 也就是说，历史命令在我注销时，会将最近的 HISTFILESIZE 笔记录到我的纪录文件当中啦！ 当然，也可以用 history -w 强制立刻写入的！那为何用『升级』两个字呢？ 因为 ~/.bash_history 记录的笔数永远都是 HISTFILESIZE 那么多，旧的信息会被主动的拿掉！ 仅保留最新的！ bash的操作环境路径和命令的查找顺序在我们系统中存在多个名字相同的名字，那么 bash shell 究竟使用的是哪个命令呢？其遵循的顺序如下 1．以相对/绝对路径来执行命令2．由 alias 找到命令来执行3．由 bash 内置命令来执行4．通过$PATH 的顺序找到的第一个命令来执行 12345[root@localhost ~]# alias echo=&apos;echo -n&apos;[root@localhost ~]# type -a echoecho is aliased to `echo -n&apos;echo is a shell builtinecho is /bin/echo 可以看到先找alias在内置命令 最后PATH bash的登录信息 这些都可以进行配置的 shell 的配置文件怎么我们什么动作都没有进行，但是一进入 bash 就取得一堆有用的变量了？ 这是因为系统有一些环境配置文件案的存在，让 bash 在启动时直接读取这些配置文件，以规划好 bash 的操作环境 这些配置文件又可以分为全体系统的配置文件以及用户个人偏好配置文件。 我们前几个小节谈到的命令别名啦、自定义的变量啦，在你注销 bash 后就会失效，所以你想要保留你的配置， 就得要将这些配置写入配置文件才行。 Bash 配置文件 以 login shell 方式 1 /etc/profile 系统最主要的shell配置文件，每次login，bash都要读取 /etc/profile文件 PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统命令目录；MAIL：依据账号配置好使用者的 mailbox 到 /var/spool/mail/账号名；USER：根据用户的账号配置此一变量内容；HOSTNAME：依据主机的 hostname 命令决定此一变量内容；HISTSIZE：历史命令记录数 2 个人配置文件 bash 在读完了整体环境配置的 /etc/profile 以及其他配置文件后，接下来则是会读取使用者的个人配置文件 其实 bash 的 login shell 配置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。 如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是： ~/.bash_profile~/.bash_login~/.profile ~/.bash_profile 是个人的bash配置文件，存在每位用户的$HOME ~/.bash_login 用户登陆时 bash会读取这个文件。通常把登陆就要执行的指令放在这 以 non-login shell 方式 ~/.bashrc 每次打开shell，shell都会读取的文件。每次打开shell,执行一次 其余的配置文件为 4 ~/.bash_logout 是退出系统时ｂａｓｈ在退出时执行的 5 ～/.bash_history 是历史功能的记录文件 数据流重定向 数据流重定向 就是把某些要出现在屏幕上的数据传输到其他地方 数据流输入数据流：以写文件为例，从键盘输入的字符就输入数据流 输出数据流：以读文件为例，将文件内容显示到屏幕上，显示的内容就是输出字符流 输出数据流又可分为：标准输出 标准错误输出 标准输入 &lt; 或者 &lt;&lt; 标准输出 &gt; 或者 &gt;&gt; 标准错误输出 2&gt; 或者 2&gt;&gt; （ 一个&lt; 表示覆盖 二个&lt;&lt; 表示进行追加 ） 1echo config.js &gt; copy.js 本应该出现在屏幕上的所有的config的信息 会被 导入到copy.js文件 这个copy文件的创建方式为 1 该文件若不存在，系统会自动的将他创建起来 2 当这个文件存在的时候，那么系统就会先将这个文件内容清空，然后再将数据写入 也就是若以 &gt; 输出到一个已存在的文件中，那个文件就会被覆盖掉 如果不想被覆盖，而是继续追加信息，使用 &gt;&gt; 命令行中的判断 &amp;&amp; ||1ls tmp/info &amp;&amp; touch tmp/info/a 管道bash 命令运行的时候有输出的数据会出现！ 那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来配置？ grep uniq 去重 wc 统计 chapter 13 shell script就是在 shell 上运行的 script 脚本 开发以 #!/bin/bash 开头 用以声明文件内语法使用bash语法 条件判断 123if [ 条件判断式 ]; then 当条件判断式成立时，可以进行的命令工作内容；fi &lt;==将 if 反过来写，就成为 fi 啦！结束 if 之意！ 如何运行sh base.shbash base.sh/bin/bash base.sh/bin/sh base.sh source x.sh source 可以回传变量 123456789101112131415// 定义变量 export 到全局export TRYPATH='trypath'// 定义 test.sh 内容为 // echo $TRYPATH// TRYPATH='changepath'sh test.sh // -&gt; trypathecho $TRYPATH // -&gt; trypath// 使用source执行source test.sh // trypathecho $TRYPATH // -&gt; changepath 也就是 source 可以修改父进程的变量 chapter 14 账号管理与权限设置 账号与用户组登陆 Linux 主机的时候，输入的是我们的账号, ID 与账号的对应就在 /etc/passwd 当中 每个登陆的使用者至少都会取得两个 ID ，一个是使用者 ID (User ID ，简称 UID)、一个是群组 ID (Group ID ，简称 GID) 文件如何判别他的拥有者与群组 每一个文件都会有所谓的拥有者 ID 与拥有群组 ID ，当我们有要显示文件属性的需求时，系统会依据 /etc/passwd 与 /etc/group 的内容， 找到 UID / GID 对应的账号与组名再显示出来 在输入账号和密码登录shell时候 系统会发生什么 1 先找寻 /etc/passwd 里面是否有你输入的账号 如果没有则跳出，如果有的话则将该账号对应的 UID 与 GID (在 /etc/group 中) 读出来，另外，该账号的主文件夹与 shell 配置也一并读出 2 再来则是核对密码表啦！ 这时 Linux 会进入 /etc/shadow 里面找出对应的账号与 UID，然后核对一下你刚刚输入的密码与里头的密码是否相符 3 如果一切都 OK 的话，就进入 Shell 控管的阶段 /etc/passwd每一行都代表一个账号，有几行就代表有几个账号在你的系统中 按照 : 分为 7个部分 [用户名]：[密码]：[UID]：[GID]：[身份描述]：[主目录]：[登录shell] /etc/shadow我们知道很多程序的运行都与权限有关，而权限与 UID/GID 有关！因此各程序当然需要读取 /etc/passwd 来了解不同账号的权限。 因此 /etc/passwd 的权限需配置为 -rw-r–r– 这样的情况， 虽然早期的密码也有加密过，但却放置到 /etc/passwd 的第二个字段上！这样一来很容易被有心人士所窃取的， 加密过的密码也能够透过暴力破解法去 try and error (试误) 找出来 因为这样的关系，所以后来发展出将密码移动到 /etc/shadow 这个文件分隔开来的技术 1testuser:!!:17854:0:99999:7::: [账号名称] [密码] [最近更动密码的日期] [密码不可被更动的天数] [密码需要重新变更的天数] [密码需要变更期限前的警告天数] [密码过期后的账号宽限时间(密码失效日)] [账号失效日期] [保留] [密码] 经过编码的密码 (加密) 只会看到有一些特殊符号的字母 [最近更动密码的日期] 是以 1970 年 1 月 1 日作为 1 而累加的日期，1971 年 1 月 1 日则为 366 /etc/group记录GID 和用户组组名对应 这个文件每一行代表一个群组 它总共分四个部分：[组名]：[密码域]：[GID]：[组员列表] 看下这三者的关系 有效用户组(effective group)与初始用户组(initial group)每个使用者在他的 /etc/passwd 里面的第四栏有所谓的 GID，就是『初始群组 (initial group) 』。也就是说，当用户一登陆系统，立刻就拥有这个群组的相关权限 但是一个用户可以被加入到多个用户组去，比如 USERA 可以同时属于 group1 （初始用户组） 与 group2 （手动添加） 那么当这个用户在新建一个文件的时候，新文件所属组是哪一个 这个取决于当时的有效用户组 查询当前用户所属的用户组 1groups 第一个输出的群组即为 有效用户组 (effective group) 了 以这个用户身份去新建一个文件，则文件的用户组就是这个 有效用户组 有效群组的切换1newgrp newGrooup 但是使用newgrp 是有限制的，那就是你想要切换的群组必须是你已经有支持的群组，也就是说，只要我的用户有支持的群组就是能够切换成为有效群组 账号管理用户相关123456// 新增一个用户usersadd newName// 删除一个用户userdel newName CentOS 系统主要会帮我们处理几个项目 1 在 /etc/passwd 里面创建一行与账号相关的数据，包括创建 UID/GID/家目录等 2 在 /etc/shadow 里面将此账号的密码相关参数填入，但是尚未有密码 3 在 /etc/group 里面加入一个与账号名称一模一样的组名 4 在 /home 底下创建一个与账号同名的目录作为用户家目录，且权限为 700 此时在 /etc/shadow 内仅会有密码参数而不会有加密过的密码数据，因此还需要使用『 passwd 账号 』来给予密码才算是完成了用户创建的流程 1passwd g1 为何『 useradd vbird1 』会主动在 /home/vbird1 创建起用户的家目录？家目录内有什么数据且来自哪里？为何默认使用的是 /bin/bash 这个 shell ？为何密码字段已经都规范好了 (0:99999:7 那一串)？ —- 取决于 useradd 所使用的参考文件 12345678 useradd -D// GROUP=100 &lt;==默认的群组// HOME=/home &lt;==默认的家目录所在目录// INACTIVE=-1 &lt;==密码失效日，在 shadow 内的第 7 栏// EXPIRE= &lt;==账号失效日，在 shadow 内的第 8 栏// SHELL=/bin/bash &lt;==默认的 shell// SKEL=/etc/skel &lt;==用户家目录的内容数据参考目录// CREATE_MAIL_SPOOL=yes &lt;==是否主动帮使用者创建邮件信箱(mailbox) 用户组相关1234567891011121314// 新增一个用户组groupadd newName// 删除一个用户组 r 表示连同用户主文件夹一起删除groupdel -r newName // 将用户加入到组和从组中删除gpasswd –a 用户名 组名 //添加用户gpasswd –d 用户名 组名 //删除用户// 查看用户属于某组#groups 用户名// 新建用户加入某组useradd –g 某组名 用户 用户组管理员设置将 g3 设置为 girls 组的管理员， 管理员可以控制 那些账号可以 移入 移除 用户组 1gpasswd -A g3 girls 设置用户密码当忘记了密码怎么办 普通用户 root管理员处理 1passwd usertest root 忘记密码 安全模式？？ 太复杂了 关于处理密码 1echo 123456 | passwd --stdin testuser2 直接变更密码，不需要重复确认 关闭/打开 某一个用户密码 1234// 使用户密码失效passwd -S xxx// 使用户密码解锁passwd -u xxx 用户的身份切换 su su 需要新用户的密码 （如果原来的是root 切换到哪一个都不需要密码 ） 原本的变量不会改变, 比如PATH变量 mail 变量 还会是之前用户的 12// 使用 - 可以处理这个问题su - 1exit 退出 第二个 用户状态 恢复到原始用户环境 sudo sudo 切换需要自己的密码，有时候还不需要 sudo 可以让你以其他用户的身份运行命令 (通常是使用 root 的身份来运行命令), 只有在 /etc/sudoers 中的用户 才可以执行此命令 将用户添加到 /etc/sudoers 1visudo 添加角色 用户功能 id 查询某人或者自己的uid/gid等信息 1234id// uid=1006(g1) gid=1007(girls) 组=1007(girls)id g2// uid=1007(g2) gid=1007(girls) 组=1007(girls) w / who 当前谁登陆在系统上 chapter16 例行性工作 crontab 什么是例行性工作？可以理解为node中的定时任务（node-schedule） 有两种任务性质，周期性，一次性 周期性: 比如每天要睡觉 一次性: 比如偶尔会捡到钱 at 命令用于处理 一次性 的工作 crontab 命令用于处理周期性的工作，循环工作 Linux常见的例行性工作调度 日志文件的轮替 临时文件的删除 某些软件在运行中会产生一些缓存文件，但是当这个软件关闭时，这些缓存文件可能并不会主动的被移除。 系统透过例行性工作排程运行名为 tmpwatch 的命令来删除这些缓存文件 at 一次性的工作调度atd 用于负责处理 这些一次的工作，但是并非所有的 Linux distributions 都默认会把他打开的 1/etc/init.d/atd restart 使用 at 这个命令来产生所要运行的工作，并将这个工作以文字档的方式写入 /var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与运行了 /etc/at.allow 与 /etc/at.deny这两个文件限制了谁有权利去调用 at 1 /etc/at.allow 写在这个文件中的使用者才能使用 at ，没有在这个文件中的使用者则不能使用 at (即使没有写在 at.deny 当中) 2 如果 /etc/at.allow 不存在，就寻找 /etc/at.deny 这个文件 凡是被写入的都不能使用at了（没有被写的就可以使用） 3 如果两个文件都不存在，那么只有 root 可以使用 at 这个命令 查询当前机器中有多少 at 的工作调度 1atq 删除某一个工作调度 1atrm [jobnumber] batchbatch 就是另一种 at, 但是batch会在 CPU 工作负载 低于 0.8 的时候，才进行你所下达的工作任务 CPU 工作负载 如果某一个程序他需要一直使用 CPU 的运算功能，那么此时 CPU 的使用率可能到达 100% 但是 CPU 的工作负载则是趋近1，因为 CPU 仅负责一个工作 如果同时运行2个这样的程序 CPU 的使用率还是 100% ，但是工作负载则变成 2 crontab用户的设置crontab 用来处理周期性的工作，为了安全考虑，可以限制哪些身份是可以使用 crontab /etc/cron.allow /etc/cron.deny 当使用者使用 crontab 这个命令来创建工作排程之后，该项工作就会被纪录到 /var/spool/cron/ 里面, 而且是以帐号来作为判别 比如 dmtsai 使用 crontab 后， 他的工作会被记录到 /var/spool/cron/dmtsai 里头去 默认情况下，只要用户没有被放入 /etc/cron.deny 就可以直接执行 crontab -e 去编辑自己的例行性命令了 时间位置是五个数字 * 分别代表 分钟 小时 日期 月份 周几 编写 1crontab -e 我们写一个每一分钟输出当前时间的 1*/1 * * * * echo $(date) &gt; /tmp/test.txt 查看当前用的 crontab 工作 1crontab -l 重启 1/bin/systemctl start crond.service 系统层级的crontabcrontab -e 是对于用户的，如果是系统的例行性任务，就需要另外处理了 需要编辑 /etc/crontab 这个文件了 cron 这个服务的最低侦测限制是『分钟』，所以『 cron 会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容 』，因此，只要编辑完 /etc/crontab 这个文件，并且将他储存之后，那么 cron 的配置就自动运行 手动重启crond服务 1/etc/init.d/crond restart MAILTO 当 /etc/crontab 这个文件中的例行性工作的命令发生错误时，或者是该工作的运行结果有 STDOUT/STDERR 时，会将错误信息或者是萤幕显示的信息传给谁(默认是由系统直接寄发一封 mail 给 root) PATH 命令路径 anacron 唤醒停机期间的工作任务anacron 并不能指定何时运行某项任务， 而是以天为单位或者是在启动后立刻进行 anacron 的动作，他会去侦测停机期间应该进行但是并没有进行的 crontab 任务，并将该任务运行一遍后，anacron 就会自动停止了 anacron 会以一天、七天、一个月为期去侦测系统未进行的 crontab 任务 anacron 运行的时间通常有两个，一个是系统启动期间运行，一个是写入 crontab 的排程中。 这样才能够在特定时间分析系统未进行的 crontab 工作 chapter17 程序管理17.1 进程 程序触发任何一个事件时，系统都会将其定义为一个进程，并给与此进程一个ID，为PID. 同时依据启发这个程序的使用者与相关属性关系，给予这个 PID 一组有效的权限配置 程序一般是放置在实体磁碟中，然后透过使用者的运行来触发。触发后会加载到内存中成为一个个体，那就是进程。 为了操作系统可管理这个程序，因此程序有给予运行者的权限/属性等参数，并包括程序所需要的命令码与数据或文件数据等， 最后再给予一个 PID 。系统就是透过这个 PID 来判断该 process 是否具有权限进行工作 程序 系统需要启动的那个二进制的文件 通常为二进制程序放置在存储媒介中，以物理文件形式存在 进程 程序触发之后，被加载到内存中成为一个个体，这就是进程 程序被触发后，执行者的权限与属性，程序的程序代码与所需数据会被加载到内存，操作系统会给与这个内存单元一个标识符PID 子程序与父程序 程序彼此之间是有相关性的。以上面的图示来看，连续运行两个 bash 后，第二个 bash 的父程序就是前一个 bash 常驻进程某些命令产生的进程很快就会被终止，比如ls显示文件 touch 创建文件等。但是有些进程会一直在执行，比如系统每一分钟会去扫描 /etc/crontab 来进行工作调度， 是 crond 这个程序所管理的，他启动后就在后台一直持续不断的运行。 这个就是一直存在内存中的进程 常驻在内存当中的程序通常都是负责一些系统所提供的功能以服务使用者各项任务，因此这些常驻程序就会被我们称为：服务 (daemon)。系统的服务非常的多， 不过主要大致分成系统本身所需要的服务，例如刚刚提到的 crond 及 atd 网络服务会启动一个可以负责网络监听的端口 (port) ，以提供外部用户端 (client) 的连线要求 Linux 的多人多工环境Q: 为什么 Linux 这么多用户，但是却每个用户都可以拥有自己的环境？ 其实在 Linux 下运行一个命令时，系统会将相关的权限、属性、程序码与数据等均加载内存， 并给予这个单元一个程序识别码 (PID)，最终该命令可以进行的任务则与这个 PID 的权限有关 1234567891011121314151617181920// 文件目录const dir = &#123;&#125;// 一些内存const Memory = &#123;&#125;function linux1 () &#123; // 用户1登录的环境 function crontab()&#123;...&#125; function pm2()&#123;...&#125;&#125;function linux2 () &#123; // 用户2 登录的环境 function crontab()&#123;...&#125; function pm2()&#123;...&#125;&#125; 多任务行为 Linux 可以让CPU在各个工作进行切换，也就是说，每一个工作仅仅占用CPU几个命令次数，所以CPU每秒能够在各个进程之间进行切换 目前的 CPU 速度可高达几个 GHz。 这代表 CPU 每秒钟可以运行 109 这么多次命令。Linux 可以让 CPU 在各个工作间进行切换， 也就是说，其实每个工作都仅占去 CPU 的几个命令次数，所以 CPU 每秒就能够在各个程序之间进行切换 特殊的程序管理行为 Linux可以在任何时候， 将某个被困住的程序杀掉，然后再重新运行该程序而不用重新启动 bash 环境下的工作管理 (job control) 登陆 bash 之后， 就是取得一个名为 bash 的 PID 了，而在这个环境底下所运行的其他命令， 就几乎都是子进程了 在这个单一的 bash 界面下，可以处理多个工作 工作管理 job control 当登录系统取得 bash shell 之后，在单一终端机界面下同时进行多个工作的行为管理 可以出现提示字节让你操作的环境就称为前景 (foreground)，其他工作就可以让你放入背景 (background) 去暂停或运行 直接将命令丢到后台中『运行』的 &amp; 比如启动一个项目 1node index.js 这个就是一直在前台启动，我们可以将这个放在后台处理 1node index.js &amp; 添加的这个 &amp; 会将命令放到后台处理，此时bash会输出一个 工作号码 1 和 PID 90328 查询目前在后台的工作 1jobs 参数 含义 l 除了列出 job number 与命令串之外，同时列出 PID 的号码 r 仅列出正在背景 run 的工作 s 仅列出正在背景当中暂停 (stop) 的工作 可以看到有一个 + - 号展示 代表最近被放到背景的工作号码 - 代表最近最后第二个被放置到背景中的工作号码 而超过最后第三个以后的工作，就不会有 +/- 符号存在了 后台工作拿到前台处理 fg (foreground) 123fg // 默认将 + 的工作取出来fg- // 取出来 - 的工作fg %工作号码 // 取出来这个工作号码的对应工作 管理工作 kill 1kill -signal %jobnumber signal参数 含义 1 重新读取一次参数的配置档 (类似 reload) 2 代表与由键盘输入 [ctrl]-c 同样的动作 9 立刻强制删除一个工作 15 以正常的程序方式终止一项工作。与 -9 是不一样的 进程管理为什么需要进程管理 1 Linux 系统是个很忙碌的系统，那么当整个系统资源快要被使用光时， 您是否能够找出最耗系统的那个程序，然后删除该程序，让系统恢复正常呢 2 此外，如果由於某个程序写的不好，导致产生一个有问题的程序在内存当中，您又该如何找出他，然后将他移除呢？ 3 如果同时有五六项工作在您的系统当中运行，但其中有一项工作才是最重要的， 该如何让那一项重要的工作被最优先运行呢 查看进程 ps 命令 含义 ps -l 查询只和自己bash相关的进程 ps aux 当前内存所有进程 ps 是静态的结果输出 是某一个时间点的进程状态 top top 可以监测整个系统的进程工作状态 1top [-d 数字] | top [-bnp] -d 后面可以接秒数，默认是 5 秒, 表示每次更新进程资源的时间 在 top 运行过程当中可以使用的按键命令 ? ：显示在 top 当中可以输入的按键命令P ：以 CPU 的使用资源排序显示M ：以 Memory 内存 的使用资源排序显示 (默认)N ：以 PID 来排序T ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序k ：给予某个 PID 一个讯号 (signal)r ：给予某个 PID 重新制订一个 nice 值q ：离开 top 软件的按键 如何查找最消耗CPU的进程 使用 top 然后 按P 进程管理其实是透过给予该程序一个信号 (signal) 去告知该程序如何操作 查询所有的可用的singal 1kill -l 常用的一些 信号 数值 名称 含义 1 SIGHUP 启动被终止的程序，可让该 PID 重新读取自己的配置档，类似重新启动 killall -singal 命令名称 根据进程名称删除此进程 比如我们通过 node index.js &amp; 启动这个服务到后台 那么删除就可以是 killall -9 node 要删除某个程序，我们可以使用 PID 或者是启动该程序的命令名称， 而如果要删除某个服务呢？呵呵！最简单的方法就是利用 killall ， 因为他可以将系统当中所有以某个命令名称启动的程序全部删除。 进程的优先级Linux 给予程序一个所谓的『优先运行序 (priority, PRI)』， 这个 PRI 值越低代表越优先的意思 之前我们查看一个进程 ps -l 可以看到 PRI 这个参数 PRI 是内核动态调整的，使用者无权去干涉 PRI 想要调整程序的优先运行序时，就得要透过 Nice 值了！Nice 值就是上表的 NI 一般来说， PRI 与 NI 的相关性如下： PRI(new) = PRI(old) + nice 但是，如果原本的 PRI 是 50 ，并不是我们给予一个 nice = 5 ，就会让 PRI 变成 55 。 因为 PRI 是系统『动态』决定的，所以，虽然 nice 值是可以影响 PRI ，不过， 最终的 PRI 仍是要经过系统分析后才会决定的。 另外， nice 值是有正负的，而既然 PRI 越小越早被运行， 所以，当 nice 值为负值时，那么该程序就会降低 PRI 值，亦即会变的较优先被处理 nice 新执行的命令处理nice nice [-n 数字] command 1nice -n 5 vi 数字范围在 -20 - 19 renice 已经存在的进程nice重新调整 线程查看系统资源free 查看内存占用free [-b|-k|-m|-g] [-t] 选项与参数 -b ：直接输入 free 时，显示的单位是 Kbytes，我们可以使用 b(bytes), m(Mbytes) k(Kbytes), 及 g(Gbytes) 来显示单位 -t ：在输出的最终结果，显示实体内存与 swap 的总量 Mem 那一行显示的是实体内存的量， Swap 则是虚拟内存的量。 total 是总量， used 是已被使用的量， free 则是剩余可用的量。 后面的 shared/buffers/cached 则是在已被使用的量当中，用来作为缓冲及缓存的量。 Linux 测试用主机是很平凡的，根本没有什么工作， 但是实体内存是几乎被用光 不过，至少有 132MB 用在缓冲记忆 (buffers) 工作， 287MB 则用在缓存 (cached) 工作，也就是说，系统是『很有效率的将所有的内存用光』， 目的是为了让系统的存取效能加速 很多朋友都会问到这个问题『我的系统明明很轻松，为何内存会被用光光？』被用光是正常的！而需要注意的反而是 swap 的量 一般来说， swap 最好不要被使用，尤其 swap 最好不要被使用超过 20% 以上， 如果您发现 swap 的用量超过 20% ，那么，最好还是买实体内存 系统会使用到 swap ， 绝对是因为实体内存不足了才会这样做的 Linux 系统为了要加速系统效能，所以会将最常使用到的或者是最近使用到的文件数据缓存 (cache) 下来， 这样未来系统要使用该文件时，就直接由内存中搜寻取出，而不需要重新读取硬盘，速度上面当然就加快了！ 因此，实体内存被用光是正常的 uname：查阅系统与核心相关资讯uptime：观察系统启动时间与工作负载netstart1netstart -tlnp 特殊文件和程序chapter 18 系统服务 系统为了某些功能必须要提供一些服务 (不论是系统本身还是网络方面)，这个服务就称为 service 但是 service 的总是需要程序的运行吧！达成这个 service 的程序我们就称呼他为 daemon 举例来说，达成循环型例行性工作排程服务 (service) 的程序为 crond 这个 daemon chapter23 软件安装Linux 开发商先在固定的硬件平台与操作系统平台上面将需要安装或升级的软件编译好， 然后将这个软件的所有相关文件打包成为一个特殊格式的文件，在这个软件文件内还包含了预先侦测系统与相依软件的脚本， 并提供记载该软件提供的所有文件资讯等。最终将这个软件文件发布。 用户端取得这个文件后，只要透过特定的命令来安装， 那么该软件文件就会依照内部的脚本来侦测相依的前驱软件是否存在，若安装的环境符合需求，那就会开始安装， 安装完成后还会将该软件的资讯写入软件管理机制中，以达成未来可以进行升级、移除等动作 目前Linux常用的两大安装方式为 dpkg rpm 不论 dpkg/rpm 这些机制或多或少都会有软件属性相依的问题，那该如何解决呢？ 其实前面不是谈到过每个软件文件都有提供相依属性的检查吗？那么如果我们将相依属性的数据做成列表， 等到实际软件安装时，若发生有相依属性的软件状况时，管理机制自动去取得其依赖来同时安装， 就解决了属性相依的问题 目前新的 Linux 开发商都有提供这样的『线上升级』机制，透过这个机制， 原版光盘就只有第一次安装时需要用到而已，其他时候只要有网络，你就能够取得原本开发商所提供的任何软件了 CentOS 系统嘛！所以说：使用的软件管理机制为 RPM 机制，而用来作为线上升级的方式则为 yum rpmRPM是RedHat Package Manager（RedHat软件包管理工具）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，现在包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。 最大的特点就是将你要安装的软件先编译过， 并且打包成为 RPM 机制的包装文件，透过包装好的软件里头默认的数据库记录， 记录这个软件要安装的时候必须具备的相依属性软件，当安装在你的 Linux 主机时， RPM 会先依照软件里头的数据查询 Linux 主机的相依属性软件是否满足， 若满足则予以安装，若不满足则不予安装。那么安装的时候就将该软件的资讯整个写入 RPM 的数据库中，以便未来的查询、验证与反安装！这样一来的优点是： 由於已经编译完成并且打包完毕，所以软件传输与安装上很方便 (不需要再重新编译)；由於软件的资讯都已经记录在 Linux 主机的数据库上，很方便查询、升级与反安装 缺点 由於 RPM 文件是已经包装好的数据，也就是说， 里面的数据已经都『编译完成』了！所以，该软件文件几乎只能安装在原本默认的硬件与操作系统版本中。 也就是说，你的主机系统环境必须要与当初创建这个软件文件的主机环境相同才行 有的时候相同 distribution 的不同版本之间也无法互通，例如 CentOS 4.x 的 RPM 文件就无法直接套用在 CentOS 5.x ！因此，这样可以发现这些软件管理机制的问题是： 软件文件安装的环境必须与打包时的环境需求一致或相当；需要满足软件的相依属性需求；反安装时需要特别小心，最底层的软件不可先移除，否则可能造成整个系统的问题！ RPM 相关操作 查询rpm包 （1）查询系统中安装的所有rpm包 #rpm –qa（2）查询软件包是否安装 #rpm –q 软件包名称（3）查询软件包信息 #rpm –qi 软件包名称（4）查询软件包中的文件 #rpm –ql 软件包名称（5）查询系统中文件所属的软件包#rpm –qf 文件全路径名（6）查询rpm包文件中的信息#rpm –qp rpm包文件全路径 安装rpm包 rpm –ivh rpm包全路径文件名 删除rpm包 rpm –e rpm包名称 升级rpm包 rpm –U rpm软件包全路径名 网络相关基本的网络配置 1、主机名2、ip地址3、网关地址4、DNS服务器地址 DNS DNS客户配置文件 /etc/resolv.conf 该文件中指定系统所使用的DNS服务器的IP地址 网络相关命令 12345// 显示当前系统的主机名称hostname// 设置系统主机名hostname 主机名称 ping Ping [–c 发出的报文数 ]目的主机地址Ping命令通过向被测试的目的主机地址发送ICMP报文并收取回应报文，来测试当前主机到目的主机的网络连接状态 nslookup用于使用系统设定的DNS服务器解析域名，用该命令可以测试NDS服务器是否工作正常Nslookup命令有交互方式查询和命令行方式查询 12#nslookup#nslookup 主机域名 | ip地址 12nslookupwww.webmxx.com]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack系列之-原理篇]]></title>
    <url>%2F2018%2F05%2F02%2Fwebpack%E7%B3%BB%E5%88%97%E4%B9%8B-%E5%8E%9F%E7%90%86%E7%AF%87%2F</url>
    <content type="text"><![CDATA[本系列将会从原理、开发、优化、对比四个方面给大家介绍webpack的工作流程。【默认是以webpack v3为例子】 储备知识CommonJS 规范12345// 模块引入let moduleA = require(&apos;./a.js)// 模块导出module.exports = () =&gt; &#123;&#125; es6规范1234567// 模块引入let &#123;moduleA&#125; from &apos;./a.js&apos;// 模块导出export default () =&gt; &#123;&#125; 黑盒体验我们可以把webpack看做一个黑盒，只要会用就可以。先来体验一次很简单的webpack打包过程 12345678910const webpack = require('webpack')const path = require('path')module.exports = &#123; entry: './index.js', output: &#123; filename: 'index.js', path: path.resolve(__dirname, 'public') &#125;&#125; 启动编译，在命令行输入 node_modules/.bin/webpack 就可看到一次打包过程 查看打包结果 关于如何启动webpack如果是全局安装了webpack，可以在命令行直接输入 webpack 如果只是项目文件夹安装，需要输入 node_modules/.bin/webpack npx 在 npmV5版本 会赠送一个npx npx 会自动查找当前依赖包中的可执行文件，如果找不到，就会去 PATH 里找。如果依然找不到，就会帮你安装 所以也可以通过npx执行webpack 1npx webpack require方法实现一个require方法 common.js的规范中 引入一个模块需要 1let getA = require(&apos;./a&apos;) 自己写一个require方法 123456789101112131415161718let fs = require('fs')// 查找modulefunction myReq (myModule) &#123; // 读取文件信息 let cont = fs.readFileSync(myModule, 'utf-8') /* function (exports, require, module, __filename, __dirname) &#123; moduel.exports = &#123;a: 'apple'&#125; return moduel.exports &#125; */ let nodeFn = new Function('exports', 'require', 'module', '__filename', '__dirname', cont + 'return module.exports') let module = &#123; exports: &#123;&#125; &#125; return nodeFn(module.exports, myReq, module, __filename, __dirname)&#125;// let getA = require('./a')let getA = myReq('./a.js')console.log(getA, 'getA') 思路：读取文件内容，根据node的封装规范，传入几个必须的参数即可。 删减 webpack 编译后的文件 把刚刚打包之后的 dist/index.js 删减掉一些不用的代码 12345678910111213141516(function(modules) &#123; function myRequire(moduleId) &#123; var module = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, myRequire); // call 用于让 modules[moduleId] 函数执行 执行的是传入后面的参数 return module.exports; &#125; return myRequire(/* 下面的第一个函数参数 */);&#125;)([ (function(module, exports) &#123; console.log('123') &#125;)]); 在线查看 可以看出来， webpack打包生成之后的文件内容就和编译的require方法类似。这就是为什么打包之后的js文件可直接在浏览器中运行的原因 编译流程常见名词解释 参数 说明 entry 项目入口 module 开发中每一个文件都可以看做module chunk 代码块 loader 模块转化器 plugin 扩展插件 自定义webpack打包过程 bundle 最终打包完成的文件 打包流程webpack的运行流程是一个串行的过程，从启动到结束，会依次执行以下流程 参数初始化 从配置文件 【webpack.config.js】和 shell 语句中读取与合并参数 开始编译 初始化一个compiler对象 加载所有插件 执行对象的run方法开始编译 确定入口文件 根据配置文件找到项目所有的入口文件 编译模块 从入口开始 调用配置的loader对模块进行编译 【有一个递归寻找依赖模块的流程】 模块编译完成后 得到模块被转化后的最后内容以及他们之间的依赖关系 资源输出 根据入口文件和模块之间的依赖关系 组成chunk文件 【一个chunk可能包含多个模块】每一个chunk将会被转化成一个单独的文件加入输出列表中 输出 根据配置的输出参数 【路径和文件名】将输出内容写入文件系统 在以上的过程 WP会在特定的时间点广播特定的事件 插件在监听到感兴趣的事件后会执行特定的逻辑 简化流程其实以上流程可以简化为三个阶段 源码分析核心库 tapable在node中有一个事件发射器 EventEmitter ，可以进行事件监听与发射。 12345678var EventEmitter = require('events').EventEmitter;var event = new EventEmitter();event.on('some_event', function () &#123; console.log('some_event 事件触发');&#125;);setTimeout(function () &#123; event.emit('some_event');&#125;, 1000); webpack核心库 tapable 的原理和 EventEmitter 类似，通过事件的注册和监听，触发各个编译周期中的函数方法.Tapable 还允许你通过回调函数的参数，访问事件的“触发者(emittee)”或“提供者(producer)” 查看在线代码 核心对象 compilercompiler 继承自 tapable 可以进行事件的广播和监听 compiler 进行事件的广播和监听的方式为 12345678// 广播事件 params 为附带参数compiler.apply('event-name', params)// 监听 名为 event-name 的事件compiler.plugin('event-name', function (params) &#123;&#125;) 查看177行代码 webpack 在初始化的时候 会将 compiler对象传入到plugin中 可以使用它来访问 webpack 的主环境 查看45行代码 compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。 核心对象 compilationwebpack系列之-原理篇compilation 继承自 tapable 可以进行事件的广播和监听 查看57行代码 compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。 一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息 打包模板webpack打包的每一个chunk都是根据模板而生成的。webpack内部提供了很多模板文件。 当webpack分析完所有的Module并准备输出chunk的时候 会分析每一个chunk找对其所对应的template 从而生成最后我们看到的文件格式 plugin 实现机制作用原理在webpack的编译流程，每一个阶段都会广播不同的事件，比如 run, done 等事件。plugin会监听到这些事件，一旦事件发生，就会执行注册好的函数方法 plugin分析每一个plugin都是 一个具有 apply 属性的 JavaScript 对象 12345678910111213class MPlugin &#123; // 这里获取用户为插件传入的配置参数 constructor (options) &#123; &#125; // webpack 会调用 MPlugin 实例的apply方法 为插件实例传入 compiler 对象 apply (compiler) &#123; compiler.plugin(&apos;compilation&apos;, function (compilation) &#123; // 回调函数中 传入了 compilation 对象 &#125;) &#125;&#125; 在webpack初始化的阶段 会往plugin中传递compiler对象 查看45行代码 编写plugin12345678910111213141516171819class StartWp &#123; constructor(options) &#123; this.options = options &#125; apply(compiler) &#123; let &#123;name&#125; = this.options // 监听事件 这是异步的 所以要执行cb 不然会卡到这里不动了 compiler.plugin('run', function (compilation, cb) &#123; console.log('run', name) // 每一次重新编译的时候又会触发 // compilation.plugin('') cb(); &#125;) compiler.plugin('done', function (compilation) &#123; console.log('done', name) &#125;) &#125;&#125;module.exports = StartWp 传递给插件的compiler和compilation是相同的 也就是某一个插件有修改对象的话会影响后面的插件的使用 有的事件是异步的，所以在使用的时候，要执行 cb() 去通知webpack 本次事件监听结束了 要往下继续执行否则会卡到这里 如何使用此插件 12345plugins: [ new StartWp(&#123; name: 'v3 - plugin ' &#125;)] 自己来写一个简易版本的webpack打包器实现原理: 根据打包的模板格式 读取文件信息并输入到指定的位置 借助ejs 将简化的webpack打包结果拿出来作为 字符串模板 最简易的webpack123456789101112131415161718192021222324252627282930313233const fs = require('fs')// 入口文件let input = './index.js'// 输出地址let output = './dist/index.js'const ejs = require('ejs')const getIntry = fs.readFileSync(input, 'utf-8')let template = `(function(modules) &#123; function __webpack_require__(moduleId) &#123; var module = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); return module.exports; &#125; return __webpack_require__(0);&#125;)([ (function(module, exports) &#123; &lt;%- getIntry %&gt; &#125;)])`let result = ejs.render(template, &#123; getIntry&#125;)// 将结果输出到 dist fs.writeFileSync(output, result) 在命令行执行一次 node webpack.0.1.0.js 执行之后的编译结果 可以看到在dist目录有index.js生成 将其引入 html页面 这样就完成了一个非常非常简单的webpack 在线查看简单的webpack 加入 require 处理如果入口文件中 有使用到 require 则需要将其替换为webpack提供的 webpack_require 先看一下如果有使用 require 之后的打包之后的结果 bundle.js 12345678910111213141516171819 (function(modules) &#123; function __webpack_require__(moduleId) &#123; var module = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); return module.exports; &#125; return __webpack_require__(0); &#125;) ([ (function(module, exports, __webpack_require__) &#123; __webpack_require__(1) console.log('index.js') &#125;), (function(module, exports) &#123; console.log(123) &#125;)]); 查看在线代码 我们使用这个模板来重新编写一个简易的webpack 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const fs = require('fs')const path = require('path')// 入口文件let input = './index.js'// 输出地址let output = './dist/index.js'const ejs = require('ejs')const getIntry = fs.readFileSync(input, 'utf-8')// 将getIntry 中的 require 进行处理// require('./a.js')const contAry = []let dealIntry = getIntry.replace(/(require)\(['"](.+?)['"]\)/g, ($1, $2, $3, $4) =&gt; &#123; // console.log($1, $2, $3, $4) // let filePath = path.join(__resolve, $2) let cont = fs.readFileSync($3, 'utf-8') // console.log(cont) contAry.push(cont) return $2 = `__webpack_require__($&#123;contAry.length&#125;)`&#125;)// console.log(contAry)let template = `(function(modules) &#123; function __webpack_require__(moduleId) &#123; var module = &#123; exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); return module.exports; &#125; return __webpack_require__(0); &#125;) ([ (function(module, exports, __webpack_require__) &#123; &lt;%- dealIntry %&gt; &#125;), &lt;% for(var i=0;i &lt; contAry.length; i++)&#123; %&gt; (function(module, exports) &#123; &lt;%- contAry[i] %&gt; &#125;), &lt;%&#125;%&gt;])`let result = ejs.render(template, &#123; dealIntry, contAry&#125;)// 将结果输出到 distfs.writeFileSync(output, result) 在命令行执行一次 node webpack.1.0.0.js 执行之后的编译结果 在线查看加入require功能的webpack 源码篇提问 在自己构建的plugin中 是否可以进行事件广播 可以。只要能拿到 compiler或者compilation对象 就可以广播事件，为其他插件监听使用]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步流程处理]]></title>
    <url>%2F2018%2F03%2F17%2F%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[promisepromise 可以说是很常用的异步处理方法 比如我们使用promise封装一个canvas截图的方法 123456789101112clip (resolve, reject) &#123; // 截屏 获取图片url return new Promise((resolve, reject) =&gt; &#123; html2canvas(document.getElementById(&apos;view&apos;), &#123; canvas: canvas, onrendered: (canvas) =&gt; &#123; let getImg = canvas.toDataURL(&apos;image/png&apos;) resolve(getImg) &#125; &#125;) &#125;) &#125; 实现一个简单的promise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function Promise (executor) &#123; let self = this self.status = &apos;pending&apos; self.success // 成功的原因 self.failure // 失败的原因 // 事件池 self.resolvePool = [] self.rejectPool = [] function resolve (data) &#123; if (self.status == &apos;rejected&apos;) return self.status = &apos;resolved&apos; self.success = data // 执行队列 self.resolvePool.forEach(function (cb)&#123; cb(self.success) &#125;) &#125; function reject (data) &#123; if (self.status == &apos;resolved&apos;) return self.status = &apos;rejected&apos; self.failure = data // 执行队列 self.rejectPool.forEach(function (cb)&#123; cb(self.failure) &#125;) &#125; // new一个实例就会立即执行这个promise executor(resolve, reject)&#125;// thenPromise.prototype.then = function (onFulfilled, onRejected) &#123; let self = this let promiseStatus = self.status if (promiseStatus == &apos;resolved&apos;) &#123; onFulfilled(self.success) &#125; if (promiseStatus == &apos;rejected&apos;) &#123; onRejected(self.failure) &#125; // 很有可能此时状态为 pending if (promiseStatus == &apos;pending&apos;) &#123; // 放入事件池中等待执行 self.resolvePool.push(function () &#123; onFulfilled(self.success) &#125;) self.rejectPool.push(function () &#123; onRejected(self.failure) &#125;) &#125;&#125; Iterator1234let target = beIteraor(&#123;name: &apos;mxx&apos;, address: &apos;beijing&apos;&#125;) target.next()target.next() Iterator 是一个迭代器对象 每次从集合中取出一项 并且跟踪当前序列所在位置 通过使用next方法 返回一个包含value和done两个属性的对象 1&#123;value: 当前对象成员, done: Boolean&#125; Iterator 简易实现 1234567891011121314151617181920212223let target = beIteraor([&apos;mxx&apos;, &apos;beijing&apos;])let a = target.next() let b = target.next()let c = target.next()// &#123; value: &apos;mxx&apos;, done: false &#125; &#123; value: &apos;beijing&apos;, done: false &#125; &#123; value: &apos;undefined&apos;, done: true &#125;// 返回一个具有next方法的对象function beIteraor(ary) &#123; let index = 0 let len = ary.length return &#123; next: function () &#123; // 调用next方法 返回 &#123;value, done&#125; 并且指针移动位置 let done = ~~index == ~~len // 如果指针位置移动到末尾 则返回undefined 否则返回当前位置成员 let value = done ? &apos;undefined&apos; : ary[index] index++ return &#123;value, done&#125; &#125; &#125;&#125; generator generator 函数生成一个迭代器 12345678910111213&lt;!-- 函数 注： 这里的read函数直接返回文件中内容 --&gt;function * getCont () &#123; let name = yield &apos;youchangjing&apos; let address = yield &apos;beijing&apos; return name + address&#125;&lt;!-- 如何执行 --&gt;let getC = getCont()getC.next() // &#123;value: &apos;youchangjing&apos;, done: false&#125;getC.next() // &#123;value: &apos;beijing&apos; , done: false&#125;getC.next() // &#123;value: undefined , done: true&#125; 可以看到 generator 函数调用和普通函数一样 fn() 即可 但是函数并不会执行 只有当调用next方法 才能执行到第一个状态 generator 是分段执行的 yield表示暂停执行 next方法恢复函数执行 目前来说 浏览器对 generator 支持情况还是很不错的 co如果 yield 后面是一个 promise 函数 可以配合co 库来使用 123456789101112131415161718192021222324&lt;!-- read函数 -- 封装的一个简易的promise --&gt;function read(dir) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(dir, &apos;utf-8&apos;, (err, cont) =&gt; &#123; if (err) reject(err) resolve(cont) &#125;) &#125;)&#125;&lt;!-- generator --&gt;function * getCont () &#123; let name = yield read(&apos;name.js&apos;) let address = yield read(&apos;address.js&apos;) return name + address&#125;&lt;!-- 配合co库 --&gt;co(getCont()).then(function (cont) &#123; console.log(cont) &#125;) 简单的CO实现原理 co 的参数是一个迭代器 co 返回的是promise 返回的promise 接受 generator 函数的 value co 内部可以使 generator 函数 一直执行到 done 为TRUE 12345678910111213141516171819function co(iterator) &#123; return new Promise(function (resolve, reject) &#123; function next(cont) &#123; let &#123;value, done&#125; = iterator.next(cont) &lt;!-- value 也是一个promise --&gt; if (done) &#123; &lt;!-- 如果 done 为TRUE 则将value 传入 resolve --&gt; resolve(value) &#125; else &#123; &lt;!-- done 为FALSE 则执行其then 方法 用于获取其data传递给 next --&gt; value.then(function (data) &#123; next(data) &lt;!-- next 递归 --&gt; &#125;, reject) &#125; &#125; next() &#125;)&#125; async awaitasync await 可以看做 co + generator 的语法糖 虽然co库可以帮我们自行处理generator 但是又要使用yield 又要封装promise 也是有点麻烦 所以转向 ES7 中的 async await 目前 async await 在Bable, Node 7+ 中被支持 1234567async function getCont() &#123; let people = await read(&apos;./file.js&apos;) let who = await read(&apos;./who.js&apos;) return people + who&#125;getCont().then((data) =&gt; console.log(data)) async 返回 promise awaitawait 顾名思义 等待。那他在等待什么呢。 这个取决于await 后面跟着的内容 12345await &apos;mxx&apos;&lt;!-- 等待非promise --&gt;await IamPromise()&lt;!-- 等待 promise --&gt; 如果 await 等待的不是一个 promise 那么await表达式的运算结果就是 它等到的东西 （其实await会将其转为一个立即resolve的promise对象） 如果 await 等待的是promise 那么他会阻塞后面的代码 等着Promise 对象 resolve 然后得到其值作为 await表达式的运算结果 123456789101112function getRank () &#123; return 12345&#125;async function getType () &#123; let name = await read(&apos;who.js&apos;) &lt;!-- read为promise --&gt; console.log(name) let rank = await getRank() &lt;!-- getRank 为普通函数 --&gt; console.log(rank)&#125; 如果我们在普通函数中使用await会被阻塞吗 好吧~~ 直接报错了 错误捕获async 中有两种错误处理方式 1 可以在 async 函数中 使用try catch async 中对try catch方法做了处理 使其可以捕获异步的错误 12345678async function () &#123; try &#123; &#125; catch (e) &#123; console.log(e) &#125;&#125; 2 在then中进行错误捕获 1getCont().then().catch((e) =&gt; console.log(e)) 如果async函数中使用了try catch 那么后面的then方法将会进入成功态 【相当于promise返回的是 undefined 】 相关资料 bluebird promise A+ Tterator async await]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[requestAnimationFrame]]></title>
    <url>%2F2018%2F02%2F19%2FrequestAnimationFrame%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 在项目中有使用到定时器去实现动画效果 但是会有卡顿问题 这是因为如果使用window.setTimout()或者window.setInterval()不断更新元素的状态位置等来实现动画 就要求画面的更新频率要达到每秒60次才能让肉眼看到流畅的动画效果 window还有一个方法requestAnimationFrame 是用来处理这种问题 window.requestAnimationFrame() 将告知浏览器你马上要开始动画效果了，后者需要在下次动画前调用相应方法来更新画面 这个方法就是传递给window.requestAnimationFrame()的回调函数 浏览器可以优化并行的动画动作，更合理的重新排列动作序列，并把能够合并的动作放在一个渲染周期内完成，从而呈现出更流畅的动画效果 比如，通过requestAnimationFrame()，JS动画能够和CSS动画/变换或SVG SMIL动画同步发生。 另外，如果在一个浏览器标签页里运行一个动画，当这个标签页不可见时，浏览器会暂停它，这会减少CPU，内存的压力，节省电池电量 使用如果我们使用定时器来创建动画 是这么写的 12345function render()&#123; //动画 setTimeout(render, 1000/60); // 一般浏览器是每秒60帧&#125;render() 定时器的问题是 如果浏览器不是每秒60帧，会造成掉帧 还有，在性能方面，大部分在浏览器在标签页/窗口处于的时候非激活状态（如窗口最小化或标签页切换了）时，setTimeout/setInterval 还会执行 这个有人做过具体的对比 请参见文章《对比时间测试》 标签页闲置时，时间间隔： 那么采用 requestAnimationFrame 则是 12345function render()&#123; // 动画 requestAnimationFrame(render)&#125;render() 参数解析 接收一个函数作为回调，返回一个ID值 1requestAnimationFrame(callback) //callback为回调函数 这个ID值传给window.cancelAnimationFrame()可以取消该次动画 Other有人封装了一个raf的模块 可以之间引入使用 click me]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>练习</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-7编译原理]]></title>
    <url>%2F2018%2F02%2F03%2Fwebpack-7%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[在webpack的构建流程中，功能通过发布订阅事件来触发各个插件的执行，]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API文档工具]]></title>
    <url>%2F2018%2F01%2F27%2FAPI%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[有点项目是和同事一起开发的 前后端分离的时候 比较需要注意的就是API文档 今天找了一份API文档生成工具 apidoc官网 CN官网 使用注意点 在package.json中添加相应参数 “description”: “apiDoc basic example”, “apidoc”: { “title”: “Custom apiDoc browser title”, “url” : “https://api.github.com/v1&quot; // 这个是你的项目URL路径 } 代码中注释的书写格式api.doc是根据特定的代码书写格式来生成API文档的 注意在js中注释是这种格式的 1234567891011/** * @api &#123;get&#125; /user/:id Request User information * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; id Users unique ID. * * @apiSuccess &#123;String&#125; firstname Firstname of the User. * @apiSuccess &#123;String&#125; lastname Lastname of the User. */ @apiSampleRequest http://localhost:8000/getLyric?queen 这个将会在页面嵌入一个类似nodemon发送请求 的功能 非常棒 文档生成命令1apidoc -f 'index.js' -i routes/ -o apidoc/ 缺点无法开启文档更新监控功能 每一次修改需要重新执行命令]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>apidoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发送请求的第三方插件]]></title>
    <url>%2F2018%2F01%2F21%2F%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[requestrequest npm urlliburllib github axiosaxios 可同时应用与前端与server端 Axios 中文说明]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack-6配置问题]]></title>
    <url>%2F2018%2F01%2F21%2Fwebpack-6%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[大问题webpack-dev-server1 入口文件与引入的静态文件不在一个目录怎么办 2 入口文件不是index.js 小参数问题]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划8]]></title>
    <url>%2F2018%2F01%2F21%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%928%2F</url>
    <content type="text"><![CDATA[work 抽奖活动优化程序 准备上线 三期娃娃机需求测试反馈 life 运营活动提出来 加入window.onError错误事件捕获]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划7]]></title>
    <url>%2F2018%2F01%2F14%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%927%2F</url>
    <content type="text"><![CDATA[work H5接入微信支付功能 腊八节提测 娃娃机排行榜转为redis处理 life 运营活动提出来 加入window.onError错误事件捕获]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何进行项目调试]]></title>
    <url>%2F2018%2F01%2F06%2F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[由于我们处理的项目主要是适配移动端 所以如何进行页面调试 是一个很重要的问题 以下方式为Mac 未尝试window系统如何使用 页面调试 iphone &amp;&amp; safari 将你的手机用数据线连接到Mac中 打开Safari浏览器 选择开发选项 可以看待自己的移动设备名称 你的移动设备需要在端外浏览器中打开页面才可以进行调试 比如查看控制台的log信息等 Android &amp;&amp; Chrome 移动设备要开启开发者选项 同样通过数据线将移动设备与Mac连接 然后在Chrome中打开控制台 点击右侧三个按钮 出现以上部分 点击remote devices 就可以看到你的移动设备页面了 参见文章远程调试Android设备 抓取接口信息 Charles抓取PC端接口当打开Charles的代理 会发现 所有的网络请求 都会出现在左侧列表 参考文章Charles使用 抓取移动设备使移动设备与PC端设备处于同一局域网的网络 Charles 打开Charles的代理设置：Proxy-&gt;Proxy Settings，设置一下端口号，默认的是8888，这个只要不和其他程序的冲突即可,并且勾选Enable transparent HTTP proxying 处理移动设备 在WiFi管理的地方 点击代理 选择手动 然后输入Charles的信息 主机就是电脑IP 当出现这个提示框的时候 提示是否允许这么做 otherchrome 链接设备出现空白页面参见文章 使用chrome remote debug时打开inspect时出现一片空白]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hi,2018]]></title>
    <url>%2F2018%2F01%2F01%2Fhi-2018%2F</url>
    <content type="text"><![CDATA[早上并没有睡到自然醒，客厅里爱如潮水的歌声作为2018年的旋律不断刺激耳朵，心情happy。 hi，2018。再见，2017。 新公司其实入职公司的过程真的是机缘巧合，记得当时和同学说，刚刚接到电话要我去面试。然后是在百度搜了一下BLUED，emmm.. 就感觉很酷。就像二次元与三次元的重叠。 那天关上浏览器的时候，画面停留的是一场在国外的婚礼上两个人交换戒指的场面，然后我对我同学说，好想去这个公司啊。公司文化一定很好。 特别奇妙的是，面试的时候发现公司的发源地原来是在秦皇岛，嗯~ 好酷~ 工作书到用时方恨少。这是在工作里最大的体会。 工作里遇到很多大神级别人物，感觉他们很厉害。 在面对问题时候的解决方式，对待工作的态度，如何平衡工作和生活，很多很多地方需要学习。 年底的时候，开始逐渐承担项目组的一些工作，有压力~ 目前还在适应阶段，有一点紧张。 在不断摸索如何平稳走过这个过渡期。 Blog从16年开始写博客 从CDSN 到 使用云空间 然后迁移的GitHub.io 最大的变化是在不断提升每一篇博客的质量 从最开始的比较多的记录性文章 到现在大多数的实践性文章 也算是一个小提高吧 生活接连两三次在地铁里出现心跳加速 呼吸困难的情况之后，(这里真的是字面意思，不是形容见到桌面那种感觉) 我去健身房报名了。感谢遇到负责的教练，不断督促我去锻炼。 目前的体重保持在96，我希望可以变胖一丢丢，长一点肌肉。 关于二次元，感觉17年在这个里面投入的时间精力有点多，不只是物质上的付出，还有精神上的。（现在想想，为了桌面熬夜到两点真的是不可理喻） 关于感情 emm~ 参不透 2018年 目标1 GitHub 中followers变为两位数 2 搞懂webpack！！！ 3 搞一个服务器给自己的网站 4 关于习惯的养成 开始有意识的创建周计划 方便处理工作以及生活安排 5 个人博客的阅读笔记部分目前比重不多 要注意多多看技术文章 在这个方面努力一点]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>love</tag>
        <tag>告别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webapck-5]]></title>
    <url>%2F2017%2F12%2F30%2Fwebpack-5%2F</url>
    <content type="text"><![CDATA[hash 与 chunkhashhash 指打包文件的hash值 chunkhash：每个chunk的hash值，你可以理解为版本号或则md5值，主要是保证每个文件的唯一性。 测试中发现 hash 有的时候代码不变动 保存的时候 也会新增 index.hash文件 chunkhash 只有当变动代码的时候 才会新生成文件 并且如果配置的是多个入口 这时候选择 chunkhash 比较合理 也就是输出的时候 会有两个js文件 两个入口文件会生成两个js编译脚本，如果配置中使用的是 hash 1234567891011module.exports = &#123; entry: &#123; index: './index.js', main: './main.js' &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'public') &#125;, watch: true&#125; 在public中查看打包完后会生成两个hash值文件 然后现在对其中的一个文件进行修改，（这里开启了watch模式） 可以直接看到 没有改动的那个js文件 也被重新编译了 而且会发现 index 和 Main 后面的hash是一样的 如果我们这里使用的是 chunkhash 1234output: &#123; filename: '[name].[chunkhash:4].js', path: path.resolve(__dirname, 'public')&#125; 当修改其中一个文件的时候 只会对修改的文件进行重新编译 看官方文档的解释 [hash] is replaced by the hash of the compilation.[chunkhash] is replaced by the hash of the chunk hash 代表的是compilation的hash值 而 chunkhash 是根据模块内容计算出的hash值 compilationcompilation对象代表某个版本的资源对应的编译进程。 当使用Webpack的development中间件时，每次检测到项目文件有改动就会创建一个compilation，进而能够针对改动生产全新的编译文件。compilation对象包含当前模块资源、待编译文件、有改动的文件和监听依赖的所有信息。 所以 只要文件有改动，compilation就会被重新创建 从而导致了哈希值变动 并且hash值是由compilation对象计算所得，而不是具体的项目文件计算所得，因此index 与 main 会具有相同的hash chunkFilename 与 CommonsChunkPluginchunkFilename异步加载 1234require.ensure(['./two.js'], function(require) &#123; console.log('那花草香')&#125;, 'tips'); 当你的js文件中异步加载模块的时候 会把异步的文件编译的 chunkFilename.js 的文件中 按需加载的文件编译之后 Externals 外部扩展项目中 我们使用第三方的库的时候 一般都是用过 import 导入 如果现在有一个第三方文件 并没有发布在npm中 那么除了在页面中直接通过 script 标签引入 还可以使用 import这种方式 这时候就需要在webpack中添加external配置项 1234567module.exports = &#123; ... external: &#123; otherSdk: 'game_user' &#125; ...&#125; 防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖 也就是说 通过externals 配置的文件 将不会被编译到bundle中 而是直接从第三方提供的link链接去获取资源 还可以将其挂载在window中 main.js 123window.smile = (name) =&gt; &#123; console.log(`hi, $&#123;name&#125;`)&#125; 然后随便将其传入到在线网址 那么我们在项目中 如何通过URL的方式 引入这个文件呢 参考文章 Webpack中hash与chunkhash的区别，以及js与css的hash指纹解耦方案]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack阅读笔记]]></title>
    <url>%2F2017%2F12%2F24%2Fwebpack%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[output配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。 Loader 特性loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照先后顺序进行编译。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。 模块解析(Module Resolution)enhanced-resolve 可以解析三种规则 相对路径 绝对路径 模块路径 指向一个文件 指向一个文件夹 解析规则 缓存每个文件系统访问都被缓存，以便更快触发对同一文件的多个并行或串行请求。 在观察模式下，只有修改过的文件会从缓存中摘出。如果关闭观察模式，在每次编译前清理缓存。(Watch 模式默认关闭) 依赖图webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些入口起点开始，webpack 递归地构建一个依赖图，【 这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle 】 - 通常只有一个 - 可由浏览器加载。 Targets ？webpack.config.js 123module.exports = &#123; target: 'node'&#125; 在上面例子中，使用 node webpack 会编译为用于「类 Node.js」环境（使用 Node.js 的 require ，而不是使用任意内置模块（如 fs 或 path）来加载 chunk）。 runtime 和 manifest runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。 manifest 通过使用 bundle 计算出内容散列(content hash)作为文件名称，这样在内容或文件修改时，浏览器中将通过新的内容散列指向新的文件，从而使缓存无效。一旦你开始这样做，你会立即注意到一些有趣的行为。 即使表面上某些内容没有修改，计算出的哈希还是会改变。这是因为，runtime 和 manifest 的注入在每次构建都会发生变化 长效缓存错综复杂之处 你可能会感兴趣，webpack及其插件似乎“知道”应该哪些文件生成。答案是，通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪 HotModuleReplacementPlugin (hmr)让我们从一些不同的角度观察，以了解 HMR 的工作原理…… 在应用程序中通过以下步骤，可以做到在应用程序中置换(swap in and out)模块： 1 应用程序代码要求 HMR runtime 检查更新。2 HMR runtime（异步）下载更新，然后通知应用程序代码。3 应用程序代码要求 HMR runtime 应用更新。4 HMR runtime（异步）应用更新。 你可以设置 HMR，[ 以使此进程自动触发更新 ]，或者你可以选择要求在用户交互时进行更新 在编译器中除了普通资源，编译器(compiler)需要发出 “update”，以允许更新之前的版本到新的版本。”update” 由两部分组成： 1 更新后的 manifest(JSON)2 一个或多个更新后的 chunk (JavaScript) manifest 包括新的编译 hash 和所有的待更新 chunk 目录。每个更新 chunk 都含有对应于此 chunk 的全部更新模块（或一个 flag 用于表明此模块要被移除）的代码。 编译器确保模块 ID 和 chunk ID 在这些构建之间保持一致。通常将这些 ID 存储在内存中（例如，使用 webpack-dev-server 时），但是也可能将它们存储在一个 JSON 文件中。 在模块中HMR 是可选功能，【 只会影响包含 HMR 代码的模块 】。 举个例子，通过 style-loader 为 style 样式追加补丁。 为了运行追加补丁，style-loader 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。 类似的，当在一个模块中实现了 HMR 接口，你可以描述出当模块被更新后发生了什么。 然而在多数情况下，不需要强制在每个模块中写入 HMR 代码。如果一个模块没有 HMR 处理函数，更新就会冒泡。这意味着一个简单的处理函数能够对整个 模块树 ？？？ (complete module tree)进行更新。如果在这个模块树中，一个单独的模块被更新，那么整组依赖模块都会被重新加载。 在 HMR Runtime 中 ？？？对于模块系统的 runtime，附加的代码被发送到 parents 和 children 跟踪模块。在管理方面，runtime 支持两个方法 check 和 apply。 check 发送 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，待更新 chunk 会和当前加载过的 chunk 进行比较。对每个加载过的 chunk，会下载相对应的待更新 chunk。当所有待更新 chunk 完成下载，就会准备切换到 ready 状态。 apply 方法将所有被更新模块标记为无效。对于每个无效模块，都需要在模块中有一个更新处理函数，或者在它的父级模块们中有更新处理函数。否则，无效标记冒泡，并也使父级无效。每个冒泡继续直到到达应用程序入口起点，或者到达带有更新处理函数的模块（以最先到达为准）。如果它从入口起点开始冒泡，则此过程失败。 之后，所有无效模块都被（通过 dispose 处理函数）处理和解除加载。然后更新当前 hash，并且调用所有 “accept” 处理函数。runtime 切换回闲置状态，一切照常继续。]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack文章记录]]></title>
    <url>%2F2017%2F12%2F24%2Fwebpack%E6%96%87%E7%AB%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[文章 webpack的主要对象 没看懂 源码 WebpackOptionsApply AST抽象语法树（Abstract Syntax Tree）也称为AST语法树，指的是源代码语法所对应的树状结构。 也就是说，对于一种具体编程语言下的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。 AST]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数分析题]]></title>
    <url>%2F2017%2F12%2F15%2F%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%E9%A2%98%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 #### 12345678console.log(a);var a=12;function fn()&#123; console.log(a); var a=13;&#125;fn();console.log(a); 输出的三次分别是多少 A、undefined 12 13 B、undefined undefined 12 C、undefined undefined 13 D、有程序报错 答案为B、undefined undefined 12 #### 12345678console.log(a);var a=12;function fn()&#123; console.log(a); a=13;&#125;fn();console.log(a); A、undefined 12 13 B、undefined undefined 12 C、undefined undefined 13 D、有程序报错 答案为A undefined 12 13 #### 12345678console.log(a);a=12;function fn()&#123; console.log(a); a=13;&#125;fn();console.log(a); A、undefined 12 13 B、undefined undefined 12 C、undefined undefined 13 D、有程序报错 答案为D 报错 a 未定义 #### 12345678var foo=1;function bar()&#123; if(!foo)&#123; var foo=10; &#125; console.log(foo);&#125;bar(); A、1 B、10 C、undefined D、报错 答案为B 10 #### 12345678910111213var n=0;function a()&#123; var n=10; function b()&#123; n++; alert(n); &#125; b(); return b;&#125;var c=a();c();alert(n); 弹出三次的结果分别是什么？ A、1 1 1 B、11 11 0 C、11 12 0 D、11 12 12 答案为C 11 12 0 #### 123456var a=10,b=11,c=12;function test(a)&#123; a=1;var b=2;c=3;&#125;test(10);alert(a); alert(b); alert(c); 弹出的三个值分别是多少？ A、1 11 3 B、10 11 12 C、1 2 3 D、10 11 3 答案为D 10 11 3 #### 1234if(!("a" in window))&#123; var a=1;&#125;alert(a); 弹出的a的值是？ A、1 B、undefined C、报错 D、以上答案都不对 答案为B undefined #### 12345678var a=4;function b(x,y,a) &#123; alert(a); arguments[2]=10; alert(a);&#125;a=b(1,2,3);alert(a); 三次弹出的结果是 A、3 3 4 B、3 10 4 C、3 10 10 D、3 10 undefined 答案为D、3 10 undefined #### 1234567var foo='hello';(function(foo)&#123; console.log(foo); var foo=foo||'world'; console.log(foo);&#125;)(foo);console.log(foo); 输出为 A、hello hello hello B、undefined world hello C、hello world world D、以上答案都不正确 答案为A 三次都为hello #### 12345678910var a=9;function fn()&#123; a=0; return function(b)&#123; return b+a++; &#125;&#125;var f=fn()var m=f(5);alert(m);var n=fn()(5);alert(n);var x=f(5);alert(x);alert(a); 弹出的四次结果？ A、6 6 7 2 B、5 6 7 3 C、5 5 6 3 D、以上答案都不正确 答案为D、以上答案都不正确 5 5 6 2]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记- mysql 必知必会]]></title>
    <url>%2F2017%2F12%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-mysql%20%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[创建表12345678910CREATE TABLE `ACTIVITY20180529_DAILY` ( `lid` int(11) NOT NULL COMMENT '这里是相关注释', `day` int(11) NOT NULL, `uid` int(11) NOT NULL DEFAULT '0', `count` int(11) NOT NULL DEFAULT '0', `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `lan` char(11) NOT NULL DEFAULT 'en', PRIMARY KEY (`uid`,`lid`,`day`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 表数据操作查询表数据1SELECT uid FROM TABLEBA 查询不同行 1SELECT DISTINCT uid FROM TABLEBA 相当于查询每一个不重复的UID 注意： DISTINCT 关键字应用与后面所有的列 limit1SELECT DISTINCT uid FROM TABLEBA LIMIT start, number 表示从start 查询 number 个 等同于 1SELECT DISTINCT uid FROM TABLEBA LIMIT start OFFSET number 如果LIMIT的后面只写一个 则表示取Number 个 1SELECT DISTINCT uid FROM TABLEBA LIMIT number 例子： 12`select id, uid, goods_id as goodsId, live_id from $&#123;TABLE['game']&#125; where uid = $&#123;uid&#125; order by datetime desc limit $&#123;number&#125;` 表示选取number 个 12`select id, uid, goods_id, live_id from $&#123;TABLE['game']&#125; where uid = $&#123;uid&#125; order by datetime desc limit $&#123;start&#125;, 20` 这里的limit m, n 表示从m 开始 选取n 个 排序 order by查询的结果按照某列排序 1select uid from tablea order by count 按照多列排序 1select uid from tablea order by count, day 多列排序的时候， 会先按照count排序 当count相等的时候 再按照day排序 order by xxx desc默认排序是从小到大。如果希望从大到小排序。则需要添加关键字 desc 1select uid from tablea order by count desc, day desc 只针对于紧挨着关键字的列排序 如果想多列都降序排序 则需要将每一列都添加 DESC 筛选数据 WHERE1select uid from tablea where day &gt; 20180412 order by count desc, day where 子句 含义 操作符 等于 = 不等于 != 或者 &lt;&gt; 大于 &gt; 大于等于 &gt;= 小于 &lt; 小于等于 &lt;= 在两者之间 between 关于查找 值为 null 的列1select uid from tablea where day is null 这样虽然能查到结果 但是不建议这么操作 [未知具有特殊含义 数据库不知道他们是否匹配] 可以将 默认值 NULL 修改为字符串null 然后 where day &lt;&gt; ‘null’ 操作符 OR AND IN1select uid from tablea where day = 20180412 or day =20180414 1select uid from tablea where day = 20180412 and city = 'th' 1select uid from tablea where uid in (123, 345, 567) NOT用于否定跟在之后的条件 插入insert into1`insert into $&#123;TABLE&#125; (uid, name) values ($&#123;uid&#125;, $&#123;name&#125;)` 如果想一次批量插入 先将语句利用循环进行拼接 123456let all = []end.forEach((uid, name) =&gt; &#123; all.push(`($&#123;uid&#125;, $&#123;name&#125;)`)&#125;)`insert into $&#123;TABLE&#125; (uid, name) values ($&#123;all.join(',')&#125;)` insert into 中如果有一列是 主键 则如果插入相同值的时候 会报错 insert ignore没有就进行插入 有就不做任何操作 这个一般会有性能问题 不建议使用 插入检索出来的数据从TABLEA 检索数据 放入 TABLEB 中 从A中查询出所有数据然后 在放入 TABLEB中 直接放入从A检索处理来的数据 1INSERT INTO ACTIVITY20180529_ANCHOR (uid) SELECT uid FROM ACTIVITY20180529_ROOM 注意，通过这种方式插入的列数据 不是根据列名去插入 而是根据写的位置去插入 比如 1INSERT INTO TABLEA (uid, city, time) SELECT city, uid, day FROM TABLEB 如果是这样写的话 从TABLEB 中查询出来的 city 列 会进入 TABLEA 的 uid 列 更新12update $&#123;TABLE&#125; set name = $&#123;name&#125; where uid = 4 limit 10 这个更新有一个问题 无法批量进行更新 删除1`DELETE FROM $&#123;TABLE&#125; WHERE id=3` 日期和时间处理函数时间戳 &amp;&amp; 时间 时间戳 -》时间 如果表中存放的是时间戳 但是想获取的是普通时间格式 1`select FROM_UNIXTIME(1516243968)` 时间 -》时间戳 1`select UNIX_TIMESTAMP('2017-01-01')` 汇总函数 含义 操作符 求和 SUM 返回某列的行数 COUNT sum 求和 比如 计算某一个用户收到的礼物总和 1SELECT SUM(beans) FORM TABLE WHER UID = 131 count 计算行的出现次数 比如，筛选某一个用户抽奖次数 1SELECT COUNT(uid) FORM TABLE WHER UID = 131 注： 如果使用的 COUNT() 则将会包含 NULL 值的那些行 如果不是用时 那么会忽略掉 NULL 行 分组 GROUP BYGROUP BY xxx]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border-image]]></title>
    <url>%2F2017%2F12%2F05%2Fborder-image%2F</url>
    <content type="text"><![CDATA[有处理到一个CSS问题 内容列表区域展示部分 边框是图片形式的~ css画不出来~~ 使用的border-iamge处理边框图片的问题 最终效果如下~ 关于border-image这里不多做解释 可参考文章 张鑫旭css3-border-image CSS魔法堂：重拾Border之——图片作边框 这里只几点使用中注意的问题 round 与 repeat您从万科地产买了个99.5m99.5m的毛坯房，地面要贴瓷砖，都是1m1m的正方形瓷砖。 如果是“平铺”，对不起，这1m边长的瓷砖不行，要处理！怎么处理法？很简单，每个瓷砖压成0.995m*0.995m的，这样就可以了，所以，平铺就是以完整的单元铺满整个区域。 如果是重复，就直接把这1m*1m的瓷砖从一个角落一个一个的放置，放到头放不下了怎么办？直接把瓷砖从中间“咔”掉，于是最后会在房子的边角看到很多半截的瓷砖 — 来自张鑫旭css3-border-image border-iamge 与 border-radius 冲突项目设计稿中 边框是有圆角的 因此我又添加了圆角属性 123456789background: green;border: 5px solid #fff;border-image-source:url('../../img/border2.png');/* 以九宫格形式做切片 */border-image-slice:20;border-image-repeat: round;/* 添加圆角属性 */border-radius: 20px; 但是页面中并没有出现圆角效果 问题参见 css3 怎么实现border-image圆角的问题 核心在于 当使用border-iamge时候 会压制 border的样式 如果border-iamge 出错 就会展示border的样式 然后测试一下 写一个错误的URL图片路径 当border-image 失效的时候 border style 就可以看到了 MDN 使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式。虽然规范要求使用 border-image 时边框样式必须存在，但一些浏览器可能没有实现这一点。 特别注意，若 border-image-source（此值可用border-image-source或border-image简写设置) 的值为 none 或者图片不能显示，则将应用 border-style。 其实我觉得 border-style 其实是实现了的 但是被border-image 的效果遮挡住了 我们可以拿一个透明图片来测试一下 那么怎么实现圆角效果呢？ 利用九宫格原理 将资源图片设置为圆角 开始时候我们的资源图片是这个样子的 是一个60 x 60的图片源 这经过九宫格处理之后 每一个格子就是 20 x 20的 那么此时分布在元素border的四个角上的 对应着 九宫格的四个角 所以我们只要把资源图片的四个角位置设置为有弧度的 那么经过九宫格处理后 页面就可以看到圆角效果了 所以将资源图片更改为 然后刷新页面 这里看到有一个圆角效果了 但是后面的多余元素颜色也漏出来了 所以再添加一个 border-radius 就可以了 盒子的overflow 将页面结构更改为 123&lt;section&gt; &lt;div&gt; 国际圣诞节 &lt;/div&gt;&lt;/section&gt; 然后里面div的样式不要变动 在section中做处理 12border-radius: 10px;overflow: hidden; 这样也可以走到罗马]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>border-iamge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划6]]></title>
    <url>%2F2017%2F12%2F03%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%926%2F</url>
    <content type="text"><![CDATA[work国际母亲节 12-21 圣诞节 涉及知识点： 精准定位 border-image 第三方分享机制 react-router life webpack 配置根据环境分开 koa koa 主页解析有问题 柯南]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-4 - webpack的常用plugin]]></title>
    <url>%2F2017%2F11%2F30%2Fwebpack-4-webpack%E7%9A%84%E5%B8%B8%E7%94%A8plugin%2F</url>
    <content type="text"><![CDATA[webpack的常用plugin CommonsChunkPlugin打包公共文件 12345new webpack.optimize.CommonsChunkPlugin(&#123; name: ['vendor', 'manifest'], minChunks: Infinity, // (随着 entry chunk 越来越多， 这个配置保证没其它的模块会打包进 vendor chunk)&#125;) CommonsChunkPlugin 的配置项 1new webpack.optimize.CommonsChunkPlugin('init') 编译之后的文件命名将按照传入的文件名 + 配置在output中 filename格式 进行命名 比如 在filename中是 123output:&#123; filename: '[name].[chunkhash:4].js'&#125; 则上面公共文件输出为 init.89sk.js 也就是也会配置相应的哈希值 公共业务模块与类库或框架分开打包12345678910111213module.exports = &#123; entry: &#123; vendor: ['react'], index: './index.js', main: './main.js' &#125;, -- -- plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: ['bundle', 'vendor'] &#125;) ]&#125; 但是这里有一个问题 如果项目中有 非 vendor 中的文件发生了重新编译 vendor 的文件也会被重新编译 vendor 哈希值一直变动问题（一下的测试全部指的是单入口应用） 为了最小化生成的文件大小，webpack使用标识符而不是模块名称，在编译期间生成标识符，并映射到块文件名，然后放入一个名为chunk manifest的JS对象中。重点就在于！！当我们使用CommonsChunkPlugin分离代码时，被分离出来的代码（比如React库，被打包为vendor），会默认被移动到entry中最后一个入口进行打包（第一个入口是index.js。重要的是，chunk manifest将随着这些被分离出来的代码共同打包！！！ 由于我们更改源代码后，不但会更新app的hash值，还会生成新的映射，然后新的映射又会和资源代码一同打包，又由于chunkhash是根据内容生成hash的，那么加入了新的映射对象chunk manifest的资源代码被打包后，hash自然也会发生改变。这反过来，产生的新hash将使长效缓存失效。 那么接下来我们需要做的就是把 manifest分离出来 12345plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: ['vendor', 'manifest'] &#125;)] 添加一个entry中未用到的名称 就可以manifest分离出来了 这样每次文件变动的时候 manifest.js 会发生变动 而 vendor 不会再发生变动 HashedModuleIdsPlugin 与 NamedModulesPlugin这个需要配合上面说的 commonsCunkPlugin 使用 参考文章 clean-webpack-plugin每次重新打包都会清理 pbblic 文件夹的内容 123456789101112const CleanWebpackPlugin = require('clean-webpack-plugin')plugins: [ new CleanWebpackPlugin( ['public/index-*.js','public/manifest-*.js'], // 匹配删除的文件 &#123; root: __dirname, //根目录 // verbose: true, // 开启在控制台输出信息 其实默认为TRUE // dry: false // 删除文件 默认FALSE &#125; )] 这样每次重新打包的时候 public文件夹都会删除掉 属性名 默认的属性值 含义 root __dirname 根节点 verbose true 在控制台输出log dry false 执行删除操作 watch false 在编译的时候 不去 删除旧的文件 exclude 数组 删除的时候 这个数组中的不进行删除 allowExternal false 不可以删除在上面配置的root之外的文件 其实还可以通过在命令行添加参数实现清除功能 1"webpack": "rm -rf public; webpack --watch" github地址 UglifyJsPlugin1new webpack.optimize.UglifyJsPlugin() extract-text-webpack-plugin此插件用于分离CSS和JS文件 将css文件单独打包到css文件，而不是写在js文件中（因为webpack将一切都视为模块，所以默认会打包到js文件中） 它会将所有的入口 chunk(entry chunks)中引用的 sass less 或者 styles 文件，移动到独立分离的 CSS 文件 因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载 在Module中配置 loader 在 plugin中添加ExtractTextPlugin 属性 123456789101112131415module: &#123; loaders: [ &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader" &#125;) &#125; ]&#125;......plugins: [ new ExtractTextPlugin('index.css')] 所有chunk中被引入的 CSS文件被打包到一个CSS文件中 并被引入index 如果是多个入口文件 需要各自引入需要的js 以及 css 文件呢 则需要这么配置 1new ExtractTextPlugin('[name].css') 需要同时配置 modules 和 plugins 12345678910111213141516171819202122232425262728293031const ExtractTextPlugin = require('extract-text-webpack-plugin')const extractCSS = new ExtractTextPlugin('style/[name]-css.css')const extractLESS = new ExtractTextPlugin('style/[name]-less.css')const extractSCSS = new ExtractTextPlugin('style/[name]-scss.css')module.exports = &#123; module: &#123; rules: [ &#123; test: /\.less$/, use: extractLESS.extract([ 'css-loader', 'less-loader' ]) &#125;, // 处理 sass 相关 &#123; test: /\.scss$/, use: extractLESS.extract([ 'css-loader', 'sass-loader' ]) &#125;, // 处理css &#123; test: /\.css$/, use: extractCSS.extract([ 'css-loader', 'postcss-loader' ]) &#125; ] &#125; plugins: [ extractCSS, extractLESS, extractSCSS, ] &#125; github]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划5]]></title>
    <url>%2F2017%2F11%2F22%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%925%2F</url>
    <content type="text"><![CDATA[work娃娃机项目 【紧急】 蓝v推广 国际父亲节 life项目总结 koa webpack ** 为什么HTML变化 页面不刷新 只有js变化 才引起页面刷新 ** 为什么 UglifyJsPlugin 配置出错 ** 目前webpack打包之后的文件在内存中 不再public里面 ** babel 配置问题 ** DevServer 中 proxy 代理设置 ** CleanWebpackPlugin 中 exclude ** 为什么css 和 less 都被编译了]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件练习]]></title>
    <url>%2F2017%2F11%2F12%2F%E4%BA%8B%E4%BB%B6%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 关于 鼠标事件 onmouseover onmouseout 这两个事件都会发生冒泡，在处理有子元素情况的时候，需要注意一下。 有两个方法解决 1 使用onmouseenter onmouseleave 替代 2 判断关联元素是否存在 1 onmouseenter onmouseleave 这两个事件都不会发生冒泡 2 关联元素 在onmoueseover 事件中，关联元素是 12let target = e.realtedTarget||e.fromElement;if( oDiv.contains(oTo) )&#123;return &#125; 在onmouseout 事件中 ，关联元素是 1let target = e.relatedTarget||e.toElement; 穿墙效果穿墙效果在线展示 核心JS代码展示]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承]]></title>
    <url>%2F2017%2F11%2F10%2F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 文章导读 1 如何更改原型上的属性或者方法 2 call 3 实现继承的几种方式 更改类的原型上的属性或者方法1.1 通过直接 修改类的prototype 1.2 通过修改实例的 proto 123Array.protype.push=&#123;&#125;;// 或者ary1.__proto__.push=&#123;&#125; 在所有浏览器下，禁止用户批量修改，实例上的公有属性和方法； IE中不允许使用proto修改属性方法，可以通过 类.prototype 个一个的修改。 标准浏览器中可以使用proto 以及 类.prototype 可以一个一个的修改原型的属性方法。 关于构造函数2.1 构造函数中的this 都是当前实例 2.2 构造函数中都是私有的变量方法, 类.prototype 上是公有的属性方法 2.3 若是类.prototype 赋值一个对象,则自带的属性constructor 一定会发生变化 3 call()call 的作用就是改变this指向 obj1.call(obj2)将obj1中的this 指向到后面的那个对象obj2call的第一个参数：改变call点前面的函数中的this指向；call的第二个参数开始，对函数中的形参从左往右的赋值； 继承的几种方式call() 继承继承原理 父级的私有属性方法 继承给子级元素的私有属性方法 12345678function Person()&#123; this.name = 'tom'; this.age = 23;&#125;function Sun()&#123; Person.call(this)&#125; 冒充继承通过for in 循环 继承原理 父级的私有以及公有属性方法 继承给子级元素的私有属性方法 12345678910111213function Person()&#123; this.name = 'tom'; this.age = 23;&#125;Person.prototype.say= fucntion()&#123;console.log('hello')&#125;var p1 = new Person();function Sun()&#123; for(var attr in p1)&#123; this[attr] = p1[attr] &#125;&#125;var sun1 = new Sun();sun1.say(); // hello 原型继承继承原理 父级的私有以及公有属性方法 继承给子级元素的公有属性方法 12345678910111213function Person()&#123; this.name = 'tom'; this.age = 23;&#125;Person.prototype.say = function () &#123; console.log('hello')&#125;var p1 = new Person();function Sun()&#123;&#125;Sun.prototype = new Person();var sun1 = new Sun(); 拷贝继承 call继承+extend继承继承原理 父级的私有属性 -》子级元素的私有属性 call() 继承 父级的公有属性 -》子级元素的公有属性 extend继承 1 先写一个extend的封装函数,将obj1中的属性方法通过for in 全复制一份到Obj2中 123456function extend(obj1,obj2)&#123; for(var attr in obj1)&#123; obj2[attr] = obj1[attr] &#125; return obj2;&#125; 2 call 继承父级私有属性 + extend 继承公有属性 123456789function Per()&#123; this.name='tom'&#125;Per.prototype.say=function()&#123;console.log('hello')&#125;function Sun()&#123; Per.call(this)&#125;extend(Per.prototype,Sun.prototype);var sun1 =new Sun() 关于属性的几种方法判断属性是否在对象上，属性名一定要加引号，否则，会把他当做变量，报错 5.1 hasOwnProperty obj.hasOwnPorperty(‘say’)判断say是不是obj的私有属性或者方法 5.2 isPropertyOf obj1.isPropertyOf(obj2)判断 前者是不是在后者的原型链上 5.3 in console.log( ‘say’ in Person )判断属性是不是所写类的属性或方法,包括公有和私有,返回true或者false 5.4 for in 循环自定义属性,公有加私有 5.5 propertyIsEnumerable 只能遍历对象身上自定义的私有属性和方法 6 other 6.1 写一个方法,判断属性是不是公有属性hasPubProperty 思路：该属性是对象上的属性 &amp;&amp; 该属性不是对象的私有属性 123fucntion hasPubProperty(attr,obj)&#123; return attr in obj &amp;&amp; !obj.hasOwnProperty(attr)&#125; 6.2 链式操作 关注的是前一个函数执行完成的“返回值”，返回的是个数组，后续就跟数组的方法，返回的是个数字，后续就跟着数字的方法]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript零碎]]></title>
    <url>%2F2017%2F11%2F06%2FJavaScript%E9%9B%B6%E7%A2%8E%2F</url>
    <content type="text"><![CDATA[JavaScript零碎知识点 1 关于运算符 算数运算符：+ - * / % 比较运算符：&lt; &gt; &lt;= &gt;= == === != !== 逻辑运算符：&amp;&amp; || ！ 运算符的优先级: 算数 &gt; 比较 &gt; 逻辑 &gt; 赋值 2 if() 条件为真假 除了以下六个为假，其他都为真： false 0 “” null undefined NaN 4 JavaScript 基本数据类型 Undefined Null Number String Boolean 5 函数返回值出现undefined： 无return 或者 return 后面没东西]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别人的读书笔记]]></title>
    <url>%2F2017%2F11%2F06%2F%E5%88%AB%E4%BA%BA%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[serverhttp1 《图解HTTP》读书笔记]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http与https]]></title>
    <url>%2F2017%2F11%2F06%2Fhttp%E4%B8%8Ehttps%2F</url>
    <content type="text"><![CDATA[在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示： HTTP默认的端口号为80，HTTPS的端口号为443。]]></content>
  </entry>
  <entry>
    <title><![CDATA[http基础知识2]]></title>
    <url>%2F2017%2F11%2F06%2Fhttp%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862%2F</url>
    <content type="text"><![CDATA[http 的报文由起始行 头部 主体构成 包含许多信息 请求行包含用于请求的方法，请求 URI 和 HTTP 版本。 状态行包含表明响应结果的状态码，原因短语和 HTTP 版本 http请求报文请求方式 HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式 本文只讲解两种 对其余有兴趣的同学可自行阅读 GET 向特定的资源发出请求 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。 POST请求可能会导致新的资源的建立和/或已有资源的修改 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed）；当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented） GET POSTGET一般用于获取/查询资源信息，而POST一般用于更新资源信息 GET和POST的区别： 1、传递数据方式不同 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。 2、数据大小限制不同 GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。 3、安全方面 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。 所以涉及到用户信息的 最好使用post请求处理 http响应报文常用的http响应状态码 200 成功 3xx 重定向 4xx 出错 5xx 服务器出错 参考文章1 http协议扫盲 2 http网络请求 返回statusCode 3 99%的人都理解错了HTTP中GET与POST的区别 4 HTTP协议中GET和POST方法的区别]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this]]></title>
    <url>%2F2017%2F11%2F06%2Fthis%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 this1.1 当元素身上的事件被触发时执行的函数，该函数中this指向当前元素 1.2 函数被调用时，看前面是否有点。有点的this就指向点前面的那个，没有就是window 1.3 自执行函数的this 为 window 应用2.1 知识点： 预解释 自执行函数this 函数返回值 12345678var name='who';var age=500;name=(function(name,age)&#123; arguments[0]='who'; age=age||this.age; console.log(name,age); &#125;)(name);console.log(name,age) 2.2 1234567891011121314151617var num = 10;var obj = &#123; num: 20, fn: (function (num) &#123; this.num *= 2; num += 10; return function () &#123; this.num *= 3; num += 1; console.log(num); &#125; &#125;)(num)&#125;;var fn = obj.fn;fn();obj.fn();console.log(window.num, obj.num);]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划4]]></title>
    <url>%2F2017%2F11%2F06%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%924%2F</url>
    <content type="text"><![CDATA[work 公益问卷提测 life 配置mac 继续阅读暗时间 正则基本知识的那篇博客 差一点东西在纸质资料中]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端与服务端交互模型]]></title>
    <url>%2F2017%2F11%2F05%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[客户端与服务器端 当用户在客户端输入一个网址，在点击enter 到页面被渲染出来，中间经历了什么事情。 什么是客户端 能向服务器端发送请求并且接受内容的都是客户端 什么是服务器端 能接受客户端请求并且返回内容给客户端的都是服务器端 2 详细步骤 1 购买一个服务器 在连上网后 获得了一个外网IP地址 2 通过ftp上传项目资源文件 到服务器 3买一个域名 进行DNS域名解析 在DNS 服务器 将域名 www.webmxx,com 解析到购买的那服务器端 IP地址 4 在服务器上创建一个服务。 这个服务接受客户端的请求，把客户端的想要的内容返回给客户。为了区分每一个服务，给其监听一个端口号。 如何创建服务 4.1 指定当前服务负责哪个文件目录 4.2 不同的服务 端口号不同 3 当用户在客户端输入一个网址，在点击enter 到页面被渲染出来，中间经历了什么事情。 1 通过域名 找到DNS 上对应的外网IP 就是服务器主机IP 【就是所谓的外网IP】 2 通过外网IP找到对应的服务器 3 通过地址栏端口号找到相应服务 4 到相应目录中找到所需要的文件 5 服务器端这个服务会把资源文件中的源代码发回给客户端浏览器 6 客户端浏览器获取到源代码后进行解析渲染 以上123属于请求阶段 Request 45 属于响应阶段 Response 4 URL URI URN http://mxx2015web.gotoip2.com/wp-admin/post.php?post=633&amp;action=edit http://www.webmxx.com/dest/JSTEST/Canvas/canvas-girl.html 这个严格意义上是叫URI URI 统一资源标识符 URL 统一资源定位符 http://mxx2015web.gotoip2.com/wp-admin/post.phpURN 统一资源名称 wp-admin/post.php?post=633&amp;action=editURI 包含了 URI 和 URN 不过一般将那个地址称为URL ，之后本文也以URL指代。 5 解析URL 以 http://www.webmxx.com:80/wp-admin/post.php?post=633&amp;action=edit#video 为例 5.1 http 传输协议。作为一个传输载体，可以帮客户端把内容传递给服务器 也可以帮服务器把内容传递给客户端。通俗理解为快递员。 常用的传输协议 1 HTTP 超文本传输协议 [除了传递文本内容之外 还可以传递其他内容 例如 二进制编码 XML格式数据 Base64 的等等] 2 HTTPS 【HTTP SSL】 更加安全的超文本传输协议 相对于HTTP 传输的时候 进行了一层加密 3 FTP 文件上传下载协议 一般应用于把本地项目资源文件上传到服务器上 特点:传递的文件比较大 以前那种点击下载文件的就是通过FTP做的 5.2 www.webmxx.com 域名 作用 就是设定一个方便用户记忆的名字 1 后缀名有 .com .cn .net .com.cn .org .gov 等等2 一级域名 二级域名 三级域名 一级域名 例 www.qq.com 二级域名 例 sports.qq.com 三级域名 例 kbs.sports.qq.com 只要购买了一级域名，二级域名 三级域名 就是自己基于一级域名下分的 5.3 端口号 80 区分不同的服务 同一台服务器上 可创建多个服务 每一个都有自己的端口号 端口号取值范围 0 -65535 之间 ,也就是最大能创建65536个服务。但是一般在1-5 个左右 一般项目是不需要用户输入端口号的,浏览器这边会根据传输协议的不同 ,会添加不同的默认端口号 比如 HTTP 默认端口号 80 HTTPS 默认端口号443 FTP默认端口号21 5.4 /wp-admin/post.php 需要请求的资源文件目录 第一个/ 表示请求的是当前项目根目录下的wp-admin文件夹中的post.php文件 5.5 ?后面的 ?post=633&amp;action=edit 问号传参 把这些信息以问号的方式追加在URL末尾 把内容传递给服务器 5.5.1 可以通过这种方式传递给服务器指定的内容 从而获取到指定信息 例如，要获取name=’tom’ 的信息 ，需要把name=‘tom’传递给服务器 5.5.2 通过问号传参，将数据在两个页面之间传递 例如 A为列表页 B为详情页 点击A中记录可跳转到B中页面 就是在B页面中展示不同的详细信息 所以B需要知道A点击的是谁 所以在点击A中记录的时候 不仅要跳转到B 还需要通过问号传参的方式 传递过去一些标识即可 5.6 #video #后面的 -》 hash 哈希值 1 锚点定位 当页面加载的时候 或者 点击a 标签 可以直接跳转到 具有该ID的元素位置 2 前端路由 [单页面应用] 3 传递给服务器进行标识 [不常用 一般都是用问号传参进行标识] 6 客户端拿到服务器返回的东西 之后 渲染页面 解析数据 6.1 为什么代码放在浏览器中可以呈现出页面样式。 W3C 万维网联盟 一个制定编程语言的非联盟组织 代码写完运行在浏览器中 浏览器制造商 制定编译规范 WEB开发者 按照W3C 规则编写网页 6.2 浏览器制造商 从浏览器内核[引擎] 来分 6.2.1 webkit 内核 又称 V8引擎 移动端浏览器都是V8引擎 chrome 谷歌 safari -webkit- 6.2.2 Trident内核代表产品Internet Explorer，又称其为IE内核 -ms- 6.2.3 Gecko内核代表作品Mozilla 火狐 -moz- 6.2.4 Presto内核代表作品Opera -0- 6.2.5 中国版浏览器 Trident 或者 webkit 6.4 从服务器把原代码获取到之后 教给浏览器内核进行解析 在解析过程中 遇到标签 link video audio script iframe 等的时候，需要重新向服务器发送请求 把内容获取到 进行解析。这样导致 一个页面在加载完毕 会向服务器发送多次请求 在chrome的network中 可以看到所有的客户端与服务器的交互信息 [请求 响应] 而且信息非常完整 6.5 前端优化 前端优化: 用户打开页面的时候 能迅速打开页面]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http基础篇]]></title>
    <url>%2F2017%2F11%2F04%2Fhttp%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是httpHTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写 目前使用的大多是HTTP 1.1版本 HTTP [超文本传输协议] 是获取网络资源的协议，在获取HTML页面后者js文件都需要按照此协议。HTTP协议是web数据交换的基础。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等在客户端从服务端接受到相应后，进行数据解析和页面渲染 http的特点1.支持客户/服务器模式。 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4.无连接：无连接的含义是限制每次连接只处理一个请求。 服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5.无状态：HTTP协议是无状态协议。 无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 就是在同一个连接中，在两个请求之间是完全没有关系的。所以服务器不知道这两个请求来自同一个连接 可以通过设置请求头或者使用cookie等存储机制解决此问题 http 分析HTTP协议属于TCP/IP协议族应用层的协议。 持久链接持久链接（HTTP Persistent Connections、HTTP keep-alive、HTTP connection reuse） HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP链接，频繁的TCP链接与断开（如请求一个有很多图片的网页）会造成无谓的流量消耗和低效的性能。 持久链接的特点是：只要任意一端没有明确地提出断开连接，则保持TCP连接状态。 在HTTP/1.1中，所有的连接默认都是持久连接，持久连接的实现需要服务器端和客户端同时支持。 持久连接使得当有多个请求时，可以以管线化方式发出请求：不用等待前一个请求的响应即可以直接发送下一个请求（实现并行请求行为） HTTP事务一次HTTP操作称为一个事务，其工作过程可分为四步： 1）首先客户机与服务器需要建立连接。只要单击某个链接，HTTP的工作开始。 2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 HTTP传输的这件事 Request + Eesponse 只有请求和响应都完成，才算HTTP事物完成 HTTP 报文客户端不仅可以向服务器发送请求，还可以把内容传送给服务器 服务器端也会把一些内容返回给客户端 请求报文: 客户端给服务器的内容 响应报文: 服务器给客户端的内容 两者统称为HTTP报文 第一部分 起始行 第二部分 首部（头）第三部分 主体 对于请求报文 -》 请求起始行 请求头 请求主体 对于响应报文- 》 响应起始行 响应头 响应主体 其实对于首部 来说，除了请求头和响应头 还有通用头 自定义请求头 自定义响应头 以上这些信息在浏览器控制台 network 选项中查看到 在自定义请求头时 一般不可以传入汉字 如果非要传入汉字 需要进行编码 然后后台进行对应解码操作 1xhr.setRequestHeader('fromWho','尝试传入汉字') 请求报文是由客户端设置 由服务器端获取的 响应报文是由服务端设置 由客户器端获取的 客户端把内容传递给服务器的方式 问号传参 使用请求报文 将内容写在请求头 使用请求报文 将内容写在请求主体 服务器把内容传递给客户端的方式使用响应报文 将内容写在响应头 使用响应报文 将内容写在响应主体 【不会使用起始行进行内容传递】 名词解析TCP/IP 协议简单的把一次通信的过程分为三个阶段：客户端发出，线路中传输，服务端响应。互联网中的设备要完成通信必须基于双方都能识别的规则，如通信的语音，格式，硬件和操作系统等等，这些规则的集合统称为TCP/IP 协议族。 http 报文用于HTTP协议交互的信息被称为HTTP报文 参考文章1 熟悉的陌生人-HTTP 2 HTTP协议详解]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存]]></title>
    <url>%2F2017%2F11%2F01%2F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[现在的大型网站，随便一个页面都是一两百个请求，每天 pv 都是亿级别，如果没有缓存，用户体验会急剧下降、同时服务器压力和网络带宽都面临严重的考验。 缓存和重用以前获取的资源的是优化网页性能很重要的一个方面。 缓存的优缺点优点 减少网络延迟，加快页面打开速度 缓存比源服务器离客户端更近，因此，从缓存请求内容比从源服务器所用时间更少，缓存的使用能够明显加快页面打开速度，达到更好的体验。 降低服务器的压力 给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。 减少网络带宽损耗 无论对于网站运营者或者用户，带宽都代表着金钱,当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。 缺点 缓存没有清理机制 这些缓存的文件会永久性地保存在机器上，在特定的时间内，这些文件可能是帮了你大忙，但是时间一长，我们已经不再需要浏览之前的这些网页，这些文件就成了无效或者无用的文件，它们存储在用户硬盘中只会占用空间而没有任何用处，如果要缓存的东西非常多，那就会撑暴整个硬盘空间。 给开发带来的困扰 明明修改了样式文件、图片、视频或脚本，刷新页面或部署到站点之后看不到修改之后的效果。 所以在产品开发的时候我们总是想办法避免缓存产生，而在产品发布之时又在想策略管理缓存提升网页的访问速度。 缓存分类Web应用领域，Web缓存大致可以分为以下几种类型： 数据库数据缓存 Web应用，特别是社交网络服务类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有memcached,redis等。 服务器端缓存代理服务器缓存 代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid,Nginx,Apache等。 CDN缓存CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，浏览器和服务器之间的缓存机制，在这种架构下同样适用。 浏览器端缓存浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。 Web应用层缓存应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率 例如 本地存储和离线存储 什么是浏览器缓存 Web缓存存在于服务器和客户端之间。Web缓存密切注视着服务器-客户端之间的通信，监控请求，并且把请求输出的内容（例如html页面、 图片和文件）另存一份；然后，如果下一个请求是相同的URL，则直接使用保存的副本，而不是再次请求源服务器。 http缓存是 基于HTTP协议 的浏览器文件级缓存机制。即针对文件的 重复请求情况 下，浏览器可以根据 协议头 判断从服务器端请求文件还是从本地读取文件 HTTP协议基于请求响应模式，客户端向服务器发送一个请求，请求头包含请求的方法，URI，协议版本以及包含请求修饰符，客户端信息和内容的类似 MIME的消息结果。 服务器则以一个状态行为作为响应，相应的内容包括消息协议的版本，成功或错误编码加上包含服务器信息，实体元信息以及可能的实体内容。 当浏览器第一次请求某个URL时，顺利访问的话，服务器返回状态200的状态, 同时会返回给浏览器一些Headers集合，例如set-cookie,Last-Mondified,Etag等等 关于处理缓存的信息头关键字HTTP协议中关于缓存的信息头关键字包括Cache-Control(HTTP1.1)，Pragma(HTTP1.0)，last-Modified，Expires等。 缓存控制头 Cache-ControlCache-Control 是最重要的规则。这个字段用于指定所有缓存机制在整个请求/响应链中必须服从的指令。这些指令指定用于阻止缓存对请求或响应造成不利干扰的行为。这些指令 通常覆盖默认缓存算法。缓存指令是单向的，即请求中存在一个指令并不意味着响应中将存在同一个指令。 cache-control 定义是：Cache-Control = “Cache-Control” “:” cache-directive cache-directive 的取值请参加本文 – 名词解析 – 部分 过期头 (Expires)指定资源在浏览器缓存中的过期时间 (需要在服务端设定) 如果给文件加上关于过期时间(Expires)的header报文,这样浏览器就会先检查缓存中的文件，如果没有过期，就直接使用缓存中的文件,从而不会发送http请求 控制文件是否有修改 Last-Modified/E-TagLast-Modified: 资源更新时间 Etag: 资源的状态唯一标识 一般选择哈希值 Last-Modified PK Etag 你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？ HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题： (1) Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间 (2)如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存 (3)有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。 Last-Modified与ETag是可以一起使用的， 服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified， 最后才决定是否返回304。 浏览器缓存流程图首次请求 第二次访问页面的缓存流程 1 判断expires，如果未过期，直接读取http缓存文件，不发http请求，否则进入下一步 2 判断是否含有etag，有则带上if-none-match发送请求，未修改返回304，修改返回200，否则进入下一步 3 判断是否含有last-modified，有则带上if-modified-since发送请求，无效返回200，有效返回304，否则直接向服务器请求 如果通过etag和last-modified判断，即使返回304有至少有一次http请求，只不过返回的是304的返回内容，而不是文件内容。所以合理设计实现expires参数可以减少较多的浏览器请求 名词解析PragmaPragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存 当该字段值为no-cache的时候，会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行 在 http1.0 时代，给客户端设定缓存方式可通过两个字段Pragma和Expires来规范。虽然这两个字段早可抛弃，但http协议做了向下兼容，所以依然可以看到 Expires响应报文中Expires其定义的是资源“失效时刻” 这里的缓存时间是相对服务器上的时间而言的, 如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了 Cache-Control针对上述的“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了 Cache-Control 来定义缓存过期时间 这三者的优先级从高到低分别是 Pragma -&gt; Cache-Control -&gt; Expires 作为请求首部时 其可选属性为 Cache-Control: no-cache：这个很容易让人产生误解，使人误以为是响应不被缓存。 实际上Cache-Control: no-cache是会被缓存的， 只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。 Cache-Control: no-store：这个才是响应不被缓存的意思。 作为响应首部时 其可选属性 Last-Modified标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间 If-Modified-SinceIf-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。 web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内）， HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。 Last-Modified/If-Modified-Since要配合Cache-Control使用 ETagETag 是HTTP1.1中才加入的一个属性，用来帮助服务器控制Web端的缓存验证。 它的原理是这样的，当浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值(3f80f-1b6-3e1cb03b)并通过 ETag 返回给浏览器，浏览器把”3f80f-1b6-3e1cb03b” 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: “3f80f-1b6-3e1cb03b” 的请求头把ETag发送给服务器，服务器再次计算A的哈希值并和浏览器返回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一个304未修改。 并未指定ETag是如何产生的 但是哈希是最好的选择方案 If-None-MatchIf-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。 Etag/If-None-Match也要配合Cache-Control使用 参考文章1 浏览器缓存原理]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划3]]></title>
    <url>%2F2017%2F11%2F01%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%923%2F</url>
    <content type="text"><![CDATA[work 公益调查问卷 第三稿修改了 甲方是爸爸 爸爸最大！！！ 希望不要有第四稿 泰国父亲节 server部分 life 人间草木 的读书笔记 webpack 暗时间 涉及到思维的书 果然难读]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[video.js的API]]></title>
    <url>%2F2017%2F11%2F01%2Fvideo-js%E7%9A%84API%2F</url>
    <content type="text"><![CDATA[视频第三方插件库 video.js 的API文档并不清晰 查阅的时候比较麻烦 自己整理了一篇API 官网 npm Github 标签属性 data-setup 属性* 方法 videojs(id, optionsopt, readyopt) ready play pause on 事件监听 off one log 信息打印 123this.on('ended', function() &#123; videojs.log('您的视频已经播放完毕')&#125;) duration currentTime 获取视频播放进度 1myPlayer.currentTime() 设置视频播放进度 1myPlayer.currentTime(100) width height size enterFullScreen 全屏 exitFullScreen 退出全屏 removeEvent 事件移除 事件 ended 播放事件结束 fullscreenchange 全屏状态变动 play pause]]></content>
      <categories>
        <category>第三方插件使用</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的css属性]]></title>
    <url>%2F2017%2F10%2F26%2F%E6%9C%89%E8%B6%A3%E7%9A%84css%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[开启惯性滑动1-webkit-overflow-scrolling:touch 但是这个可能会引起一些别的问题,参见文章webkit-overflow-scrolling 图片变为黑白1234567img.desaturate &#123; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%);&#125; 主要应用的是 css3-filter 它可以对图片进行类似于ps的简单效果 box-sizing可以设定图片实际宽度 文本渐变123&lt;div class="element"&gt; &lt;p&gt;Lorem ipsum dolor sit … amet.&lt;/p&gt;&lt;/div&gt; 1-webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0))); 利用了CSS的遮罩进行处理 也可以使用一个特定的图片进行展示 1-webkit-mask-image: url(mouse.png) calc1width: calc(100% - 100px) 可以利用calc 实现css中的函数效果 mask – css遮罩123456&amp;__mask &#123; color: #fff; mask-image: url('../../img/product.png'); mask-repeat: no-repeat; mask-size: 100% 100%;&#125; css遮罩 @supports类似媒体查询 可以将@supports 视为 特性查询 用来查询浏览器是否支持某个CSS3的特性，这个功能除了IE之外，已被其他浏览器所支持 123@supports ( display: flex ) &#123; .foo &#123; display: flex; &#125;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础]]></title>
    <url>%2F2017%2F10%2F25%2Fnode%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[event事件发射on 与 emit emitemit 一次 相当于向方法池中添加一个函数 写一次加一次 即使是相同函数名 [ fn1 , fn2,fn1,fn4 ,fn1] once 发射一次之后移除此事件 removeListen 在发射之前移除 是就近移除 1removeListen(emitName,fn) removeAllListen 移除所有监听 removeAllListen 有参数则移除参数事件 有最大监听数 10 但是可以自己设置 target.setMaxListeners() listeners 获取当前函数池子中函数个数 12345678let girl = new Girl()girl.age='20'girl.once('smile', function () &#123; console.log('i am smiling') console.log(this.age)&#125;)girl.setMaxListeners(5)girl.emit('smile') 流 stream可读流 readStreamflag 打开文件要做什么 start end 前+后面 highWaterMark 最大字节数 默认64k 传送字节数 切换到流动模式 1rs.on('data') 流的方式是异步的，不能用try catch 要用on(‘err’) 不写编码格式的， on.(‘data’) 中读取到 就是 buffer形式 如果设置之后，highwaterMark 一定要大于最小编码的字符长度 pause 暂停 resume 开始 结束 1rs.on('end',function()&#123; ... &#125;) 可写流 writeStream默认编码utf8 highWaterMark 最大字节数 默认16k 1ws.write(data) 当数据写入核缓存区，该值为true 当数据存放到队列 ，该值为false 当流成功出刷新挂起的缓存区时调用drain 12ws.on('drain')ws.end('当写入结束时候你要写入的东西') pipe相当于可读流和可写流的综合：暂停可读流直到可写流赶上再恢复可读流 1(可读流).pipe(可写流); 默认情况下，可读流在结束时会调用end方法 当然你可以设置不这么做 12345678var fs = require('fs')var rs = fs.createReadStream('./2.txt')var ws = fs.createWriteStream('./3.txt') // 这个目标文件没有回自动创建的(rs).pipe(ws)rs.on('end', function () &#123; console.log('ending')&#125;) node路径__dirname 表示当前文件所在的目录的绝对路径 __filename 表示当前文件的绝对路径 module.filename ==== __filename 等价 process.cwd() 返回运行当前脚本的工作目录的路径 process.chdir() 改变工作目录]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[video 和 audio在移动端的表现]]></title>
    <url>%2F2017%2F10%2F24%2Fvideo%E5%92%8Caudio%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E8%A1%A8%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[videovideo是HTML5提供的新标签 用于替代flash进行视频展示 然而video在移动端的表现情况却不如人意 使用1&lt;video poster=&#123;`$&#123;source&#125;?vframe/jpg/offset/0`&#125; src=&#123;source&#125; controls="controls" /&gt; 或者是 123&lt;video poster=&#123;`$&#123;source&#125;?vframe/jpg/offset/0`&#125; controls="controls"&gt; &lt;source src=&#123;source&#125; type="video/mp4"&gt;&lt;/video&gt; 浏览器支持情况 在PC端表现还是不错的 常用属性 属性 属性值类型 含义 autoplay autoplay 设置为自动播放 controls controls 展示视频播放的控制条 preload preload 视频预加载 如果使用 “autoplay”，则忽略该属性 loop loop 开启循环播放 src string 视频源 muted Boolean 静音 poster string 视频封面 controls控制条包括：播放 暂停 定位 音量 全屏切换 字幕（如果可用）音轨（如果可用） 在iOS和Android中 控制条表现不同 以下是iOS中视频控制条的表现形式 以下是Android中视频控制条的表现形式 autoplay此属性表示设置为默认播放 但实际上 这个效果在移动端体验非常不友好 并不能实现视频自动播放的功能 移动端实际样式123&lt;video&gt; &lt;source src=&#123;source&#125; type="video/mp4" /&gt;&lt;/video&gt; 安卓手机呈现 iOS 手机呈现 可以看到 移动端视频展现没有一个合适的封面图 实际应该展示的是视频的第一帧作为默认封面图 然后我们添加一个 poster 属性 用于展现封面 123&lt;video poster=&#123;poster&#125;&gt; &lt;source src=&#123;source&#125; type="video/mp4" /&gt;&lt;/video&gt; 就可以正确展示视频封面了 关于获取视频封面项目中的视频是存储在七牛中的 七牛提供了一个图片地址 是截取视频第一帧 1let poster = `$&#123;source&#125;?vframe/jpg/offset/0` 如果你无法拿到视频中的某一张图片 就需要另外处理了 视频设置自动播放 则默认使用视频第一帧作为封面图 如果视频有设置 autoplay 属性 则可以展现第一帧作为封面 但是移动端体验不好 canvas截取视频封面 123456789let canvas = document.createElement('canvas')let video = document.getElementById(`video`)let ctx = canvas.getContext('2d')canvas.width = video.offsetWidthcanvas.height = video.offsetHeightctx.drawImage(video, 0, 0)let img = document.createElement("img")img.src = canvas.toDataURL("image/png")document.body.appendChild(img) 这样是利用canvas截取视频 得到一个Img图片 视频跨域 则无法获取到图片 视频截取中 网页报错 canvas中的图像进行操作时有跨域限制（canvas安全机制）,如在某一个域名项目中的canvas中加载非本域中的图像，在进行toDataURL或getImageData进行操作时抛出异常 所以如果你的项目中视频源不涉及到跨域问题 可以直接使用这种方式 如果视频不同源 则直接将canvas元素展现出来 配合CSS充当封面 123456let canvas = document.getElementById('canvas')let video = document.getElementById(`video`)let ctx = canvas.getContext('2d')canvas.width = video.offsetWidthcanvas.height = video.offsetHeightctx.drawImage(video, 0, 0) 全屏播放iOS系统中 默认是全屏播放 当你点击视频 iOS会自动全屏 Android 系统就是在展现的位置播放 当点击全屏按钮才会显示全屏 禁止iOS全屏播放 如果不想在iOS展示全屏效果 那么可以添加属性 playsinline 来禁止iOS的默认全屏 1&lt;video ref='videoEl' src=&#123;source&#125; &#123;...videoProps&#125; playsinline /&gt; 这样视频会在指定位置处播放 [和Android表现相同] Android 无法实现自动全屏 需要再处理 如果有设置 control 属性 则可以通过点击控制条中的全屏按钮实现全屏播放 还可以通过一个虚假的蒙层实现 全屏播放 当点击按钮的是 传入视频源 然后强制蒙层中的video元素100% 播放 常用方法 方法 含义 play 播放视频 pause 暂停视频 play12345componentDidMount () &#123; // 尝试播放视频 let target = findDOMNode(this.refs.videoEl) target.play()&#125; 然而 并没有什么用 PC端一切正常 但是在移动端是无法实现的 移动端的视频播放 必须通过用户执行点击动作 否则是无法实现播放的 1234document.addEventListener('touchstart', function () &#123; let video = document.querySelector('video') video.play()&#125;) 项目开始的时候提出一个需求 类似于微博客户端效果 当视频滑动到用户可视区 即可自动播放此视频 当此视频滑离可视区 则视频停止播放 1234567891011window.addEventListener('scroll', () =&gt; &#123; // 自动播放过一次之后 就禁止第二次自动播放了 let &#123;played&#125; = this.state if (played) return let scrollTop = document.documentElement.scrollTop || document.body.scrollTop // 滑动距离 + 屏幕距离 &gt; 盒子距离顶部 + 200 if (scrollTop + screenH &gt; boxTop + 200) &#123; this.refs.videoEl.play() this.setState(&#123;played: true&#125;) &#125;&#125;) 可以看到在PC端 可以实现这种效果 然而 由于移动端 必须通过用户点击屏幕的动作来触发播放事件 所以无法实现这个效果 添加一个事件: 视频滑入可视区的时候 监听用户的 touch 事件 用户触发视频的播放 1234567891011window.addEventListener('scroll', () =&gt; &#123; let &#123;played&#125; = this.state if (played) return let scrollTop = document.documentElement.scrollTop || document.body.scrollTop if (scrollTop + screenH &gt; boxTop + 200) &#123; document.addEventListener('touchstart', () =&gt; &#123; this.refs.videoEl.play() this.setState(&#123;played: true&#125;) &#125;) &#125;&#125;) 功能上是可以实现的 但是这种方式非常不友好 体验的时候就能感觉到 当用户把视频滑动到可视区域 并不一定发生touch事件 audioaudio 是HTML5提供的新标签 用于进行音频文件的播放 基本使用12345let audioProps = &#123; src: '../music.mp3', loop: 'loop'&#125;&lt;audio &#123;...audioProps&#125; /&gt; 常用属性 属性 属性值类型 含义 autoplay autoplay 设置为自动播放 controls controls 展示音频播放的控制条 preload preload 音频预加载 如果使用 “autoplay”，则忽略该属性 loop loop 开启循环播放 src string 音频源 autoplay 自动播放音频文件在ios系统中无法实现自动播放的这个效果 User Control of Downloads Over Cellular NetworksIn Safari on iOS (for all devices, including iPad), where the user may be on a cellular network and be charged per data unit, preload and autoplay are disabled. No data is loaded until the user initiates it. This means the JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action. In other words, a user-initiated Play button works, but an onLoad=”play()” event does not. 简而言之 ios认为自动播放音频视频是不友好的行为 不想用户浪费过多的流量，禁止了自动播放的功能 所以即使你在标签中添加了 autoplay属性 在移动端也不会触发视频或者音频的播放 解决方案1 如果就是想要用户开启播放 可以为页面绑定一个 touchstart 点击事件 这样在页面点击的时候 触发此音频播放 1234document.addEventListener('touchstart', function () &#123; let audio = document.getElementById('audio') audio.play()&#125;) 解决方案2 虽然在浏览器中有此限制 但是在微信中却可以做到自动播放 Android 中可以使用 [ios 无效] 1234document.addEventListener('DOMContentLoaded', function () &#123; let audio = document.getElementById('audio') audio.play()&#125;) iOS 可以使用 [Android 也可以] 1234document.addEventListener("WeixinJSBridgeReady", function () &#123; let audio = document.getElementById('audio') audio.play()&#125;, false) src测试的时候使用了一首来自5sing的歌曲链接 1let src = 'http://data.5sing.kgimg.com/G106/M00/0A/0F/SpQEAFljNBqATRL-ADks3ezSCI8032.m4a' 然后发现无法播放 是由于audio不支持此格式的音频文件 audio只支持三种格式的音频文件 其实并非所有的浏览器都支持video与audio的所有的编码解码器 这就代表着有时候需要提供多个格式的资源 ja提供了一个 canPlayType 方法 来判断是否支持当前播放资源 canPlayType 参数为 某一种格式 或者 编解码器 返回值 ‘maybe’ ‘’ ‘probably’ 三种结果 1234let audio = document.querySelector('audio')// let canPlay = audio.canPlayType('audio/mpeg')let canPlay = audio.canPlayType('audio/m4a')console.log(canPlay) 创建实例其实还可以通过new 来创建一个 audio 实例 就类似于 Image 来创建 img 一样 123let src = 'https://os4ty6tab.qnssl.com/web/static/AllProjects/music-0c0d070d.mp3'this.audio = new Audio(src)this.audio.setAttribute('loop', 'loop') 这样就不必在页面中插入一个audio元素了 第三方视频插件其实原生的video标签有的时候无法满足UI需求 比如一般需要另行处理播放或者全屏按钮 可以看到页面元素中 下面控制条部分并没有被解析为标签元素展示 整个视频源和控制条都在一个video元素中展示 所以无法处理这些按钮 比如调整位置或者样式 video.js Video.js 是一个通用的在网页上嵌入视频播放器的 JS 库，Video.js 自动检测浏览器对 HTML5 的支持情况，如果不支持 HTML5 则自动使用 Flash 播放器 官网 npm Github 使用 1234videojs(videoID, &#123;&#125;, function()&#123; console.log(this) this.play()&#125;) 传入的参数是 属性 类型 含义 videoID string video标签元素的id option {} 标签参数 cb function 回调函数 其中的this表示为当前播放源 去看了源码 有这么一段 简化版 12345678910function videojs(id, options, ready) &#123; let tag; if (typeof string) &#123; tag = $(`#$&#123;id&#125;`) &#125; else &#123; tag = id &#125; ......&#125; 所以第一个参数那里 不只是可以传递 id 也可以直接传递 DOM节点 比如 1234videojs(document.querySelector('video'), &#123;&#125;, function()&#123; console.log(this) this.play()&#125;) 查看页面元素 可以看到 每一个部分都被解析为元素节点了 这样就可以调整按钮样式了 ** video.js 提供了在React中的使用方式 react-video 1234567891011121314151617181920212223242526272829303132import videojs from 'video.js'export default class VideoPlayer extends React.Component &#123; componentDidMount() &#123; let option = &#123; autoplay: true, controls: true, poster: `$&#123;this.props.video&#125;?vframe/jpg/offset/0`, sources: [&#123; src: this.props.video, type: 'video/mp4' &#125;] &#125; this.player = videojs(this.videoNode, option, function onPlayerReady() &#123; console.log('onPlayerReady', this) &#125;); &#125; componentWillUnmount() &#123; if (this.player) &#123; this.player.dispose() &#125; &#125; render() &#123; return ( &lt;div data-vjs-player&gt; &lt;video ref=&#123; node =&gt; this.videoNode = node &#125; className="video-js"&gt;&lt;/video&gt; &lt;/div&gt; ) &#125;&#125; 有一些坑请看程总文章 video.js文档笔记(videojs)]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>video</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2F2017%2F10%2F15%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 事件分为两部分，1 行为本身 2 事件绑定 行为本身鼠标事件 MouseEvent onclick 点击事件 不是单击 【这和在移动端中不同】 ondbclick [双击] mouseover mouseout mouseenter mousemove mouseleave contextmenu [鼠标右键] 禁止右键事件 document.oncontextmenu= function(e){ e.preventDefault?e.preventDefault():e.returnValue=false;}mousedown mouseup 系统事件 onload 加载 onunload 关闭 onscroll 滑动 onerror 加载失败 onresize 窗口变化 还有一个beforeunload 当浏览器窗口关闭之前 window.onbeforeunload=function(){ // 窗口关闭前的提示 var con = confim(‘确认关闭当前页面吗’); if(!con){ return false; }}键盘事件 onkeydown onkeyup onkeypress 表单事件 onfocus onblur onchange onselect 下拉选择 onsubmit 提交表单 onreset 重置 音频 oncanplay 音视频可以正常播放 AJAX onabort ontimeout onreadystatechange DOM2级事件独有的 jQuery中$(document).ready()的原理 DOMcontentload 当文档结构完毕 就触发 而window.onload 则是当全部加载完毕才触发此事件 即使没有给行为绑定方法，事件也是存在的1）DOM0级事件是元素身上的私有属性 2）DOM0级事件，当给同一个元素，同一个行为上绑定多个不同的方法的时候，后面的方法会“覆盖”前面的方法； 1）DOM2级事件是元素身上的公有属性，存放在元素所属的eventTarget这个类的原型上； 2）DOM2级事件，可以给同一个元素的同一个行为上绑定多个不同的方法； 事件绑定的两种方式 123oDiv.onclick = function()&#123;&#125;// 或者oDiv.addEventListener('click',fn) 当触发点击行为时，会把绑定的这个方法执行。 通过查看其原型，onclick 属于oDiv 的私有属性 addEventListener 通过proto会查找到 EventTarget这个类上 onclick 属于DOM 0级事件 addEventListener属于DOM 2级事件 1oDiv.onclick = function()&#123;&#125; 把匿名函数的定义部分当做一个值赋值给oDiv放入点击行为，是函数表达式 当触发元素的点击行为时，会执行对应绑定上的方法 不仅仅把绑定的方法执行了，浏览器还默认给这个方法传递了一个参数值 MouseEvent 鼠标事件对象 MouseEvent 鼠标事件对象 1 是一个对象，里面的属性是用来记录鼠标信息的 2 MouseEvent -》 UIEvent。》Event-》Object 3 MouseEvent 记录了页面唯一一个鼠标每次触发的相关信息。与到底在哪个元素上触发的事件无关 123456odiv.onclick = function () &#123; console.log(arguments) // 数组中是MouseEvent &#125;document.body.onclick = function (e) &#123; console.log(e) // MouseEvent&#125; 这两个输出的实际都是同一个MouseEvent 对象 关于事件对象的兼容问题4.1 事件对象本身的获取存在兼容问题 在IE678 中打印e 为undefined。 odiv.onclick = function (e) { console.log(window.e)}这样输出就有了。标准浏览器也可以输出，但是火狐会出错。所以获取事件对象 在标砖浏览器中，事件对象是浏览器传递的默认参数，可以通过设置形参e获取。但是IE678 没有给方法传递参数，无法通过e获取。我们需要通过window.e 获取 var EventTarget = e || window.e4.2 MouseEvent属性 clientX clientY 当前鼠标触发点距离当前屏幕左上角的距离 e.type 存储的是鼠标触发的行为类型 比如click e.keycode 以上两个无兼容性问题 e.target 事件源 当前鼠标触发的哪个元素。在IE678中不存在这个属性。打印是undefined。我们使用e.srcElement 来获取事件源 e.pageX e.pageY 触发点距离body左上角的距离 即第一屏 在IE678无此属性 通过e.clientX 加上scrollLeft模拟 123456odiv.onclick = function (e) &#123; e =e||window.e; e.target = e.target||e.srcElement; e.pageX = e.pageX||e.pageX+(utils.win('scrollLeft')); e.pageY = e.pageY||e.clientY+(utils.win('scrollTop')) &#125;; 阻止默认行为e.preventDefault 默认行为 比如a 标签 在点击时的默认跳转 链接1234aAs.onclick = function (e) &#123; e=e|| e.window.e; e.preventDefault? e.preventDefault(): e.returnValue=false;&#125; 或者使用 123aAs.onclick = function () &#123; return false;&#125; 或者在Html标签中 123&lt;a href="javascript:;"&gt;&lt;/a&gt;&lt;a href="javascript:void 0;"&gt;&lt;/a&gt;&lt;a href="javascript:void 1;"&gt;&lt;/a&gt; 6 keyboardEvent 键盘事件 oinput1.onkeyup = function (e) { console.log(e);}输出的是keyboardEvent 对象 常用属性 1 e.keyCode 键盘 上每一个键对应的ASII值 空格 space 32 回退键 backspace 0 回车 enter 13 删除 delete 46 四个方向键 上下左右 38 39 40 37 6 事件委托本质是对冒泡的应用 如果有多个元素都发生同一个事件，可以使用事件委托。 可以通过判断事件源来执行不同的方法。 7 DOM2级事件addEventListen removeEventListen other1 window.onload 在jq中 $(function(){……})// 或者$(document).ready(function(){……}) 阻止事件冒泡传播e.stopPropagation 在IE6 不兼容 处理兼容性 e.stopPropagation?e.stopPropagation():e.cancelBubble=true;]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建函数]]></title>
    <url>%2F2017%2F10%2F15%2F%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 回调函数 回调函数定义 这个函数以参数形式 传入别的函数进行使用 使用回调函数需要注意 1 回调函数的调用次数以及何时调用 不由自己决定 2 回调函数中this 默认为window ，但可通过call apply 改变this 指向 3 回调函数中参数 4 回调函数有无返回值 怎样封装一个函数1 根据函数功能，1 考虑是否需要传参 2 考虑是否需要返回值 2 封装过程，考虑浏览器的兼容问题 创建函数到目前为止，常用的创建一个函数，有两种方式 函数声明 函数定义表达式 在ES6中 新增了一种创建函数的方式 函数声明 1function add()&#123;&#125; 函数表达式 1var add = function ()&#123;&#125; 新增的定义方式 生成器函数声明 就是在funciton关键字后加了一个星号 function* add(){} 生成器函数表达式 1const add = function* ()&#123;&#125; 箭头函数 1(name)=&gt;&#123;console.log(name)&#125; 2 区别 几种方式的区别 1 使用函数声明的函数名不能被改变 而使用函数表达式定义的函数变量可以再被赋值 2 函数声明 会带来变量提升 所以可以在函数之前使用此函数 而函数表达式不可以 ( 变量提升存在于 es5 时代 )]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>练习</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function]]></title>
    <url>%2F2017%2F10%2F15%2FFunction%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 1 所有的函数数据类型都是Function 的实例 所有的对象，都是Object这个基类的实例 2 构造函数的三种身份 1 普通函数 2 构造函数 类 实例 原型 打交道 3 对象 就是普通对象，具有属性和方法两个特征 3 基类Object与函数类Function之间的关系 1 Function instanceof Object // true Function的一种身份是对象 ， 是Object的实例 2 Object instanceof Function //true Object是构造函数，函数都是Function的实例 3 Object.protorype 是Function.prototype 的上一级 4 Object.prototype 是 Function.proto的上一级]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-数据类型及其使用]]></title>
    <url>%2F2017%2F10%2F12%2Fredis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[redis 是目前流行数据库的一种 数据类型String、 Hash、 List、 set、 sotred set 字符串类型 哈希 列表 集合 有序集合 字符串字符串类型是Redis中最基本的数据类型 它可以存储任何形式的字符串 包括二进制数据 可以存储用户的邮箱 JSON对象甚至图片 一个字符串键最大能存储512MB 字符串类型是其他4种数据类型的基础 差别从某些角度来说 只是组织字符串的形式不同 比如 列表类型List 是以列表形式组织字符串 而集合类型Set则是以集合形式 Redis字符串命令用于管理Redis中的字符串值 基本使用方式如下 12let liveRedis = reqs('liveRedis')yield liveRedis.COMMAND(KEY_NAME) Redis 字符串命令设置 与 获取set 设置值setnx key不存在则设置其值get 获取值getset 设置并且将旧值返回mset 设置多个值msetnx key不存在时设置多个值mget 返回多个key值 1.1 set key value 设置指定key值 1liveRedis.set(name,'tom') 2.2 setnx key不存在时设置其值 1liveRedis.setnx(name,'tom') 将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 不做任何动作。 setnx -&gt; 『SET if Not eXists』(如果不存在，则 SET)的简写。 1.3 get key 获取指定key值 1liveRedis.get(name) 当键不存在时候 返回null 如果key 储存的值不是字符串类型，返回一个错误 1.4 getset 设置值并返回旧值 如果key不存在 返回null 1.5 mset 设置多个值 用于同时设置一个或多个 key-value 对 1MSET key1 value1 key2 value2 .. keyN valueN 1.6 msetnx 当key值不存在时 设置其值 用于所有给定 key 都不存在时，同时设置一个或多个 key-value 对 1MSETNX key1 value1 key2 value2 .. keyN valueN 所有 key 都成功设置，返回 1 。 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 1.7 mget key1 key2 ..获取所有指定建的值 对于不包含字符串值或不存在的每个键，返回特殊值 - nil 1liveRedis.mget(name , age ,habit ,valentines) 返回值为一个包含所有给定 key 的值的列表 2 设置值以及有效期 setex 设置key值 并以秒为单位指定过期时间psetex 设置key值 并以毫秒为单位指定过期时间 2.1 setex 在Redis键中的指定超时，设置键的字符串值 1SETEX KEY_NAME TIMEOUT KEY_VALUE 为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值 设置成功 返回值为OK 否则返回错误 注意 此命令以秒为单位设定过期时间 2.2 psetex 该命令类型与setex类似，但是使用毫秒指定过期时间 哈希 hashRedis以键值对的形式存储数据 而数据结构之一的哈希类型也是键值对形式存储数据 Hash类型适合存储对象 使用对象类别和ID构成键名 使用字段表示对象属性 而字段值则存储属性值 Hash存储了字段和字段值的映射 但是字段值只能是字符串 不支持其他数据类型 Redis 中每个 hash 可以存储 232 - 1 键值对 let liveRedis = reqs(‘liveRedis’) Redis hash命令设置1.1 HSET 哈希表中指定字段的进行赋值 HSET key filed value 设置一个用户信息 1hset let startT = yield liveRedis.hset('user', 'name','tom') hset的命令不区分插入和更新操作 这意味着修改数据不用事先判断字段是否存在来决定要执行的是插入还是更新操作 如果执行的是插入[之前该字段并不存在] 则返回的是1 如果执行的是更新[之前该字段存在] 则返回的是0 如果该键不存在 则会自动创建此键 1.2 HSETEX 字段不存在则设置其值 1HSET key filed value 与HSET命令一样，HSETEX同样会设置哈希表key的field字段值为value。但仅当field不存在才会设置。如果field字段已经存在，该操作无效 1.3 HGET 获取存储在哈希表中指定字段的值 1HGET key filed 返回哈希表key中field的值 获取到car字段的price属性 1let startT = yield liveRedis.hget('car', 'price') 1.4 HGETALL HGETALL key 获取存储在哈希表key中全部字段以及其值 1let info = yield liveRedis.hgetall('car') 一般在想要获取全部字段 又不知道有哪些字段时候使用 这个其实返回的不是很直观 不过在node中 可以将其处理为合适的对象格式 1234liveRedis.hgetall('car',function(error,car)&#123; // 已经将其封装为一个对象了 console.log(car.price)&#125;) 2 批量操作 2.1 HMSET 批量设置多个字段以及值 1HMSET key field value [field value ...] 将一个或多个field-value对设置到哈希表key。 如果要设置的field已存在，则会覆盖其值。如果哈希表不存在，首先会创建再执行HMSET操作。 2.2 HMGET 获取存储在哈希表中多个字段的值 1HMGET key field [field ...] 返回哈希表key中，一个或多个指定的定段。如果指定的字段在哈希表中不存在，则返回一个nil 比如 1let info = yield liveRedis.hmget('car', 'price', 'time', 'user') hlen 获取哈希表中字段的数量 HLEN KEY_NAME 哈希表中字段的数量。 当 key 不存在时，返回 0 1let len = yield liveRedis.hlen('car') ListRedis的列表类型List是有序的字符串列表。 LIST 内部使用双向链表实现 可以在其头部(左边)和尾部(右边)添加新的元素 而获取数据越位于链表两端的时候 速度就越快 操作列表元素时，如果是从链表的两头插入或删除元素，操作效率会非常高。即使列表中已存储了百万条数据，该操作也可以在常量短的时间内完成 比如在千万个数据的表中获取前后20个的速度与从具有100个的表中获取前后20个速度一样 不过使用链表的代价是通过索引访问元素比较慢 比如 将元素插入列表中间或是删除位于链表中间元素，那操作效率会非常的低 Redis List命令插入新元素1.1 LPUSH 向开始位置插入元素 LPUSH 1lpush key value [value...] 将一个或多个值value插入到列表key的开始位置 如果有多个value，那么从左到右依次插入列表 如果列表key不存在，首先会创建一个空列表再执行LPUSH操作 命令执行成功后，返回列表的长度 如果key存在，但不是List类型，会返回一个错误提示 1.2 如果列表存在则将元素插入表头 lpushx 1lpushx key value 将一个或者多个value插入列表头部位置 如果列表key存在且是List类型，则将值value插入到列表key的头部 如果列表key不存在，则无操作 1.3 将指定元素插入列表末尾 RPUSH 此命令同lpush类似 只不过是插入元素的位置不同 1.4 如果列表存在则将元素插入表尾 RPUSHX 1rpushx key value 取值2.1 LPOP 左侧弹出一个数值 2.2 RPOP 右侧弹出一个数值 2.3 获取列表元素个数 1LLEN numbers 当键不存在 则返回0 2.4 获取列表片段 1LRANGE key start end 它用来获取列表中某一片段 将返回此片段内所以的元素（包含两端的元素） Redis列表的起始索引为0 lrange 命令支持索引为负数 表示从右侧开始读取元素 1lrange user -2 -1 截取右侧第二个 到右侧第一个 所以获取列表中所有的值 使用 1lrange user 0 -1 然后注意start 与 stop的大小处理 如果start &gt; stop 则返回空列表 如果 stop 大于实际的索引 则只是返回所有的元素 2.5 通过索引获取列表中指定位置的元素 lindex 1lindex key index 删除列表中值3.1 LREM LREM key count val 删除列表中val的值 删除个数为count 返回删除的元素个数 Set 集合Redis中的集合(Set)类型类似于List类型 Set是无序列的 集合成员是唯一的，这就意味着集合中不能出现重复的数据。如果多次添加相同元素，Set中将仅保留该元素的一份拷贝 和List类型一样，我们可以对集合类型进行元素的添加、删除或判断元素是否存在等操作 1let liveRedis = reqs('liveRedis') Redis 集合命令1 添加元素 成员之间的操作sadd 添加元素srem 移除元素 1.1 sadd 往集合中添加元素 1sadd key member [member ...] 将一个或多个元素member添加到集合key中，如果要添加的元素在集合中已存在，那么该元素将被忽略 如果集合key不存在，那么包含元素member的集合会被创建 返回值 是被添加到集合中的新元素的数量，不包括被忽略的元素 1yield liveRedis.sadd("cars" ,"tout") 1.2 移除元素 1SREM key member [member ...] 返回值：被移除的元素数量；如果key不是集合类型，会返回一个错误 2 查询元素 scard 集合元素数smembers 返回集合成员sismember 判断元素是不是集合的成员 2.1 获取集合中元素数量 scard scard key返回值 是集合的数量。 当集合 key 不存在时，返回 0 1yield liveRedis.scard("cars" ) 2.2 SMEMBERS - 返回集合中成员 smembers keyRedis Smembers 命令返回集合中的所有的成员。 不存在的集合 key 被视为空集合 123liveRedis.sadd('followers','tom','jury','hell')let users = yield liveRedis.smembers('followers')// tom jury hell 2.3 SISMEMBER - 判断元素是否是集合的成员 1sismember key member 如果member是集合成员，返回1 如果不是集合成员或集合不存在，返回0 123liveRedis.smembers('followers')// tom juar huilet isM = liveRedis.sismember('fallowers','hui') // 1 项中使用案例 比如将某一天完成指定任务的用户存储在当天的key中 通过此命令可以判断当前用户是否已经完成了今日任务 3 集合之间的操作 sdiff 差集 A-Bsinter 交集sunion 并集 A+B 3.1 一个或者多个集合的差集 1SDIFF key [key ...] 返回值为 差集的成员列表 也就是 A-B 比如当前有集合A与B A中元素为 1 2 3 B中元素为 2 3 4 计算A与B的差集 SDIFF A B 返回值为1 如果命令为 SDIFF B A 则返回值为 4 3.2 对多个集合进行交集运算 1SINTER key [key ...] 返回值为交集的成员列表 3.3对多个集合进行并集运算 1SUNION key [key ...] Redis 有序集合(sorted set)Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis通过分数来为集合中的成员进行从小到大的排序 有序集合的成员是唯一的,但分数(score)却可以重复 sort set 和 LIST 类型在某些方面相似 两者都是有序的 两者艘可以获取某一范围的元素 但是两者的使用场景不同 1 LIST 更适合于实现‘新鲜事’或者‘新日志’ 而不是获取中间元素信息 2 sort set 的内部机制使其即使访问中间位置元素 速度也快 3 LIST 不能简单的更改元素位置 但是SORT SET可以简单的变动score来更改位置 4 SORT SET 比LIST耗费内存 1let liveRedis = reqs('liveRedis') Redis 有序集合命令添加 修改集合元素1 zadd 添加元素 1ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN Redis Zadd 命令用于将一个或多个成员元素及其分数值加入到有序集当中。 如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。 分数值可以是整数值或双精度浮点数。 如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。 当 key 存在但不是有序集类型时，返回一个错误 1liveRedis.zadd('user_votes',23,'tom',21,'meary') 查询2.1 zcard - 返回集合数量 zcard (key) 返回值：有序集合key的基数；当集合不存在时，返回0 1234liveRedis.zadd('user_votes',20,'tom2')let num1 = liveRedis.zcard('user_votes') // 1liveRedis.zadd('user_votes',29,'tom3')let num1 = liveRedis.zcard('user_votes') // 2 2.2 zrank 返回元素排名 ZRANK key member 返回有序集合key中的元素member的排名。元素成员按score值递增，相同score值的成员按字典排序。元素排名从0开始计数 显示所有成员及其 score 值 1ZRANGE keyname 0 -1 WITHSCORES 2.3 ZSCORE - 返回指元素的权重 ZSCORE key member返回有序集合key中，元素member的score值 2.4 ZCOUNT - 返回集合两个权重间的元素数 ZCOUNT key min max返回有序集合key，score值在min和max之间的元素数(包含值为min和max的元素) 2.5 ZRANGE - 返回指定区间内的元素 ZRANGE key start stop [WITHSCORES]返回有序集合key指定区间内的元素。元素成员按score值递增，相同score值的成员按字典排序。 start和stop都是从0开始。当使用负数时，表示从集合的末尾开始计数 WITHSCORES用于指定是否同时返回元素的score 2.6 ZREVRANGE - 倒序返回指定区间内的元素 ZREVRANGE key start stop [WITHSCORES]返回有序集合key中，指定区间内的成员。score值按倒序(从大到小)顺序排序 2.7 ZRANGEBYSCORE - 返回指定权重区间内的元素 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]返回有序集合key指定区间内的元素。元素成员按score值递增，相同score值的成员按字典排序。 可选参数LIMIT用于指定返回元素数量，offset用于指定便移量 移除元素3.1 ZREM - 移除元素 1ZREM key member [member ...] 移除有序集合key中的一个或多个元素member的排名，不存在成员将被忽略。 移除全部元素 1ZRANGE page_rank 0 -1 WITHSCORES 3.2 ZREMRANGEBYRANK - 移除指定区间内的元素 ZREMRANGEBYRANK key start stop移除有序集合key中，指定排名(rank)区间内的元素。 start和stop用于指定元素区间，start和stop包含在区间内。start和stop的底数以0开始，也可以使用负数，如-1表示最后一个元素，依次类推]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮播图]]></title>
    <url>%2F2017%2F10%2F11%2F%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 左右滑动banner1 追加第一个图片 改变盒子宽度 2 开启定时器 变化left 自动轮播图片 注意这里的边界判断 而且图片切换时间 要大于内部图片运动速度 不然看不到停顿效果的 3 焦点变化 4 鼠标悬停 5 焦点点击切换图片 焦点索引正好对着图片索引 6 左右按钮点击切换图片 向右点击 相当于执行一次定时器 向左点击注意进行边界判断 使用构造函数进行方法封装 1 变量转为私有属性 函数转为共有方法 2 时刻注意this指向问题 应该全部改为当前实例 3 使用init 表示执行顺序 4 思路 追加图片 变化宽度-》开启定时器 图片轮播 -》 焦点轮播-》鼠标悬停-》点击焦点 图片切换-》点击左右 图片切换 1 左右轮播 效果显示 2 左右轮播 数据获取 在线效果展示 核心JS代码展示 3 左右轮播 jQuery 在线效果展示 核心JS代码展示 Github项目地址展示 渐隐渐现 banner1 获取数据 解析数据 2 渲染页面 【 图片延迟加载 第一张图 渐现 】 3 开启定时器 切换图片 4 焦点切换 5 鼠标悬停 6 焦点点击 切换图片 7 按钮点击 切换图片 渐隐渐现 普通函数版本 在线效果展示 普通函数版本 普通函数JS核心代码展示 渐隐渐现 构造函数版本 在线效果展示 构造函数版本 构造函数JS核心代码展示 渐隐渐现+jQuery 渐隐渐现+jQuery在线效果展示 渐隐渐现+jQuery核心JS代码展示 渐隐渐现 es6+jq 渐隐渐现 es6+jq 在线效果展示 渐隐渐现 es6+jq 核心JS展示]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目组推荐]]></title>
    <url>%2F2017%2F10%2F10%2F%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[酷站推荐cssloading loading.io balloon vpnlantern 资源站点all]]></content>
      <categories>
        <category>推荐阅读</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划2]]></title>
    <url>%2F2017%2F10%2F08%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%922%2F</url>
    <content type="text"><![CDATA[work 调查问卷上线 留言墙上线 阅读 阅读笔记 山海经 可以写小段子 lift 英语单词]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply、bind]]></title>
    <url>%2F2017%2F10%2F07%2Fcall%E3%80%81apply%E3%80%81bind%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 call apply bind 这三个方法都是Function 函数类上的方法 callcall的作用：改变obj1中this指向 并执行call前面的函数obj1 1obj1.call(obj2) call 的应用2.1 前面的函数中没有this 相当于只是执行前面的函数 1234567function father()&#123; console.log('father')&#125;function son()&#123; console.log('son')&#125;father.call(son); // 控制台打印出father 2.2 前面的函数有this 12345function father()&#123; console.log(this);&#125;function son()&#123;&#125;father.call(son); // 控制台打印出 function son()&#123;&#125; 2.3 多个call 连续使用 123function f1()&#123;console.log('i am f1')&#125; ; function f2()&#123;console.log('i am f2')&#125; ;f1.call.call.call(f2) 相当于执行f2 函数 所以输出 i am f2 f1.call 是走到函数的定义阶段 applyapply使用和call 相同,只不过是在传入参数的使用的是数组 1f1.apply(f2,['tom',24]) apply的应用获取数组中最大值 2.1 sort 排序 2.2 假设法 2.3 利用apply 传参为数组这个特点 12var arys =[3,4,2,61,99];Math.max.apply(Math,arys) 2.4 eval 将字符串转为JS代码执行 数组与字符串进行拼接 会连接为新的字符串 1eval('Math.max('+ arys +')') bindbind 和call有点类似 改变this指向,传入参数，但是不执行函数。所以属于预处理机制。 1f1.bind(f2,'tom',24)]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiper.js]]></title>
    <url>%2F2017%2F10%2F07%2Fswiper-js%2F</url>
    <content type="text"><![CDATA[swiper 是一个很好的处理滑动的第三方插件 github地址 API 属性 属性 含义 fullScreen 是否支持全屏展示 animate 是否开启动画 speed 切换速度 loop 是否开启循环播放 direction 切换方向 autoplay 每一屏幕展示时间 autoplayDisableOnInteraction 是否继续保持用户行为 initialSlide 默认在开始的时候展示第几个实例 autoplayDisableOnInteraction 关于这个属性 就是当你开启了手势滑动或者键盘切换的时候 如果不设置此属性值为 FALSE 那么当你手动滑动之后 自动切换功能将会停止 也就是只能通过 手动触发滑动事件了 1autoplayDisableOnInteraction: false 此属性值设置为FALSE 表示可以当用户行为结束之后 继续自动切换效果 事件onSliderMove在滑动屏幕的时候 注意这个事件在通过键盘滑动切换的时候 并不会触发 onSlideChangeEnd 屏幕切换结束方法slideTo指定跳转到某一页实例 1mySwiper.slideTo(9, 75, runCallbacks) removeAllSlides移除所有实例 1mySwiper.removeAllSlides(); //移除全部 此方法将所有的实例删除 可以查看DOM树信息 会发现所有切换实例被移除 OtherDOM 元素解析查看页面元素发现 Swiper 将DOM树解析为包含 swiper-slide-prev swiper-slide-active swiper-slide-next 这三个比较重要的部分 包含 swiper-slide-active 类名的 表示处于激活状态的屏幕 onSlideChangeStart VS onSlideChangeEnd项目中一个swiper的切换banner之后获取新数据的需求 最开始的时候是把getData写到 onSlideChangeEnd 中 但是发现 如果快速滑动页面 swiper会丢失 onSlideChangeEnd 中注册的函数 不再执行 GIT中也有人反应这个bug onSlideChangeEnd丢失 然后我把方法注入 onSlideChangeStart 中 发现可以正确得到结果 不会丢失 v4 vs v3v4 在一些安卓机和部分iOS中 无法使用，建议使用v3]]></content>
      <categories>
        <category>第三方插件使用</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rn-下拉刷新]]></title>
    <url>%2F2017%2F10%2F05%2Frn-%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%2F</url>
    <content type="text"><![CDATA[PullToRefreshListView 提供了页面下拉刷新 上滑获取更多数据的功能 [GitHub 地址] (https://github.com/react-native-component/react-native-smart-pull-to-refresh-listview/) 其实提供了Android和iOS两种系统的刷新 如果你的项目只服务其中一种系统 可以只引入其中一个 12import AndroidPullToRefreshListView from './PullToRefreshListView-android'import IOSPullToRefreshListView from './PullToRefreshListView-ios' 安装1npm install react-native-smart-pull-to-refresh-listview --save code1234567891011121314151617181920&lt;PullToRefreshListView viewType=&#123;viewType&#125; enableEmptySections=&#123;true&#125; pagingEnabled=&#123;false&#125; contentContainerStyle=&#123;styles.listView&#125; dataSource=&#123;state.dataSource&#125; renderRow=&#123;renderRow&#125; renderHeader=&#123;this._renderHeader&#125; renderFooter=&#123;this._renderFooter&#125; onRefresh=&#123;this._onRefresh&#125; onLoadMore=&#123;this._onLoadMore&#125; autoLoadMore=&#123;true&#125; pullUpDistance=&#123;1&#125; pullUpStayDistance=&#123;35&#125; pullDownDistance=&#123;pullOkMargin&#125; pullDownStayDistance=&#123;defaultTopIndicatorHeight&#125; scrollRenderAheadDistance=&#123;windowHeight&#125; removeClippedSubviews=&#123;true&#125; pageSize=&#123;20&#125;/&gt; 属性解析1 viewType 2 dataSource 数据来源 3 renderRow 内置函数 123456789_renderRow = (rowData, sectionID, rowID) =&gt; &#123; return ( &lt;View style=&#123;styles.thumbnail&#125;&gt; &lt;View style=&#123;styles.textContainer&#125;&gt; &lt;Text&gt;&#123;rowData.text&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ) &#125; 这个函数是组件封装好的 默认接受三个参数 第一个参数是渲染的数据 可以直接使用 123let renderRow = (rowData, _, index) =&gt; &#123; return shouldHidden ? null : &lt;ListRow &#123;...props&#125; &#123;...rowData&#125; /&gt;&#125; 4 renderheader 下拉刷新时候展示的头部loading组件部分 这个是一个函数 返回值是一个组件 此组件将作为loading组件展示在头部 而关于下拉刷新的几个状态值 比如未下拉刷新 正在下拉 松手状态 刷新完毕状态 都可以获取到 12345678910_renderHeader = (viewState) =&gt; &#123; let &#123;pullState, pullDistancePercent&#125; = viewState let &#123;refresh_none, refresh_idle, will_refresh, refreshing&#125; = PullToRefreshListView.constants.viewState pullDistancePercent = Math.round(pullDistancePercent * 100) switch(pullState) &#123; case refresh_none : return &lt;Text&gt; 请下拉用以刷新页面 &lt;/Text&gt; ...... &#125;&#125; 可以看到几个状态值 全部保存在 PullToRefreshListView.constants.viewState 里面 5 renderFooter 同理 是在下拉获取更多的时候 在底部展示的组件 12345_renderFooter = (viewState) =&gt; &#123; let &#123;pullState, pullDistancePercent&#125; = viewState let &#123;load_more_none, load_more_idle, will_load_more, loading_more, loaded_all, &#125; = PullToRefreshListView.constants.viewState ......&#125; 则关于上拉的各种状态也是在PullToRefreshListView.constants.viewState中 6 autoLoadMore 是否开启上拉获取更多数据功能 默认值FALSE 7 关于处理下拉以及上滑的距离 1234pullUpDistance=&#123;1&#125;pullUpStayDistance=&#123;35&#125;pullDownDistance=&#123;pullOkMargin&#125;pullDownStayDistance=&#123;defaultTopIndicatorHeight&#125; 方法1 onRefresh 当下拉刷新的时候 触发此方法 2 onLoadMore 当上拉获取更多数据的时候 触发此方法 other 1 beginRefresh 相当于强制去执行一次下拉刷新 2 endRefresh 终止下拉刷新 3 endLoadMore 终止上拉获取更多数据 当开始执行下拉刷新 获取数据的过程 此时展示头部loading组件部分 当数据获取完毕 需要使用以上方法关闭loading状态 123 this._pullToRefreshListView.endRefresh()// 或者 this._pullToRefreshListView.endLoadMore(true) 如果不执行这个方法 加载状态会一直存在的]]></content>
      <categories>
        <category>第三方插件使用</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rn-swiper]]></title>
    <url>%2F2017%2F10%2F04%2Frn-swiper%2F</url>
    <content type="text"><![CDATA[RN 提供的react-native-swipe是一个swiper 滑动组件 GitHub地址 npm地址 安装1npm i react-native-swiper --save 基本使用123456789101112131415render () &#123; return ( &lt;Swiper style=&#123;styles.wrapper&#125; showsButtons=&#123;true&#125;&gt; &lt;View style=&#123;styles.slide1&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Hello Swiper&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide2&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;Beautiful&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;styles.slide3&#125;&gt; &lt;Text style=&#123;styles.text&#125;&gt;And simple&lt;/Text&gt; &lt;/View&gt; &lt;/Swiper&gt; )&#125; 参数解析 参数 说明 index 默认展示的面板的索引 loop 开启循环滑动 horizontal 水平滑动 设置FALSE 则垂直滑动 autoplay 开启自动循环 showButtons 展示按钮 其实是和一款js插件Swiper效果类似]]></content>
      <categories>
        <category>第三方插件使用</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native1]]></title>
    <url>%2F2017%2F10%2F04%2Freact-native1%2F</url>
    <content type="text"><![CDATA[本文搭建的是Mac环境的RN 环境搭建官网链接 安装所需模块按照官网中逐步安装即可 所有模块安装完毕 开始创建项目 1react-native init HelloWorld 这样就可以创建一个完成的RN项目 启动项目 在命令行中输入 1react-native run-ios 即可启动此项目 项目启动中bug在尝试启动项目中 一直报错 1‘boost/iterator/iterator_adaptor.hpp’ file not found 产生原因： 1* /Users/xxx/.rncache 中 boost_1_63_0.tar.gz， double-conversion-1.1.5.tar.gz， folly-2016.09.26.00.tar.gz， glog-0.3.4.tar.gz 等文件下载不完整 解决方案 删除 .rncache 后重新下载，或手动下载后放入 .rncache 中 可能是由于网络问题或者无法翻墙 导致此文件下载不完整 然后一旦此文件存在 后面的发现有这个 就不再去安装它了 所以你会发现 即使你把所有项目删掉重新来 也依旧显示这个错误 相关文章导读1 《RN 开发错误警告处理》 2 RN 课程自学 基础组件RN 的元素渲染与React不同 前者就是使用的普通HTML标签 而RN则是新的一套语义化更加明白的标签 Loading 123456&lt;ActivityIndicatoranimating=&#123;this.state.animating&#125;style=&#123;[styles.centering, &#123;height: 80&#125;]&#125;color='#000'size='large'/&gt; 其属性animating 表示是否显示loading图片 默认TRUE 显示color loading的颜色size 大小设置 属性值 可写 small large 不可以为数字或者其他 Button12345&lt;ButtononPress=&#123;this.onPressLearnMore&#125;title='click the button'color='#841584'/&gt; 属性 onPress 当点击的时候 执行此函数 其余属性 disabled 为TRUE 时候 则按钮不可点击color 按钮中字体颜色 Alert 弹出层123import &#123;Alert&#125; from 'react-native'---&lt;Button onPress=&#123;() =&gt; Alert.alert('you clicked the button') &#125;&gt; Image1234&lt;Image style=&#123;styles.logo&#125; source=&#123;&#123;uri: 'http://facebook.github.io/react/img/logo_og.png'&#125;&#125;/&gt; 注意这里的属性source 后面的URL 如果是http开头的 很可能在iOS上打不开 推荐使用https开头 listView展示数据列表 123456789101112131415constructor(props) &#123; super(props); var ds = new ListView.DataSource(&#123;rowHasChanged: (r1, r2) =&gt; r1 !== r2&#125;); this.state = &#123; dataSource: ds.cloneWithRows(['row 1', 'row 2']), &#125;;&#125;render() &#123; return ( &lt;ListView dataSource=&#123;this.state.dataSource&#125; renderRow=&#123;(rowData) =&gt; &lt;Text&gt;&#123;rowData&#125;&lt;/Text&gt;&#125; /&gt; );&#125; 最基本的使用方式就是创建一个ListView.DataSource数据源，然后给它传递一个普通的数据数组， 再使用数据源来实例化一个ListView组件，并且定义它的renderRow回调函数 这个函数会接受数组中的每个数据作为参数，去渲染每一行，返回一个可渲染的组件（作为listview的每一行） 属性参数解析 dataSource列表依赖的数据源 initialListSize 【number】指定在组件刚挂载的时候渲染多少行数据 用这个属性来确保首屏显示合适数量的数据，而不是花费太多帧逐步显示出来 onChangeVisibleRows [function]1(visibleRows, changedRows) =&gt; void 视野内可见的行的集合变化的时候调用此回调函数 visibleRows 以 { sectionID: { rowID: true }}的格式包含了所有可见行，而changedRows 以{ sectionID: { rowID: true | false }}的格式包含了所有刚刚改变了可见性的行 其中如果值为true表示一个行变得可见，而为false表示行刚刚离开可视区域而变得不可见。 pageSize 【number】每次事件循环（每帧）渲染的行数 renderFooter 【function】renderHeader 【function】1() =&gt; renderable 页头与页脚会在每次渲染过程中都重新渲染【如果提供了这些属性】 如果它们重绘的性能开销很大，把他们包装到一个StaticContainer或者其它恰当的结构中。页脚会永远在列表的最底部，而页头会在最顶部 renderRow 【function】(rowData, sectionID, rowID, highlightRow) =&gt; renderable 从数据源(Data source)中接受一条数据，以及它和它所在section的ID。返回一个可渲染的组件来为这行数据进行渲染。默认情况下参数中的数据就是放进数据源中的数据本身，不过也可以提供一些转换器。 如果某一行正在被高亮（通过调用highlightRow函数），ListView会得到相应的通知。当一行被高亮时，其两侧的分割线会被隐藏。行的高亮状态可以通过调用highlightRow(null)来重置 ListView.DataSource要更新datasource中的数据，每次都重新调用cloneWithRows方法 数据源中的数据本身是不可修改的，所以请勿直接尝试修改 clone方法会自动提取新数据并进行逐行对比（使用rowHasChanged方法中的策略）这样ListView就知道哪些行需要重新渲染了 cloneWithRows(dataBlob, rowIdentities)根据指定的dataBlob和 rowIdentities为ListViewDataSource复制填充数据。dataBlob即原始数据。需要在初始化时定义抽取函数（否则使用默认的抽取函数）。 rowIdentities是一个二维数组，包含了行数据对应的id标识符，例如[[‘a1’, ‘a2’], [‘b1’, ‘b2’, ‘b3’], …]。如果没有指定此数组，则默认取行数据的key。 注：此方法实际并没有复制数据。它只是重新创建一个datasource，然后将你指定的dataBlob传递给构造函数中指定的提取函数，因而会抛弃先前的数据。如果你希望保留先前的数据，则必须先自行进行新老数据的合并处理，然后再将合并后的结果作为dataBlob传递给此方法调用。 ScrollView 视图滚动属性解析 horizontal当此属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列 默认值为false showsHorizontalScrollIndicator bool当此属性为true的时候，显示一个水平方向的滚动条 scrollEventThrottle 【number】这个属性控制在滚动过程中，scroll事件被调用的频率（单位是每秒事件数量） 更大的数值能够更及时的跟踪滚动位置，不过可能会带来性能问题 默认值为0，意味着每次视图被滚动，scroll事件只会被调用一次 onScroll滚动是触发的方法 scrollEnabled bool当值为false的时候，内容不能滚动，默认值为true TouchableOpacity本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低。这个过程并不会真正改变视图层级 使用案例 123456&lt;TouchableOpacity onPress=&#123;this._onPressButton&#125;&gt; &lt;Image style=&#123;styles.button&#125; source=&#123;require('image!myButton')&#125; /&gt;&lt;/TouchableOpacity&gt; 项目调试当你的项目在模拟器中运行起来之后 需要对项目进行调试 针对于iOS开发 Developer Menu在模拟器中开启 Developer Menu 快捷键 com + D Chrome Developer Tools谷歌开发工具是大家非常熟悉的了 第一步：启动远程调试 Developer Menu下单击”Debug JS Remotely” 启动JS远程调试功能。此时Chrome会被打开 第二步：打开Chrome开发者工具 在该“http://localhost:8081/debugger-ui.”Tab页下打开开发者工具。打开Chrome菜单-&gt;选择更多工具-&gt;选择开发者工具 然后选择source 进行调试 other1 在调试模拟器的时候发现速度很慢 估计是在刷新页面的时候 误点击了commond + T 导致开启了slowe animation]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2]]></title>
    <url>%2F2017%2F10%2F01%2Fpm2%2F</url>
    <content type="text"><![CDATA[什么是pm2pm2 是一个带有负载均衡功能的Node应用的进程管理器 GitHub地址 安装1npm install -g pm2 还可以使用淘宝滤镜 1npm install -g pm2 --registry=https://registry.npm.taobao.org 使用 pm2 list 显示所有进程状态 pm2 start app.js 开始进程 – watch 监控变化并自动重启 pm2 stop 停止进程 pm2 stop 0 # 停止指定的进程 pm2 stop all # 停止所有进程 pm2 restart 重启进程 pm2 restart 0 # 重启指定的进程 pm2 restart all # 重启所有进程 pm2 reload all # 0秒停机重载进程 (用于 NETWORKED 进程) pm2 delete 杀掉进程 pm2 delete 0 杀死指定的进程 pm2 delete all 杀死全部进程 pm2 logs 查看日志 比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启]]></content>
      <categories>
        <category>服务端</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[留言反馈墙]]></title>
    <url>%2F2017%2F10%2F01%2F%E7%95%99%E8%A8%80%E5%8F%8D%E9%A6%88%E5%A2%99%2F</url>
    <content type="text"><![CDATA[可以看做一个不断滚动的banner墙 页面可见性用户在浏览器可以同时打开N个tab窗口，他看的永远只是一个tab，其他不是激活态（按API，应该是叫隐藏） 但是这些 hidden 起来的窗口 里面的数据还有内存还在一直处理 没有停止 比如视频会一直处于播放状态什么的 HTML5的Page Visibility (页面可见性) API有两个属性，一个事件 API 属性 属性值类型 document.hidden Boolean document.visibilityState hidden、visible、 prerender、 preview document.hidden 是一个只读的属性，返回一个布尔值标识当前页面是否hidden 事件 visibilitychange 123document.addEventListener('visibilitychange', function() &#123; console.log( document.visibilityState )&#125;) 如果想要在用户重新进入页面的时候获取到最新数据 可以在在监听到当前标签页被重新激活的时候 进行一个reload 12345document.addEventListener('visibilitychange', function() &#123; if (!document.hidden) &#123; window.location.reload() &#125;&#125;) 关于浏览器是否支持此属性 页面可见性API的所有属性以及事件，目前是需要添加私有前缀的 ms webkit 等 根据文字框的高度来自动改变字体的大小1234567891011for (var i = 12; i &lt; 140; i++) &#123; contHeight = target.offsetHeight if (contHeight &gt; boxHeight) &#123; // 当容器高度大于最大高度的时候，上一个尝试的值就是最佳大小。 target.style.fontSize = `$&#123;(i - 2)&#125;px` break &#125; else &#123; // 如果小于最大高度，文字大小加1继续尝试 target.style.fontSize = `$&#123;(i)&#125;px` &#125;&#125; 通过不断比较已经填充内容区域高度与文字框的高度 来确定文字字号大小 其实也有一个第三方插件 react-textfit 但是在测试中发现 在这个项目中并不是特别适合 npm地址 12345import &#123; Textfit &#125; from 'react-textfit'&lt;Textfit style=&#123;&#123;height: 300&#125;&#125; mode="multi" min=&#123;34&#125; max=&#123;100&#125;&gt; &#123;contents&#125;&lt;/Textfit&gt; 渐变透明阴影 这各部分本来直接使用的图片 之后复查代码的时候 感觉可以直接使用CSS的处理 css的渐变分为两种 线性渐变 linear gradients 与 径向渐变 radial gradients 这里需要用到的是linear gradients 从左到右 渐变 并且渐变色 透明度逐渐降低 1background: linear-gradient(direction, color1, color2); 默认情况下 第一个渐变参数 方向 为从上到下 从左到右 1background: linear-gradient(to right, red , blue); 指定角度 1background: linear-gradient(40deg, red , blue); 实现图例中的阴影渐变 12background: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));border-radius: 0.3rem 0 0 0.3rem； dangerouslySetInnerHTML由于文字框需要展示用户的留言部分 为了防止出现意外情况 （XSS攻击） 比如用户输入多个空格 需要原样展示用户留言 后者如果用户手动输入类似于代码的留言 比如 1&lt;script&gt;alert(window.NAME)&lt;/script&gt; 如果不做任何处理 那么当留言被读取进入服务器再展示出来 就能看到站点信息了 因此需要将留言进行净化处理展示 dangerouslySetInnerHTML ，它的 prop 值（ 一个对象而不是字符串 ）应该被用来表明净化后的数据 简单的说 他是用来 提供插入纯 HTML 字符串的功能 1dangerouslySetInnerHTML = &#123;&#123; __html: contents.replace(/\n/g, '&lt;br /&gt;') &#125;&#125; 关于 cross-site scripting (XSS)攻击： 简单点来说 就是非本站开发人员 通过各种方式注入影响项目功能或者获取站点信息的代码]]></content>
      <categories>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屏幕尺寸、分辨率等]]></title>
    <url>%2F2017%2F09%2F28%2F%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E3%80%81%E5%88%86%E8%BE%A8%E7%8E%87%E7%AD%89%2F</url>
    <content type="text"><![CDATA[项目中有遇到一个关于大屏幕适配的问题， 本来以为大屏幕的分辨率会很高，结果却只有 960 很是奇怪 尺寸 英寸常用的长度单位 有xxx英寸 英寸转化为厘米为 1英寸（inch）= 2.54厘米（cm） 而我们说的手机是xxx英寸的 这个长度指的是手机屏幕对角线的长度 你可以直接用尺子量出几厘米然后将其转化为英寸的单位 分辨率手机的分辨率一般是xxx px 比如iPhone5的分辨率是 320px 这里px是像素 因此分辨率的单位就是像素 比如我们平时使用的设计稿为 750px 这里就是在有750个像素中的UI设计 屏幕像素密度屏幕像素密度，即每英寸屏幕所拥有的像素数，英文简称PPI 注意 每英寸并不是每平方英寸的简称 这个英寸跟之前手机屏幕的尺寸一样，也是对角线的长度 屏幕像素密度就是一个对角线长度为1英寸的正方形内所拥有的像素数 屏幕像素密度，分辨率，屏幕尺寸的关系是什么 像素的大小是固定的吗iPhone 华为荣耀6手机参数 手机型号 实际尺寸 屏幕分辨率 屏幕像素密度PPI iPhone7 plus 5.5英寸 1920 * 1080 px 401 PPI 华为荣耀 5.2英寸 1920 * 1080 px 424 PPI 这两个手机的分辨率都是1920px*1080px。 但是，苹果手机的屏幕尺寸比华为荣耀7大了0.3英寸。而苹果手机的屏幕像素密度（PPI）却比华为荣耀7高 说明了同样的一英寸的长度，苹果手机用401个ppi来显示，华为只用了424个ppi来显示 同样是一英寸，同样都是像素，但是两个手机中每英寸屏幕像素个数却不同 我们知道，英寸是长度单位，它有固定的物理尺寸。那么问题就只能出在了像素身上。这说明，像素这个东西，在苹果手机上变小了。所以，像素这个东西能变大能变小。 (原文在这里)[http://www.jianshu.com/p/c3387bcc4f6e] 原文下面的讨论区也很有意思]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>分辨率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas]]></title>
    <url>%2F2017%2F09%2F27%2Fcanvas%2F</url>
    <content type="text"><![CDATA[之前写过一篇 canvas初识 简单使用了canvas进行图形绘制 canvas 绘制弧度三角 这个气泡的左下部分 是一个有弧度的三角 最开始是使用的一个图片来处理 后来想想 使用canvas应该也可以做到这个效果 主要是canvas的弧度处理 也就是画圆 ctx.arc(x, y, radius, start, end, boolean)这个方法是用来进行画圆的 参数解析 参数 含义 x , y 圆心 radius 半径 start 开始角度 end 结束角度 Boolean 顺时针或者逆时针 最后一个布尔值 默认FALSE 表示顺时针开始画画 半圆12ctx.arc(190, 190, 90, 0, Math.PI * 3, true)ctx.fill() 四分之一12ctx.arc(190, 190, 90, 0, Math.PI * 0.5, false)ctx.fill() 带有弧度的三角形1234ctx.arc(100, 100, 50, Math.PI, Math.PI * 1.5, false)ctx.lineTo(50, 50)ctx.lineTo(50, 100)ctx.stroke()]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一周计划]]></title>
    <url>%2F2017%2F09%2F25%2F%E4%B8%80%E5%91%A8%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[work调查问卷 已经提测 等待反馈中 吐槽墙知识点 canvas 弧度 处理对话框 服务器配置 防火墙 如何获取到IP地址 第三方插件 request-ip pm2 项目布置到服务器中 尺寸与分辨率 research webpack exif.js 处理照片上传之后的旋转角度 阅读计划web前端工程师的自我修养 第一遍读完 2017/09/28 山海经 – 南山卷]]></content>
      <categories>
        <category>一周计划</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG + CSS3动画实现文字描边]]></title>
    <url>%2F2017%2F09%2F24%2Fsvg%2F</url>
    <content type="text"><![CDATA[svg 定义SVG 是使用 XML 来描述二维图形和绘图程序的语言 1&lt;svg&gt;&lt;/svg&gt; stroke 属性 属性名 含义 stroke 用于设置线条颜色 stroke-width 线条粗细 stroke-opacity 线条不透明度 stroke-linecap 描边方式 stroke-linejoin 两个描边之间用什么链接 stroke-dasharray 虚线样式 stroke-dashoffset 定义虚线开始的位置 stroke-dasharray stroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列。 12stroke-dasharray="5,10,5"stroke-dasharray="5,5" 注意，和path不一样，这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度。 所以在上面的例子里，第二个路径会先做5个像素单位的填色，紧接着是5个空白单位，然后又是5个单位的填色。如果你想要更复杂的虚线模式，你可以定义更多的数字。 第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复 实例展示创建元素 12345&lt;svg width="100%" height="100"&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text"&gt; cancan &lt;/text&gt;&lt;/svg&gt; 控制CSS 123456789101112131415.text&#123; font-size: 64px; font-weight: bold; text-transform: uppercase; fill: none; stroke: #3498db; stroke-width: 2px; stroke-dasharray: 90 310; animation: stroke 6s infinite linear;&#125;@keyframes stroke &#123; 100% &#123; stroke-dashoffset: -400; &#125;&#125; 开启Animation动画 通过不断变动虚线开始的位置 来实现文字边线闪动 这样可以发现 视觉上的文字边界移动效果 如果创建多个重复元素 可以实现以下效果]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>svg</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-3]]></title>
    <url>%2F2017%2F09%2F21%2Fwebpack-3%2F</url>
    <content type="text"><![CDATA[当在命令行输入 webpack 发生了什么 执行脚本 bin/webpack.js 解析参数每次在命令行输入 webpack 后，操作系统都会去调用 ./node_modules/.bin/webpack 这个 shell 脚本。这个脚本会去调用 ./node_modules/webpack/bin/webpack.js 并追加输入的参数，如 -p , -w yargs 解析命令行参数通过第三方模块 yargs 来解析命令行参数 123var argv = require('yargs').argvconsole.log('hello ', argv.name) 可以在命令行输入 123$ hello --name=tom// 或者$ hello --name tom 解析 webpack 指令后面追加的与输出显示相关的参数（Display options） 比如命令行经常输入的 -w -color -hot 参数 webpack.config.js 中参数./node_modules/webpack/bin/convert-argv.js，是用来通过判断 argv 中参数的值决定是否去加载对应插件的功能 123456789101112131415if(argv.watch) &#123; options.watch = true;&#125;// other codeifBooleanArg("debug", function() &#123; ensureArray(options, "plugins"); var LoaderOptionsPlugin = require("../lib/LoaderOptionsPlugin"); options.plugins.push(new LoaderOptionsPlugin(&#123; debug: true &#125;));&#125;);// other codereturn options webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中 通过 optimist 将用户配置的 webpack.config.js 和 shell 脚本传过来的参数整合成 options 对象 1var options = require("./convert-argv")(yargs, argv) plugins 插件的加载在加载插件之前 webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 接着 optimist.argv 会被传入到 ./node_modules/webpack/bin/convert-argv.js 中，通过判断 argv 中参数的值决定是否去加载对应插件 12345678910111213141516171819ifBooleanArg("hot", function() &#123; ensureArray(options, "plugins"); var HotModuleReplacementPlugin = require("../lib/HotModuleReplacementPlugin"); options.plugins.push(new HotModuleReplacementPlugin());&#125;);ifBooleanArg("debug", function() &#123; ensureArray(options, "plugins"); var LoaderOptionsPlugin = require("../lib/LoaderOptionsPlugin"); options.plugins.push(new LoaderOptionsPlugin(&#123; debug: true &#125;));&#125;);ifArg("devtool", function(value) &#123; options.devtool = value;&#125;);return options; 至此当插件对象初始化完毕 option中包含了全部的参数设置 包括webpack.config.js 与 shell 命令行中的输入的参数 12345678&#123; entry: &#123;&#125;,//入口配置 output: &#123;&#125;, //输出配置 plugins: [], //插件集合(配置文件 + shell指令) module: &#123; loaders: [ [Object] ] &#125;, //模块配置 context: //工程路径 ...&#125; 然后options对象传到了下一个流程的控制对象 12345678var webpack = require("../lib/webpack.js")var compiler;try &#123; compiler = webpack(options);&#125; catch (e) &#123; ......&#125; lib/webpack.js 初始化 webpack 对象在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步 而这个时候，真正的 webpack 对象才刚被初始化，具体的初始化逻辑在 lib/webpack.js webpack 的实际入口是 Compiler 中的 run 方法，run 一旦执行后，就开始了编译和构建流程 不过在进行run之前 先判断是否配置watch参数 如果有则会开启 watch 线程 如果有配置此参数 则开启监听文件变化 12345678910// 回调函数function compilerCallback(err, stats) &#123;......&#125;if(firstOptions.watch || options.watch) &#123; ...... compiler.watch(watchOptions, compilerCallback); console.log("\nWebpack is watching the files…\n");&#125; else &#123; compiler.run(compilerCallback);&#125;]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-web工程师的自我修养]]></title>
    <url>%2F2017%2F09%2F10%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-web%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%2F</url>
    <content type="text"><![CDATA[Emmmmm… 很奇怪的书名~~ 这本书不是很具体讲某一个方面的技能点 而是分析了一下程序员的生存之路吧 指点作为一名程序员如何学习 展现 提升自我 简单记录几个笔记 chapter1一个基本的web栈由服务器 数据库 服务端编程语言 html css javascript 组成 用户量的大小 服务器承受压力的能力 软件对服务器计算要求 对服务器相应要求 等等因素 MEAN 一个完整技术栈 mongodb express angular node 这个如果对照我们的项目 使用就是 MySQL koa React node VPS Virtual private server 虚拟专用服务器 把一台物理服务器虚拟成多给我虚拟专用服务器的服务 每一个vps都可以分配独立的公网IP地址 运行独立的操作系统 拥有独立的磁盘空间 内存 CPU资源 进程 系统配置 勿在浮沙筑高台 每三个月就要更新学习计划 chapter4 野生程序员 Http 前端处理： 减少同一个域的http请求数目 减少每一个资源的体积 后台处理： 尽快相应请求 以及减少请求对于服务器的开销]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数预解释]]></title>
    <url>%2F2017%2F09%2F09%2F%E5%87%BD%E6%95%B0%E9%A2%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 1 预解释 var 和 function 2 函数操作过程，四步。 3 奇怪的预解释 js中的预解释什么是预解释js中，在代码执行前，带var 和function关键字是需要预解释的。 在当前作用域下，在JS代码执行之前，浏览器会对带var和带function的，进行提前声明或定义； var 和 function的预解释不同 var 声明变量的时候，只是发生了声明，而不会发生定义，即赋值 function关键字的预解释，声明和定义，在整个代码执行前，就已经将函数名存入内存并且给这个函数名进行了赋值。即将函数空间地址赋值给函数名， 函数的四个步骤1 形成私有作用域 2 形参赋值 3 变量预解释 4 代码从上到下执行 预解释是在私有作用域的私有作用域函数运行时会形成一个自己的私有作用域，预解释是在函数私有作用域进行的。 作用域链：当函数被调用的时候，会形成一个私有作用域， 我们看该私有作用域下，是否有私有变量A： 1）如果有私有变量A：那么该作用域中的A，都是私有变量，跟外界没有任何关系2）如果没有私有变量A：到上级作用域进行查找，如果没有，继续往上找，找到window全局作用域还没有的话，报错； 在私有作用域内有变量a，则与外界作用域无关 如果没有私有变量a,则到上级作用域进行查找 私有变量【两种】1 形参 2 带var的 堆内存和栈内存1 栈内存提供了代码的运行环境 里面保存基本数据类型的变量 运行环境： 包括私有作用域和全局作用域 2 堆内存保存引用数据类型的数据，其中对象以键值对形式保存，函数以字符串形式保存 关于带var 的和不带var 的如果是全局变量，无论是带不带var，都属于全局window 而带var的会进行预解释，不带var的则不进行预解释 内存释放 堆内存释放 123var a =['hi'];a=null; // 内存释放 栈内存释放 栈内存，是形成js代码的执行环境，也就是私有作用域和全局作用域。所以需要进行作用域的销毁。 全局作用域的产生是伴随浏览器而形成，所以当关闭浏览器，全局作用域自然销毁。 私有作用域一般情况下，当函数执行完毕就会被js的垃圾回收机制自动销毁。 特殊情况有两种分为，1 不销毁 2 暂时不销毁 不销毁状态： 函数内部有东西被外部变量占用 暂时不销毁：一般是内层函数执行完毕先销毁内层之后外层函数进行销毁 奇怪的预解释3.1 对于var在左侧的，只进行变量声明 3.2 已经声明过的，不会重复声明。但是可以进行赋值操作。 3.3 预解释阶段，函数优先级高于var 变量 3.4 自执行函数，不会进行预解释。只有执行到的时候，就是开始那个函数的四步操作 3.5 条件判断语句中，无论条件是否成立，都会进行预解释 3.6 return后面的语句不会进行预解释，但是return下面的，会进行预解释 Other 上级作用域只跟函数在哪里开辟内存空间有关，与在哪里执行无关 练习 6.1 123456var n=9;function fn()&#123; alert(n) var n=9;&#125;fn() 上面的结果输出值为 undefined。函数运行分析 1 函数运行时候，先解释关键字var和function的变量，方法中有var n=9; 所以会先对n进行定义，但是不进行赋值操作。这个过程是函数预解释。 2 函数预解释完毕，开始按代码顺序执行函数，执行到alert(n).此时变量n由于函数的预解释作用，已经进行了变量声明，但未赋值。所以此时输出为undefined 3 继续执行代码 var n=9; 此时完成变量赋值。 6.2 1234567891011var a=[23,48,98,666]; //1.私有作用域 2.形参赋值 3.预解释 4.代码从上到下的执行 function fn(a)&#123; a[0]=123;//【123,48,98,666】 console.log(a) a=[]; a[a.length]=456; console.log(a);//[456] &#125; fn(a);console.log(a); 6.3 12345678function fn()&#123;console.log('fn')&#125;function fn2()&#123; console.log(fn) fn = 2; return ; function fn()&#123;console.log('i am inner')&#125;&#125;fn2() 当执行fn2时候，会输出 1function fn()&#123;console.log('i am inner')&#125; 函数解释： 当fn2执行时，在函数内部形成作用域，作用域内发生了变量预解释。function关键字的预解释不但有声明，而且有定义，所以可以输出函数内部定义的fn，而不是全局变量中的fn es6let const 已经不存在预解释了]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>预解释</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[告别]]></title>
    <url>%2F2017%2F09%2F04%2F%E5%85%B3%E4%BA%8E%E5%91%8A%E5%88%AB%2F</url>
    <content type="text"><![CDATA[2017/09/01 去参加苏榭男友的葬礼 送别会去的人很多，有的人是因为苏苏的关系，我也是其中之一。 许多人生命的散场突如其来，意外比明天更早一步与他们相见。 很久之前为他们的爱情感动过，嗯，或者说，每一位和世俗目光对抗的勇者都是直接赞叹的。 “我会一直爱你，直到死亡将我们分开”]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>love</tag>
        <tag>告别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-2]]></title>
    <url>%2F2017%2F09%2F02%2Fwebpack-2%2F</url>
    <content type="text"><![CDATA[webpack 配置 – 监听文件变化 开启自动刷新 webpack’s Watch Mode配置 –watch 开启观察模式 添加一个用于启动 webpack 的观察模式的 npm script 1"watch": "webpack --watch", 当使用此命令 会监听到文件变动 webpack会自动重新打包编译文件重新生成bundle文件 当文件有变动的时候 会自动产生新的bundle文件 但是唯一的缺陷是无法刷新浏览器 因此页面的刷新还需要用户手动刷新 webpack-dev-serverwebpack-dev-server 提供了一个简单的 web 服务器，并且能够实时重新加载页面 webpack-dev-server主要是启动了一个使用express的Http服务器。它的作用主要是用来伺服资源文件 此外这个Http服务器和client使用了websocket通讯协议，原始文件作出改动后，webpack-dev-server会实时的编译，但是最后的编译的文件并没有输出到目标文件夹 你启动webpack-dev-server后，你在目标文件夹中是看不到编译后的文件的,实时编译后的文件都保存到了内存当中 12345devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true, port: 9000&#125; 以上配置表示在 localhost:9090 下建立服务，将 dist 目录下的文件作为可访问文件。 通过 通过CLI选项 来配置 webapck-dev-server也就是在命令行启动方式 1webpack-dev-server --hot --inline --open 那么webapck.config.js中配置如下 1234devServer: &#123; contentBase: path.join(__dirname, 'dist'), compress: true&#125; –open 表示自动开启一个浏览器去加载页面 直接在 webapck.config.js 中配合参数命令行中配置 1webpack-dev-server --open 那么webapck.config.js中配置如下 12345678910devServer: &#123; contentBase: path.join(__dirname, 'dist'), inline: true, hot:true, compress: true&#125;,plugins: [ new HtmlWebpackPlugin(&#123;template: './index.html'&#125;), new webpack.HotModuleReplacementPlugin()] 注意plugin中这里添加HMR插件 contentBase告诉服务器从哪里提供内容。只有在你想要提供静态文件时才需要 也就是本地服务器所加载的页面所在的目录 devServer.publicPath 将用于确定应该从哪里提供 bundle，并且此选项优先 默认情况下，将使用当前目录(所谓当前的目录就是在哪里运行webpack-dev-server这个命令的目录)作为提供内容的目录 但是你可以修改为其他目录 1contentBase: path.join(__dirname, 'public') compress表示一切服务都启用gzip 压缩 port默认监听端口，如果省略，默认为”8080“ inline设置为true，当源文件改变时会自动刷新页面 proxy属性值为 Object 如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。 比如当前项目 koa搭建 运行端口为 localhost:3000 然后你的route 有一个接口 12345router.get('/api/try', function * () &#123; this.body = &#123; code: 9999999999999999999 &#125;&#125;) 但是前端用webpack启动 打开的端口是 9090 那么如果想通过 /api/try 接口接受信息 就可以配置 proxy 123proxy: &#123; "/api": "http://localhost:3000"&#125; 这样如果你发的请求是 /api/xxx 可以被http://localhost:3000/api/xxx 接口捕获到 所以如果你的服务和页面是相同的接口 就不用配置proxy的 hot表示重新加载改变的部分，如果HRM失败则刷新页面 关于hot 以及 inline 参数 ‘inline’选项会为入口页面添加“热加载”功能，’hot’选项则开启“热替换HMR”功能，即尝试重新加载组件改变的部分（而不是重新加载整个页面） 如果两个参数都传入，当资源改变时，webpack-dev-server将会先尝试HRM（即热替换），如果失败则重新加载整个入口页面。 自动刷新 Automatic RefreshIframe mode这种刷新处理方式 在网页中嵌入了一个 iframe ，将我们自己的应用注入到这个iframe当中去，因此每次你修改的文件后，都是这个iframe进行了reload当资源改变的时候会重新加载 开启这种刷新方式只需要通过 http://localhost:8081/webpack-dev-server/index.html 来访问你的项目就可以 每次更改数据 页面将会开启自动刷新 页面中被插入一个 iframe 并且引入 live.bundle.js 文件 这个iframe页面会请求 live.bundle.js ,其中里面会新建一个 Iframe ，你的应用就被注入到了这个 Iframe 当中 live.bundle.js 中含有 socket.io 的 client 代码，这样它就能和 webpack-dev-server 建立的 http server 进行 websocket 通讯了，并根据返回的信息完成相应的动作 iframe 引起页面自动刷新的机制为 因为我们的访问此页面的时候加载了live.bundle.js，其具有websocket的client代码，所以当websocket-dev-server服务端代码发生变化的时候会通知到这个页面，这个页面只是需要重新刷新iframe中的页面就可以了 inline mode 命令行中使用 –inline webapck 配置文件中使用 设置inline: true [感觉webpackV1好像不支持这种处理方式] 每一个模式都是支持Hot Module Replacement的 在HMR模式下，每一个文件都会被通知内容已经改变而不是重新加载整个页面。因此，在HMR执行的时候可以加载更新的模块，从而把他们注册到运行的应用里面。 模块热替换(Hot Module Replacement)HMR 用于替换、添加或删除模块，无需重新加载整个页面 HMR 与 chunkhash 的问题 项目中有在输出项配置 filename 为 chunkhash 123output: &#123; filename: `[name]-[chunkhash:8].js`&#125; 这样使用webpack 启动项目是可以的 但是如果是通过 webpack-dev-server –hot –inline 就会一直报错 原来是 热更新(HMR)不能和[chunkhash]同时使用 chunkhash问题 12filename: `[name]-[hash].js`,chunkFilename: `[name]-[hash].js` HMR 的工作原理 在应用程序中置换模块的步骤 应用程序代码要求 HMR runtime 检查更新 -&gt; HMR 下载更新，然后通知应用程序代码 -&gt; 应用程序代码要求 HMR 进行处理去更新应用 -&gt;HMR runtime（异步）应用更新 在编译器中 编译器(compiler)需要发出 “update”，以允许更新之前的版本到新的版本。”update” 由两部分组成： 更新后的 manifest(JSON)一个或多个更新后的 chunk (JavaScript) manifest 包括新的编译 hash 和所有的待更新 chunk 目录。每个更新 chunk 都含有对应于此 chunk 的全部更新模块（或一个 flag 用于表明此模块要被移除）的代码。 编译器确保模块 ID 和 chunk ID 在这些构建之间保持一致。通常将这些 ID 存储在内存中（例如，使用 webpack-dev-server 时），但是也可能将它们存储在一个 JSON 文件中。 * 启用 HMR两种方式可以开启 webpack 的HMR 功能 上文已经提到过 命令行添加参数 –hot 直接在配置文件中修改并添加 HMR 配置plugin HotModuleReplacementPlugin 如果已经通过 HotModuleReplacementPlugin 启用了模块热替换(Hot Module Replacement)，则它的接口将被暴露在 module.hot 属性下面 参考文章1 webpack-dev-server问题 2 webpack 插件拾趣 (1) —— webpack-dev-server]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片上传]]></title>
    <url>%2F2017%2F08%2F31%2F%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[File 图片文件上传到本地通过input点击 选择图片上传 1234567changeInput = () =&gt; &#123; let input = document.getElementById('input') let src = input.files[0] // 这里拿到一个File对象 src = window.URL.createObjectURL(file) // 拿到Blob格式的图片了 就可以处理预览操作&#125; 上传到七牛项目中的有些图片被托管到七牛中 关于七牛的介绍请自行百度 我们的项目中封装的图片上传到七牛的方法 是传递一个File格式的参数 但是我们在前端获取的图片 确实是一个base64的格式]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>文件处理</tag>
        <tag>html5</tag>
        <tag>图片上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas,blob,file,base64格式的转换]]></title>
    <url>%2F2017%2F08%2F30%2Fcanvas-blob-file-base64%E6%A0%BC%E5%BC%8F%E7%9A%84%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[canvascanvas -&gt; DataURL这个可以使用 canvas本身提供的方法来处理 1canvas.toDataURL('image/png') canvas -&gt; blob这个可以使用 canvas本身提供的方法来处理 123canvas.toBlob((blob) =&gt; &#123;&#125;) 不过这个方法在iOS中不被支持 也可以借助一些第三方插件 JavaScript-Canvas-to-Blob base64base64 -&gt; blob12345678910function convertBase64UrlToBlob(urlData)&#123; var bytes = window.atob(urlData.split(',')[1]) //去掉url的头，并转换为byte //处理异常,将ascii码小于0的转换为大于0 var ab = new ArrayBuffer(bytes.length) var ia = new Uint8Array(ab) for (var i = 0; i &lt; bytes.length; i++) &#123; ia[i] = bytes.charCodeAt(i) &#125; return new Blob( [ab] , &#123;type : 'image/png'&#125;)&#125; 这里传入的参数 urlData 是base64格式的 但是是不带有头部的 因此在函数内部做了处理 window.btoa() 编码一个可能在传输过程中出现问题的数据 window.atob() 将使用window.btoa方法的数据进行解码 这两个方法的支持情况还不错 base64 -&gt; file将图片转化为file格式 其实是模拟了一个form表单的提交 但是这里需要将base64先转化为Blob格式 123456789101112131415161718function base64ToFile (base64) &#123; let form = new FormData() formData.append('photo', Base64UrlToBlob(base64)) formData.append('uid', uid) $.ajax(&#123; url: 'upload', type: 'POST', data: formData, processData: false, // 不处理数据 contentType: false // 不设置内容类型 &#125;).done((&#123;photoUrl&#125;) =&gt; &#123; // 得到截图上传到七牛的URL console.log(photoUrl) resolve(&#123;photoUrl&#125;) &#125;).fail(() =&gt; &#123; console.log('error') &#125;)&#125; 这里使用的append方法是FormData对象中的方法 通过FormData对象可以组装一组用 XMLHttpRequest发送请求的键/值对。它可以更灵活方便的发送表单数据，因为可以独立于表单使用。如果你把表单的编码类型设置为multipart/form-data ，则通过FormData传输的数据格式和表单通过submit() 方法传输的数据格式相同 DataURLDataURL 展示图片将DataURL 图片绘制在canvas中 12345let img = new Image()img.onload = () =&gt; &#123; canvas.drawImage(img)&#125;img.src = dataurl FileFile -&gt; dataUrlFile -&gt; Blob两种方式全部借助 FileReader 对象的方法 参见本站文章 《关于文件的那点事》]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>file</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack-1]]></title>
    <url>%2F2017%2F08%2F27%2Fwebpack-1%2F</url>
    <content type="text"><![CDATA[为什么使用webpack现在的应用大多是webAPP的形式 通常都是单页面应用 每一个视图异步加载文件信息 在页面初始化过程中 会加载很多的JavaScript代码 页面中所需的资源通过增量加载的方式运行到浏览器 那么在开发环境中如何很好的将这些碎片资源组织起来 更加优雅迅速的在浏览器中展现 就需要一个模块化系统的支持 模块化系统的演进模块系统主要解决模块的定义 依赖 导入 常用的模块系统12&lt;script src='./jquery.js'&gt;&lt;/script&gt;&lt;script src='./zeptojs'&gt;&lt;/script&gt; 这种是最原始的模块加载方式（将每一个js文件看做一个模块） 这种加载方式有很多不足之处 由于是暴露在全局作用域中 所以很容易造成变量冲突 文件的加载顺序是js文件引入顺序 开发人员需要处理模块与各个代码库的依赖关系 前端模块加载前端模块是需要加载到浏览器中 预想的加载方式有两种 一种为将所有模块打包为一个文件 一次性将其加载到页面中 但这种处理方式会导致流量浪费、初始化过程慢 或者每一个模块都单独请求 但是这样会导致请求次数发送或多 webpack 介绍 WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用 webpack 处理文件方式是 把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件 webpack 在命令行中打包项目 1webpack &#123;entry file&#125; &#123;build file&#125; 但是一般我们都是在项目中通过一个配置文件来将所需的webpack信息进行完整的配置 启动webpack在命令行执行编译命令 1webapck 这条命令会自动引用webpack.config.js文件中的配置选项 如果你不是在全局安装的 webpack 就需要另行指定路径 1./node_modules/.bin/webpack --config webpack.config.js 或者在package.json中配置 12"start": "webpack","dev": "webpack --config webpack.config.js" 命令行执行此命令后 可以看到有bundle文件生成 chunkchunk：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module webpack 基本配置在项目中新建 webpack.config.js 的文件 用于配置webpack 1module.export = &#123;...&#125; context 上下文1context: path.resolve(__dirname, "app") 绝对路径，用于从配置中解析入口起点(entry point)和 loader 默认值是当前目录 entry 入口Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到 bundle.js 入口文件 属性名 参数类型 entry String Array Object 123456789101112131415// Stringmodule.export = &#123; entry: './index.js'&#125;// Arraymodule.export = &#123; entry: ['./index.js', './main.js']&#125;// Objectmodule.export = &#123; entry: &#123; index: './index.js', home: './home.js' &#125;&#125; 当为数组时 向 entry 属性传入「文件路径(file path)数组」将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用 也就是 将所有的文件会打包到最后一个chunk文件中 123module.export = &#123; entry: ['./index.js', './main.js']&#125; 会发现dist中只会生成一个文件 当为对象格式时 Webpack会为每一个html生成一个 bundle 文件 这是应用程序中定义入口的最可扩展的方式 在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载 关于生成的 bundle 文件 发现如果文件中有代码变动 则这里的哈希值就会发生变化 表示webpack打包之后的bundle.js文件也变化了 vendor分离第三方应用 123456module.export = &#123; entry: &#123; vendor: ['jquery', 'react', 'redux'], home: './home.js' &#125;&#125; 分离第三方应用主要是因为vendor.js 的内容基本上很少更新，所以如果下一次更改了 app.js 的内容时，vendor.js 仍然在浏览器的缓存中，那么用户就只需要重新下载 app.js 就可以了 注意如果这里配置了vendor属性 需要在plugins只能怪添加 1234new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', filename: 'vendor-[hash].min.js',&#125;) 但是 在测试中发现 虽然vendor中的是第三方代码 不经常更新 但是每次有其余代码更新 都会生成一个新的vendor文件 哈希值发生变化 关于此问题的讨论 然后将配置文件修改为 1234567891011121314entry: &#123; vendor: ['react', 'react-dom'], index: path.resolve('views')&#125;,output: &#123; path: path.resolve('public'), filename: `[name]-[chunkhash:8].js`, chunkFilename: `[name]-[chunkhash:8].js`&#125;,plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: ['vendor', 'manifest'], &#125;) ] manifest是为了解决vendor再次编译的问题 公共文件被编译为vendor.js 并且不再变化 但是还会生成一个manifest.js 这个会一直有哈希值变化生成新文件 注意 如果此时有在plugin中配置热加载 1new webpack.HotModuleReplacementPlugin() 就会发现一直报错 是因为在 热更新(HMR)不能和[chunkhash]同时使用 所以可以把 HMR 注释掉 output 输出webpack的输出配置 控制 webpack 如何向硬盘写入编译文件 即使可以存在多个入口起点，但只指定一个输出配置。 123456module.export = &#123; output: &#123; path: path.resolve('dist'), filename: 'bundle.js' &#125;&#125; path此选项规定了文件被写入硬盘的位置 也可以采用绝对路径的方式 1path: path.resolve(__dirname, 'dist') filename进行文件的命名 12345678entry: &#123; home: "./home.js", server: "./server.js"&#125;,output: &#123; path: 'build', filename: '[name].js'&#125; 如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称 [name] 被 chunk 的 name 替换 也就是entry的对象键名 则生成的文件为 1build/home.js 与 build/server.js name], [id] and [hash]如果考虑缓存问题，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变） webpack可以把一个哈希值添加到打包的文件名中，将特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前 1234output: &#123; path: 'build', filename: '[name]-[hash].js'&#125; publicPath通常用来进行开发者模式与正式环境的路径替换 12345output: &#123; path: path.resolve(__dirname, '../dist'), publicPath: isDev ? 'http://localhost:9333/' : '/', filename: '[name].bundle.js'&#125; 比如在本地开发者模式中 加载一个图片的方式为 123.bg&#123; background: url('../img/webpack/bg.png')&#125; 但是在正式环境中 路径可能是CDN的路径 所以需要对文件中的路径进行修改 因此借助环境变量 来处理此问题 12345678// 如果当前是生产模式，使用前者，否则[也就是本地开发者模式]使用localhost:3000const ASSET_PATH = isProd ? `$&#123;QNCDN&#125;/project/` : 'http://locahost:3000'export default &#123; output: &#123; publicPath: ASSET_PATH &#125;&#125; 此属性 有默认值 为’’ 1publicPath: '' publicPath参数跟path参数的区别是：path参数其实是针对本地文件系统的，而publicPath则针对的是浏览器； 因此，publicPath既可以是一个相对路径，如示例中的’’，也可以是一个绝对路径如http://www.xxxxx.com/。 一般来说，我还是更推荐相对路径的写法，这样的话整体迁移起来非常方便。那什么时候用绝对路径呢？其实也很简单，当你的html文件跟其它资源放在不同的域名下的时候，就应该用绝对路径了，这种情况非常多见于后端渲染模板的场景 chunkFilenamechunkFilename 参数指定的是除入口文件外的chunk（这些chunk通常是由于webpack对代码的优化所形成的) 123chunkFilename: `[name]-[chunkhash:8].js`// 或者chunkFilename: `[name]-[hash].js` module &amp;&amp; loaders 模块加载器决定了项目中如何处理不同类型的模块 loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件 loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！ 简而言之 loaders 用以将浏览器无法解析的 全部转化为可解析的代码 基本使用123456rules: [ &#123; test: /\.css$/, use: ["style-loader", "css-loader"], &#125;] loader 会以数组逆序运行。这意味着 css-loader 会在 style-loader 之前运行 处理stylecss-loader 和 style-loader，二者处理的任务不同 css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能 style-loader将所有的计算后的样式加入页面中，二者组合在一起使能够把样式表嵌入webpack打包后的JS文件中 css-loaderstyle-loaderpostcss-loader可以自动补全css中那些兼容性前缀 github 配置Module 1234567891011module: &#123; rules: [ &#123; test: /\.scss$/, use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: ['css-loader', 'postcss-loader', 'sass-loader'] &#125;) &#125; ]&#125; 因为我的项目中是将CSS与js抽离开的 所以使用了 ExtractTextPlugin 如果你不需要这么做 可以直接配置 12345678module: &#123; rules: [ &#123; test: /\.scss$/, use: ['style-loader', 'css-loader', 'postcss-loader', 'sass-loader'] &#125; ]&#125; 但是需在目录中添加一个文件 postcss.config.js 内容为 12345module.exports = &#123; plugins: [ require('autoprefixer') ]&#125; 这样就可以成功的添加样式各种浏览器前缀了 关于参数 这里可以传入一个对象作为参数 用于指定哪些浏览器来使用postcss 1234567module.exports = &#123; plugins: [ require('autoprefixer')(&#123; browsers: ['last 2 versions', '&gt; 5%', 'last 5 iOS versions', 'Android &gt;= 3'] &#125;) ]&#125; 如果不在这里写 还可以配置在package.json 中 添加支持哪些浏览器 12345678"browserslist": [ "defaults", "not ie &lt; 11", "last 2 versions", "&gt; 1%", "iOS 7", "last 3 iOS versions"] 坑 网上有的文章是将 autoprefixer 配置在 plugin中 这样写的 1234567require('autoprefixer')// 或者是添加一个对象参数require('autoprefixer')(&#123; browsers: ['last 2 versions', '&gt; 5%', 'last 5 iOS versions', 'Android &gt;= 3']&#125;) 但是我没有调试出结果来 所以采用了 添加 postcss.config.js 文件的形式 配置 module.rules创建模块时，匹配请求的规则数组 这些规则能够修改模块的创建方式 这些规则能够对模块(module)应用加载器(loader)，或者修改解析器(parser) 允许你在 webpack 配置中指定多个 loader 123456module: &#123; rules: [ &#123; test: /\.css$/, use: 'css-loader' &#125;, &#123; test: /\.ts$/, use: 'ts-loader' &#125; ]&#125; 或者 使用多个loader解析同一个类型的文件 use 这里就可以配置数组 12345678910111213141516module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; modules: true &#125; &#125; ] &#125; ]&#125; 如何编写loader 处理图片123456789101112&#123; test: /\.(gif|png|jpe?g|svg)$/, include: path.resolve(__dirname, 'component'), use: [ &#123; loader: 'file-loader', options: &#123; name: `[name]-[hash:8].[ext]` &#125; &#125; ]&#125; 然后图片格式就成了这样子了 配置 module.noParse防止 webpack 解析那些任何与给定正则表达式相匹配的文件 忽略的文件不应该被 import, require, define 或者任何其他导入机制调用 用这个忽略大型库文件(library)可以提高构建性能 123module: &#123; noParse: /jquery|backbone/&#125; resolve 配置模块如何解析 解析规则也可以称之为检索，索引规则 配置索引规则能够缩短webpack的解析时间，提升打包速度 123resolve: &#123; modules: [path.resolve(__dirname, "src"), "node_modules"]&#125; 首先指定了我们自己的源文件目录，然后是 node_modules。这样子 Webpack 解决起来就会处理得更好一些，按照那个顺序先找我们的源文件目录，然后是已安装的 Node Modules modules webpack 解析模块时应该搜索的目录 可以使用绝对路径和相对路径 如果使用相对路径将类似于 Node 查找 ‘node_modules’ 的方式进行查找 也就是现在当前文件中查找 然后去父级查找 层层向上查 如果使用绝对路径，将只在给定目录中搜索 默认值是 node_modules 表示从 node_modules 文件夹中搜索所有组件中引入的模块 1modules: ['node_modules'] 手动添加到数组中 1modules: [path.resolve(__dirname, 'src'), 'node_modules'] extensions123resolve: &#123; extensions: ['.js', '.jsx']&#125; 配置此属性 则可以在项目中 引入模块的时候 省略后缀名 因为webpack会根据这里配置的数组作为后缀 分别进行匹配 比如引入 jQuery.js 可以忽略后缀 .js 直接写 1import $ from 'jquery' alias配置别名 在引入模块的时候 就可以使用更加简单的方式 例如 1import Utility from '../../src/utilities/utility' 可以在alias中 配置好路径 然后 组件中使用别名 123alias: &#123; Utilities: path.resolve(__dirname, 'src/utilities/utility')&#125; 模块引入 1import Utility from 'Utilities' 项目中使用到别名的案例: 通过环境变量的不同 来区分引入模块 12345alias: &#123; 'react': needReact ? path.resolve(__dirname, `../node_modules/react/dist/react$&#123;isProd ? '.min' : ''&#125;.js`) : path.resolve(__dirname, `../node_modules/preact-compat/dist/preact-compat$&#123;isProd ? '.min' : ''&#125;.js`),&#125; 这样在项目中模块引入是相同的 1import React from 'react' mainFiles属性值为数组格式 表示解析目录时要使用的文件名 默认值为 index 1mainFiles: ['index'] 一般我们都是默认是index 所以想要引入某一个组件 可以使用 1import main from './components' 不用具体书写为 1import main from './components/index' 如果你想使用main 来作为默认的文件名 1mainFiles: ['main'] 插件(Plugins)属性值为数组格式 数组元素是通过new 创建出来的每一个实例 表示 webpack 使用的插件列表 1234plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;)] CommonsChunkPlugin当多个 bundle 共享一些相同的依赖，CommonsChunkPlugin 有助于提取这些依赖到共享的 bundle 中，来避免重复打包 1234567plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: "common", filename: "common.js", minChunks: 2 &#125;)] 在 output 的文件里，如果有任意模块加载了两次或更多（通过 minChunks 设置该值），它就会被打包进一个叫 commons.js 的文件里，后面你就可以在客户端缓存这个文件了 当然，这肯定会造成一次额外的请求，但是却避免了客户端多次下载相同库的问题。所以在很多场景下，这都是提升速度的举措 常用的webpack插件列表 source map多个文件打包到一个bundle文件中 只要其中一个出错 控制台的错误提示都将指到编译后的 bundle文件 source map 可以追踪代码错误 准确地知道错误来自于哪个源文件 需要配置 devtool 属性 1devtool: 'inline-source-map' 当没有配置devtool 属性的时候 倘若文件中有错误 则提示很粗暴 当配置了此属性 则可以明确指出错误文件位置 其实一般在生产环境 可以关掉 source map 1devtool: isProduction ? null : 'inline-source-map' 常用的属性值 属性值 含义 source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包速度 cheap-module-source-map 在一个单独的文件中生成一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便 eval-source-map 使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定不要启用这个选项 cheap-module-eval-source-map 这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点 HtmlWebpackPlugin没用 html-webpack-plugin 插件之前 我们需要在html文件中手动引用我们之前经过webpack打包好的js文件 而此插件会自动生成html文件并将打包好的js插入文件 HtmlWebpackPlugin 简化创建服务于 webpack bundle 的 HTML 文件，尤其是对于在文件名中包含了 hash 值，而这个值在每次编译的时候都发生变化的情况 可以让这个插件来帮助你自动生成 HTML 文件 12345678910module.exports = &#123; entry: &#123; index: './index.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js' &#125;, plugins: [new HtmlWebpackPlugin()]&#125; 执行相应命令后 在dist文件中生成一个 index.html 以及 index.bundle.js 文件 其中 index.html已经引入了script文件 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Webpack App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="index.bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果配置多个入口文件呢 1234entry: &#123; index: './index.js', server: './server.js'&#125; 会发现所有文件都被引入了 1&lt;script type="text/javascript" src="index.bundle.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="server.bundle.js"&gt;&lt;/script&gt;&lt;/body&gt; 属性配置 属性 含义 属性值 title 用来生成页面的 title 元素 无 filename 输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录 无 template 模板文件路径，支持加载器，比如 html!./index.html 无 inject 注入所有的资源到特定的 template 或者 templateContent 中，如果设置为 true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部，’head’ 将放置到 head 元素中 {true / ‘head’ / ‘body’ / false} favicon 添加特定的 favicon 路径到输出的 HTML 文件中 无 minify 传递 html-minifier 选项给 minify 输出 {} / false hash 如果为 true, 将添加一个唯一的 webpack 编译 hash 到所有包含的脚本和 CSS 文件，对于解除 cache 很有用 true / false cache 如果为 true, 这是默认值，仅仅在文件修改之后才会发布文件 true / false showErrors 如果为 true, 这是默认值，错误信息会写入到 HTML 页面中 true / false chunks 允许只添加某些模块 从entry 中定义的入口文件中选择 无 chunksSortMode 允许控制块在添加到页面之前的排序方式 ‘none’ / ‘default’ / {function}-default:’auto’ excludeChunks 允许跳过某些块，(比如，跳过单元测试的块) 无 使用案例 指定title 以及模板 1new HtmlWebpackPlugin(&#123;title: 'new html title', template: './index.html'&#125;), 如果有多个单页面 需要配置多个 HtmlWebpackPlugin 实例 12new HtmlWebpackPlugin()new HtmlWebpackPlugin(&#123;title: 'new html title', template: './server.html'&#125;), 可以自己创建模板文件 12345new HtmlWebpackPlugin(&#123; title: 'default template', template: 'myself.html', inject: 'body'&#125;) 编译 myself.html 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-type" content="text/html; charset=utf-8"/&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 延伸阅读 chunk当指定了chunks属性，webpack会按照这个属性定义的数组，将数组中所有片段完成打包，并用script标签将打包的js插入到生成的页面中，没有在数组中的片段，则不插入页面 比如你的入口文件中有三个 但是只想让其中一个被打包引入文件 就可以使用chunk属性 123456789101112entry: &#123; index: './index.js', server: './server.js'&#125;......plugins: [ new HtmlWebpackPlugin(&#123; chunks: ['server'], title: 'cancan', template: './index.html' &#125;)] title有一个奇怪的问题 当我同时指定title 和 template [不是那种自己写的模板] 之后 这里书写的title值将失效 也就是当你指定了 template 的时候 编译之后的模板使用的将是初始模板中的title 即使这里重新指定title也是无效的 还有一个title失效问题 如果使用自己写的模板 12345new HtmlWebpackPlugin(&#123; title: 'default template', template: 'myself.html', inject: 'body'&#125;) 发现无法正确解析title部分 原因是webpack.config.js的配置文件里面加了 html-loader，加了之后会正常解析html文件作为模版，就会直接把 &lt;%= htmlWebpackPlugin.options.title %&gt; 解析成字符串 如果有html-loader, 去掉就可以了 所以使用别的模板进行解析 hash1hash: true 设置了此属性为true 则在编译之后的文件中 引入的外部文件会加上哈希值 1&lt;script type="text/javascript" src="server.bundle.js?81641f9e16cafa3fb408"&gt;&lt;/script&gt;&lt;/body&gt; minify1234minify: &#123; removeComments:true, //移除HTML中的注释 collapseWhitespace:true //删除空白符与换行符&#125; 配置里的hash属性虽然可以给html引入的所以css文件后面加hash字符串，可以达到清除缓存的效果，但缺点是有些不需要清除缓存的css文件它也清除了 因为每次编译它会给所有css文件加同样的hash字符串。即时其他css没有变化。所以推荐用extract-text-webpack-plugin插件在编译提取css属性的时候用contenthash配置一下就可以解决这个问题 Babelbabel-loader的功能就是将项目中使用到ES6或者jsx的代码转化为es5,并且会把项目中所有的js文件都进行转化一遍，其中包括node_modules文件里面的内容 如果直接在webpack中配置babel 123456789module: [ &#123; test: /\.js$/, use: [&#123; loader: 'babel-loader', options: &#123; presets: ['es2015', 'react'] &#125; &#125;], &#125;] 但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中 如果不在webpack中写入babel的options部分 则webpack会自动调用.babelrc里的babel配置选项 12345678module: [ &#123; test: /\.js$/, use: [&#123; loader: 'babel-loader' &#125;], &#125;] 一个简单的 .babelrc 文件 1234567891011&#123; "presets": [ "es2015", "stage-0", "react" ], "plugins": [ ["import", [ &#123; "libraryName": "antd", "style": "css" &#125;, &#123; "style": "css","libraryName": "antd-mobile" &#125; ] ] ]&#125; 这里控制台可能会报错 根据api 需要安装一个模块 1npm i babel-plugin-import]]></content>
      <categories>
        <category>前端自动化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-hammer]]></title>
    <url>%2F2017%2F08%2F27%2Freact-hammer%2F</url>
    <content type="text"><![CDATA[react-hammer是一个帮助实现移动端拖拽效果的插件 npm Github 其实React-hammer是基于hammer.js 构建而成的一个更适合在React中使用的触摸插件 使用123let Hammer = require('react-hammerjs')&lt;Hammer onTap=&#123;handleTap&#125; options=&#123;options&#125;&gt;&lt;div&gt;Tap Me&lt;/div&gt;&lt;/Hammer&gt; 六种手势支持react-hammer.js 支持六种手势操作 事件 手势 pan 单手指滑动 tap 单手指点触 doubleTap 单手指双击 pinch 两个手指进行缩放动作 press 单手指下压 rotate 双手指旋转 swipe 单手指滑动 默认状态下 是无法进行pinch 与 rotate 操作的 需要手动将其设置为TRUE As a default, the pinch and rotate events are disabled in hammer.js, as they would make actions on an element “blocking”. 12345678910let options = &#123; recognizers: &#123; pinch: &#123; enable: true &#125;, rotate: &#123; enable: true &#125; &#125;&#125;&lt;Hammer options=&#123;options&#125; &gt; &lt;p&gt;&#123;text&#125;&lt;/p&gt;&lt;/Hammer&gt; 这样才能进行缩放以及旋转动作 事件对象每一个事件的回调函数中都有一个事件对象 包含以下属性 (展示部分常用属性) 事件对象 含义 type 事件类型 deltaX X轴方向移动 deltaY Y轴方向移动 distance 移动距离 direction 移动的方向 srcEvent 事件来源 rotation 多点触摸时已经完成的旋转（deg） eventType 事件类型，匹配INPUT常量 pan 单手滑动 事件 含义 pan 单手指滑动 整个滑动周期 panstart 开始滑动 panmove 滑动 panend 滑动结束 pancancel 滑动取消 默认只能进行水平方向的滑动 无法处理垂直方向的滑动 因此需要手动添加属性 direction npm 中这样说道 If you provide the prop direction the pan and swipe events will support Hammer.DIRECTION_(NONE/LEFT/RIGHT/UP/DOWN/HORIZONTAL/VERTICAL/ALL). 因此我就这么写的 123&lt;Hammer direction=&#123;DIRECTION_ALL&#125;&gt; ...&lt;/Hammer&gt; 然而并没有效果 之后查看issue 发现实际是这么处理 123&lt;Hammer direction='DIRECTION_ALL'&gt; ...&lt;/Hammer&gt; 关于 pancancel 个人感觉应该是在快速拖动导致手势丢失的时候 会触发此事件发生 然而测试中并没有发现有什么用 因为一直会被 panend 被捕捉而不是 pancancel 拖拽此函数会一直被执行 从整个滑动开始 正在滑动 滑动结束 元素跟随手指滑动变动位置的原理是 获取元素初始位置 + 手指滑动距离 然后在手指抬起瞬间 更新元素初始位置 1let eleLeft = startX + deltaX 结束手指滑动时候 更新元素位置 之前一直是在 Panend 中处理这个问题 但是发现实际页面拿到的left数据 一旦发生一次滑动结束 再次滑动的时候 里面的值就是undefined 调试很久之后 将事件处理到 pan 事件中 通过监听事件对象的 eventType === 4 来判断词此时是要结束滑动 然后更新元素初始位置 有一个坑 当手指离开屏幕 也就是结束滑动的时候 12345// 不触发方向运动 也就是手指离开的时候if (direction === 1) &#123; end = translateX topEnd = translateY&#125; 不属于任何一个判断条件 但是此时也要处理 左 上 的值 否则也会发现下次出现undefined 建议不要使用定位变动元素位置 最开始通过position将元素进行定位 在滑动过程中更改left top 坐标点 但是这种处理方式中 元素滑动并不流畅 体验性很差 可以通过transform来移动元素 1transform: `translateX($&#123;translateX&#125;px) translateY($&#123;translateY&#125;px)`, 缩放 事件 含义 pinch 两个手指缩放 整个缩放周期 pinchstart 开始滑动 pinchIn 缩小 pinchOut 放大 PinchEnd 缩放取消 PinchCancel 滑动取消 缩放监听的是两个手指捏合的动作 元素缩小 1234pinchIn () &#123; let width = this.state.width - 1 let height = this.state.height - 1&#125; 元素放大 1234pinchOut () &#123; let width = this.state.width + 1 let height = this.state.height + 1&#125; 由于手指捏合速度很快 所以这里直接将元素进行宽度与长度的增减 最好不要将元素大小变化的处理放入 onPinch 事件 防止手势丢失导致元素一直放大或者缩小 旋转 rotatehammer.js官网中提供的 旋转案例 中 通过判断两个手指之间的角度差 来更改元素旋转角 123onRotate (ev) &#123; transform.angle = initAngle + ev.rotation&#125; 但是这样是有一个问题如果最开始两个手指之间不在同一个水平线上 同样检测到两个手指之间的差值 元素会马上发生转动 所以这个属性不能准确读取到手指旋转角度 测试中发现 函数中事件对象 ev 有一个 srcEvent 参数 它也是一个对象 里面也有一个 rotation 属性 这个真正的表示了每一次手指旋转的角度值 此处有坑 只在iOS中有此属性 所以更改为使用此属性值来进行元素的旋转效果 12345678910111213handleRotate (ev) &#123; let &#123;startRotate&#125; = this.state let &#123;deltaTime, srcEvent&#125; = ev // 点触事件 时间太短不去触发旋事件 if (deltaTime &lt; 100) return let &#123;rotation = ''&#125; = srcEvent || &#123;&#125; // 每次手指旋转的角度 let end if (rotation) &#123; // 如果存在则表示是在iOS中 rotation 从srcEvent 中获取 表示每一次旋转的角度 end = startRotate + rotation &#125;&#125; 按压 press 事件 含义 press 按压周期 pressUp 按压结束 手指抬起 旋转的补充方案 由于在安卓机中没有拿到每一次旋转角度 因此使用plan B 通过添加两个按钮 当点击按钮或者长按按钮 可以进行图片的旋转 按压过程 通过开启定时器 来不断旋转目标元素 1234timer = setInterval(() =&gt; &#123; old-- this.setState(&#123;rotateArg: old&#125;)&#125;, 25) 在按压结束的时候 清除定期器 123handlePressUp () &#123; timer = window.clearInterval(timer)&#125; bug 处理 手势并发 导致不停旋转 后来发现 如果在点击旋转按钮的时候 同时触发了别的手势 比如滑动 那么一旦手指离开屏幕 会发现元素会一直转个不停 这是因为定时器的清除操作只写在了 PressUp 这个手势中 而多手势的时候 有时候会读不到此事件 修正措施： 在每一种手势结束的时候 都清除一次定时器 比如 tapEnd 、 pinchEnd等]]></content>
      <categories>
        <category>第三方插件使用</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现截屏效果]]></title>
    <url>%2F2017%2F08%2F26%2Fjs%E5%AE%9E%E7%8E%B0%E6%88%AA%E5%B1%8F%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[项目中需要一个截屏的效果 因此尝试了两个不错的第三方截屏插件 html2canvas 官网 Github 基本使用 1234567html2canvas(document.getElementById('view'), &#123; onrendered: (canvas) =&gt; &#123; image = canvas.toDataURL('image/png') &#125;, width: 300, height: 300&#125;) 这里返回的是一个canvas元素 你可以通过canvas的方法获base64的图片格式 或者 Blob的形式 base64 1let baseimage = canvas.toDataURL('image/png') Blob 123canvas.toBlob((blob) =&gt; &#123;&#125;) 这里就可以拿到图片Blob的形式 但是这里也有一个坑 此Blob无法在iOS中实现 所以如果需要Blob 最好不要使用这种方式 使用base64 转化为 Blob 的函数方法 12345678910function convertBase64UrlToBlob(urlData)&#123; var bytes = window.atob(urlData.split(',')[1]) //去掉url的头，并转换为byte //处理异常,将ascii码小于0的转换为大于0 var ab = new ArrayBuffer(bytes.length) var ia = new Uint8Array(ab) for (var i = 0; i &lt; bytes.length; i++) &#123; ia[i] = bytes.charCodeAt(i) &#125; return new Blob( [ab] , &#123;type : 'image/png'&#125;)&#125; 注意这里的参数 是不需要带有base64格式头部那里的部分 最开始没有注意到这里 会发现在控制台报错 1failed to execute 'atob' on 'window': the string to be decoded is not correctly encoded. 这种方法是可以兼容安卓以及iOS系统的 将指定元素的部分以图片形式展示 dom-to-image此插件最大的坑是 Safari is not supported Github 1234567domtoimage.toPng(document.getElementById('view')).then((dataUrl) =&gt; &#123; imgSrc = dataUrl&#125;).catch(function (error) &#123; console.log('oops, something went wrong!', error)&#125;)]]></content>
      <categories>
        <category>第三方插件使用</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于文件的那点事]]></title>
    <url>%2F2017%2F08%2F25%2F%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[我们经常使用的文档上传方式为 借助input标签 1&lt;input type='file' /&gt; FileUpload创建一个此 input 元素标签 则新建了一个 FileUpload 对象 file-upload 元素的表单被提交的时候，浏览器会向服务器发送选中的文件的内容 当用户选择一个新的文件，file-upload 元素会触发 onchange 事件句柄 所以可以通过监听此事件 来处理用户操作 12let element = document.getElementsByClassName('input')element.addEventListener('change', function ()&#123;...&#125;) File APIFile API 为web开发人员提供一种安全的方式 方便客户端访问计算机中的文件 并对其进行操作 HTML5在DOM中为文件添加了 files 集合 在通过 input 元素 选择一个或者多个文件时候 files中将包含一组File对象 每一个File对象对应着一个文件 每一个File对象有以下只读属性 属性名 含义 name 在本地系统中的文件名 size 文件字节大小 type 文件的MIME类型 lastModifiedDate 文件上次修改时间(chorme支持) 所以可以在监听函数中 读取files属性 注意files属性不是匿名函数的参数 而是元素的属性 1234let element = document.getElementsByClassName('input')[0]element.addEventListener('change', function () &#123; console.log(element.files)&#125;) FileReaderFileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容 1let reader = new FileReader() FileReader 的方法 readAsText（file, encoding）纯文本形式读取文件 将读取到的文版保存在result中 第二个参数指定编码类型 是可选参数 readAsDataURL（file)读取文件 并将其以数据URL的形式保存在result中 readAsArrayBuffer (file)读取文件 并将一个包含文件内容的 ArrayBuffer 保存在result中 此方法 IE 并不能很好的支持 abort中断文件读取过程 FileReader 的事件 由于读取内容的过程是异步的 所以FileReader提供了几个事件 比较常用的有 progress error load progress每50ms左右 会出发一次progress事件 error如果由于某些原因无法读取文件 则会出发error事件 load当文件成功加载之后 会出发load事件 loadend在触发 error 或者 load 或者 abort 事件之后 会触发 loadend 事件 FileReader 的属性 error当文件出错时 先关信息会存在error中 readyState表明FileReader对象的当前状态 result读取到的文件内容.这个属性只在读取操作完成之后才有效,并且数据的格式取决于读取操作是由哪个方法发起的 例子123456789101112131415161718let ele = document.getElementsByClassName('input')[0]ele.addEventListener('change', function (args)&#123; let reader = new FileReader() if (/image/.test(ele.files[0].type)) &#123; reader.readAsDataURL(ele.files[0]) &#125; else &#123; reader.readAsText(ele.files[0]) &#125; reader.onprogress = function (arg) &#123; console.log(arg) &#125; reader.onerror = function (error) &#123; console.log(error) &#125; reader.onload = function (result) &#123; console.log(result) &#125;&#125;) 读取文件部分内容如果想要读取部分文件内容 可以借助Blob 类型的方法 slice Blob是File 类型的父类型 具有slice属性 以及 type 属性 而且它支持 slice 方法 可以切割数据 123456789function getblob (blob, start, end) &#123; if (blob.slice) &#123; return blob.slice(start, end) &#125; else if (blob.webkitSlice) &#123; return blob.webkitSlice(start, end) &#125; else if (blob.mozSlice) &#123; return blob.mozSlice(start, end) &#125;&#125; 实例 1234567891011let ele = document.getElementsByClassName('input')[0]ele.addEventListener('change', function (args)&#123; let reader = new FileReader() let blob = getblob(ele.files[0], 0, 32) if (blob) &#123; reader.readAsText(blob) reader.onload = function () &#123; console.log(reader.result) // 读取文件的32b的内容 &#125; &#125;&#125;) 对象URL也称之为Blob URL 值得是引用保存在File或者 Blob中数据的URL 这种好处是 可以不必把文件内容读取到JavaScript中 而是直接使用文件内容 创建对象URL考虑浏览器兼容问题 可以使用以下函数来创建对象URL 123456789function creatObjUrl (blob) &#123; if (window.URL) &#123; return window.URL.createObjectURL(blob) &#125; else if (window.webkitURL) &#123; return window.webkitURL.createObjectURL(blob) &#125; else &#123; return null &#125;&#125; 函数返回值为字符串 指向内存的地址 实例 1234567let ele = document.getElementsByClassName('input')[0]let imgs = document.getElementsByClassName('img')[0]ele.addEventListener('change', function ()&#123; let reader = new FileReader() let imgUrl = creatObjUrl(ele.files[0]) imgs.src = imgUrl // 可以在页面中看到此图片&#125;) 直接将对象URL 放入 Img标签中 就省去了数据先读到JavaScript中的麻烦 标签会自动找到相应地址 直接将图像读取出来 如果不需要相应数据 最好释放内存 有两种方式可以进行内存的释放 手工释放内存 1234567function revokeObjectUrl (url) &#123; if (window.URL) &#123; window.URL.revokeObjectURL(url) &#125; else &#123; window.webkitURL.revokeObjectURL(url) &#125;&#125; 页面卸载时 会自动释放对象URL占用的内存]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>文件处理</tag>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2017%2F08%2F13%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组是JavaScript基本数据类型之一 数组是值的有序集合 每一个值称为数组元素 创建数组 字面量形式 1let anchorAry = ['tom', 'juery'] 实例创建 1let rank = new Array(2,4,5) es6 1let items = Array.of(3, 6, 7) 数组的属性 length 数组长度 表示数组内部有多少个元素 数组的索引总是由0开始，所以一个数组的上下限分别是0和length-1 数组实例的方法增加数组 1 unshift 1234let flowers = [1, 2, 3]let end = flowers.unshift(4)console.log(flowers) // [4, 1, 2, 3,]console.log(end) // 4 unshift 向数组头部增加元素 返回值为新数组的长度 原数组发生变动 方法 参数 原数组是否变化 返回值 unshift 任何类型 是 新数组长度 2 push 1234let grass = [1, 2]let end = grass.push(6, 7, 8)console.log(grass) // [1, 2, 6, 7, 8]console.log(end) // 5 push 向数组末尾追加元素 返回值为新数组长度 原数组发生变动 方法 参数 原数组是否变化 返回值 push 任何类型 是 新数组长度 3 concat 12345let birds = [1, 2]let trees = [2, 3]let end = birds.concat(trees)console.log(birds) // [1, 2]console.log(end) // [1, 2, 2, 3] concat 两个数组的拼接 返回值为新数组 原数组不变 方法 参数 原数组是否变化 返回值 concat 数组 否 新数组 4 splice 1234let stars = [1, 2, 3]let end = stars.splice(2, 1, 4, 5, 6)console.log(stars) // [1, 2, 4, 5, 6]console.log(end) // [1, 2, 3] splice 对数组元素进行删除或者替换 方法 参数 原数组是否变化 返回值 splice 三个 否 新数组 删减数组 1 shift 1234let songs = ['can1', 'can2']let end = songs.shift()console.log(songs)console.log(end) shift 从数组头部开始删除元素 返回值为删掉的元素 原数组变化 方法 参数 原数组是否变化 返回值 shift 无 是 删除的元素 2 pop 删除最后一个数组元素 1234let wind = [1, 3, 6]let end = wind.pop()console.log(wind) // [1, 3]console.log(end) // 6 方法 参数 原数组是否变化 返回值 pop 无 是 删除的元素 3 splice 遍历数组 1 forEach (fn, thisArg) 12345let valley = ['Canada', 'Zealand', 'Mexico']let end = valley.forEach((current, index, array) =&gt; &#123; console.log(current, index, array)&#125;)console.log(end) // undefined 方法 参数 原数组是否变化 返回值 forEach cb , this [第二个参数可有可无] 否 无 2 map 123456let valley = ['Canada', 'Zealand', 'Mexico']let end = valley.map((current, index, array) =&gt; &#123; console.log(current, index, array) return index&#125;)console.log(end) // [0, 1, 2] 方法 参数 原数组是否变化 返回值 map cb , this [第二个参数可有可无] 否 有 返回值为数组 3 filter 123let singer = ['灿灿', '希小白', '伦桑']let end = songs.filter(item =&gt; item.length &gt; 2)console.log(end) // ['希小白'] filter 筛选符合条件的元素 返回数组 方法 参数 原数组是否变化 返回值 filter cb , this [第二个参数可有可无] 否 有 返回值为数组 4 every 123let singer = ['岑岑', '白止', '老干妈']let end = singer.every(item =&gt; item.length &lt; 2 )console.log(end) // false 遍历数组中元素 当每一个元素在callback中返回为TRUE 则最后才返回TRUE 方法 参数 原数组是否变化 返回值 every cb , this [第二个参数可有可无] 否 Boolean 5 some 123let singer = ['宁采臣', '李逍遥', '小八']let end = singer.some(item =&gt; item.length &gt; 2 )console.log(end) // true 遍历数组中元素 当有一个元素在callback中返回为TRUE 则可才返回TRUE 方法 参数 原数组是否变化 返回值 some cb , this [第二个参数可有可无] 否 Boolean 6 reduce 123let math = [0, 1, 2]let end = math.reduce((current, next) =&gt; current + next)console.log(end) 从左到右依次进行元素的累加 方法 参数 原数组是否变化 返回值 reduce cb , origin [初始值 第二个参数可有可无] 否 累加之和 reduce 原理编写 123456789Array.prototype.reduce = function (cb, defaultVal) &#123; let end = defaultVal || this[0] let index = defaultVal ? 0 : 1 for (index; index &lt; this.length; index++) &#123; const element = this[index]; end = cb(end, element) &#125; return end&#125; 7 reduceRight 从右到左依次进行元素的累加 方法 参数 原数组是否变化 返回值 reduceRight cb , origin [初始值 第二个参数可有可无] 否 累加之和 8 find 1234let singer = ['萧忆情', '小义学长', '李蚊香']let end = singer.find(item =&gt; item === '李蚊香')let end2 = singer.find(item =&gt; item === 'Can')console.log(end, end2) // 李蚊香 , undefined 遍历数组 返回 第一个 使callback 为TRUE的元素 如果没有 则返回undefined 方法 参数 原数组是否变化 返回值 find cb , thisArg [第二个参数可有可无] 否 元素 或者 undefined 9 findIndex 类似于 find 不过返回的是符合条件的元素的位置 如果所有成员都不符合条件，则返回-1 方法 参数 原数组是否变化 返回值 findIndex cb , thisArg [第二个参数可有可无] 否 元素下标 或者 -1 find filter在数组中查找符合某种条件的元素 可以使用 filter 或者 find filter 将会遍历所有元素 返回值为数组 find 一直遍历到第一个符合条件的 返回值是 该元素 slice截取数组n到m项，包括n和M,原数组不变 第n项的索引 n-1，第m项的索引 m-1 slice() 方法为包前不包后，本题要求包括后面的,所以后面的应该加1 ary.slice(n-1,m) other toString() 123var ary =[2,3]var nA = ary.toString();//'2,3' 不改变原数组 join() 指定分隔符，转为字符串 123[1,2,90,'k'].join('') //"1290k"[1,2,90].join() // '1,2,90' 如果不写就相当于直接转字符串[2,3,4].join('o') // '2o3o4o' 就相当于把逗号转为分隔符 sort sort() 只可以进行10以内的排序 返回的排好序的新数组 原数组发生改变 123var ary = [7,4,7,2,12]var nA = ary.sort()console.log(ary,nA) // [12,2,4,7,8] [12,2,4,7,8] 2.2 sort 从小到大 12345var ary = [2,3,4,1,7]ary.sort(function (a,b) &#123; return a-b&#125;)document.write(ary) 2.4 sort 从大到小 12345var ary = [2,3,4,1,7]ary.sort(function (a,b) &#123; return b-a&#125;)document.write(ary) reverse() 翻转数组，倒序排列 indexOf 查找返回元素第一次出现的索引 没有则返回-1 lastIndexOf 查找返回元素最后一次出现的索引 没有则返回-1 es6 扩展… 扩展运算符12345console.log(...[1, 2, 3]) // 1 2 3function push(array, ...items) &#123; array.push(...items);&#125; 扩展运算符后面还可以放置表达式 1234const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b',]; 如果扩展运算符后面是一个空数组，则不产生任何效果 1[...[], 1] // [1] 替代apply 12345// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77]) 1234567var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 类数组转为真正的数组 12let nodeList = document.querySelectorAll('div');let array = [...nodeList]; 任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。 扩展运算符还可以将字符串转为真正的数组 1[...'hello'] // [ "h", "e", "l", "l", "o" ] Array.from()只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。 Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。 因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] Array.of()Array.of方法用于将一组值，转换为数组 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 es6 新增数组实例fill 填充fill方法使用给定值，填充一个数组 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。1['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c'] 从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历 唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 includes判断数组中是否包含元素 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true flat1[1, 2, [3, 4]].flat() // [1, 2, 3, 4] flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] 上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 12[1, [2, [3]]].flat(Infinity)// [1, 2, 3]]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[客户端存储]]></title>
    <url>%2F2017%2F03%2F19%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 存储信息可以放在服务器或者客户端 1 当登录成功后 在本地存储用户信息 -》》 验证登录态 2 增加用户信息 放在服务器数据库中 目前的存储方式html5新增的本地存储方式 cookie 本地存储 数据库存储 mongodb Access MySQL 等 存储数据的量级不同 JSON文件存储 2 cookie 与 localstorage 1 cookie兼容性很好 兼容所有浏览器 localstorage 是h5新增特性 不兼容低版本浏览器 所以一旦要求考虑兼容性 需要使用cookie 3 4 用户可能处于安全考虑 禁用cookie 比如隐私模式 或者不记录历史 也就是无痕浏览 谷歌浏览器中 ctrl+shift+n 开启无痕浏览 但是localStorage不受此干扰 360安全卫士在清理cookie垃圾的时候 可以把cookie清除掉 浏览器自带的清理机制 也可以清除掉cookie 如果项目只在移动端 可以选择localStorage 【也就是不考虑兼容性】 本地存储都是明文存储 在本地控制台中都可看到 所以为了保证信息安全 需要对重要信息进行加密处理 加密分为 可逆转加密 不可逆加密 可逆转加密 -》 可按照加密规则进行解密 不可逆加密-》无法解密 用的最多的是md5.js 加密 MD5加密是输入相同那个 输出相同 真正项目中 使用md5加密之后 还会按照公司自己定义的一套规则 进行深层加密 localStorage的使用 得到的是属性值 是字符串 cookie的使用 可以使用 document.cookie但是一般cookie需要写的字段比较多 进行一个方法的封装 删除的原理是将过期时间设置为今天日期以前的时间 所谓的本地存储 尤其是cookie和localStorage 都是存储在当前电脑的指定浏览器的指定位置 而且在哪一个域名下 localStorage 是 永久回话存储 sessionStorage 临时本地存储 当前页面关闭 存储信息会销毁]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记-js高程]]></title>
    <url>%2F2017%2F03%2F01%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-js%E9%AB%98%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象[Obecjt-Oriented 简称OO]语言有一个标志，那就是【类】的概念，通过类可以创建多个具有任意属性和方法的对象。但是JS中其实是没有 类的概念的，所以js中的对象与其他语言中的类不同。 简单来说，js中的对象是一组无序的名值对，而其中的值是对象或者函数。 对象 创建对象创建一个对象，可以通过new一个实例或者使用对象字面量的方式 123456var person=new Object();person.name='tom';// 或者使用对象字面量var person=&#123; name='tom',age=20&#125; 虽然以上两个方式都能创建对象，但是如果通过这些方式创建大量对象，会产生大量冗余代码。为此开始使用别的方式来创建对象。 工厂模式12345function createP(name)&#123; var per=new Object(); per.name=name; return per;&#125; 工厂模式就是一个函数的封装 构造函数通过创建自定义构造函数，定义对象类型的属性和方法。 123function Per(name)&#123; this.name=name;&#125; 构造函数相对于工厂模式，并没有显示创建对象，直接将方法属性赋值this，无return语句。就相当于系统自动进行了 var 和return 的过程。 按照惯例，构造函数的首字母大写。 要创建一个新实例，必须通过new操作符。这种方式实际会经历以下过程 创建一个新对象 &gt; 将构造函数作用域赋值给新对象 所以this为当前实例 &gt; 执行构造函数中代码 即为新对象添加属性方法 &gt; 返回新对象 原型模式我们创建的每一个函数都有一个prototype属性 这其实是一个指针 指向创建出当前实例的那个类的原型对象 使用原型对象的好处是，在原型对象上添加的属性和方法是所有实例都可以共享的。 12function Person();Person.prototype.say=function ()&#123; console.log('hello') &#125; 通过这个方式，以后new出来的实例都可以使用say方法了 关于类 原型 实例之间的关系构造函数也就是类，自带一个prototype属性，这是类的原型对象。 每一个原型对象自带一个constructor的属性 指向当前类 1Person.prototype.constructor=Person; 当通过构造函数new出一个实例后， 此实例会自带一个proto属性，指向当前实例所属类的原型 1person1.__proto__ = Person.prototype; 在ES6中 新增了一个Object.getPrototypeOf() 方法，可以返回 实例的proto的值 1Object.getPrototypeOf(person1) == Person.prototype // true 所以在ES6中 可以使用Object.getPrototypeOf() 获取实例的原型对象 实例在查找某个属性或方法时，会先找私有属性，然后向上查找原型对象 一直最后找到基类Object为止 【虽然可以通过实例访问保存在原型中的值 但是不能通过实例重写原型中的属性或者方法】 1234567function Person()&#123;&#125;Person.prototype.name='tom';var per1 = new Person();var per2 = new Person();per1.name='jack';console.log(per1.name);// jackconsole.log(per2.name);// tom 以上例子表示，在实例上添加一个同名属性， 会阻断向原型上的查找， 但是不会覆盖原型中属性。 【即使将此同名属性值设为null 也只会在实例中设置该属性 而不会恢复指向原型的链接 不过可以使用delete操作符完全删除实例属性 从而重新访问原型中的属性】 属性判断4.1 hasOwnPrototype 判断私有属性 使用此方法可以判断一个属性是存在于实例中还是原型中 若给定属性存在于实例中 返回true 4.2 in 操作符 无论是私有属性还是共有属性 都可以使用in 【结合两者 写一个判断是公有属性的判断】 123function common(object,attr)&#123; return (attr in object) &amp;&amp; !object.hasOwPprototype(attr);&#125; 4.3 isPropertyOf 1obj1.isPropertyOf(obj2) 判断 前者是不是在后者的原型链上 4.4 for in 循环自定义属性,公有加私有 数组数组是值的有序集合。其中每一个值是一个元素。 1 稀疏数组 稀疏数组就是从0开始的不连续索引的数组。如果数组是稀疏的，length属性值大于元素的个数。 注意，当数组直接量中省略值时，不属于稀疏数组。省略的元素在数组中是存在的，其值为undefined。这个数组元素不存在是不同的。 123var ary1 = [,,]; // 元素是3个undefined var ary2 = new Array(3); // 元素为空 但是数组长度是3 2 数组长度 ary.length 数组长度可能小于数组元素个数 ，因为有稀疏数组情况存在 3 数组元素的删除 添加 常用删除方法 pop shift 常用添加方法 push unshift 注意，还可以使用delete操作符删除数组元素，但是使用此方法，不会改变数组长度，也不会发生数组塌陷，而是变为稀疏数组 其余删除方式： 使用splice 或者 改变Length 4 数组遍历 1 for循环 在稀疏数组中，有元素不存在的情况，假设不想处理不存在元素 1234for(var i=0;i&lt;ary.length;i++)&#123; if(!( ary[i] in ary) ) continue; - somethings--&#125; 2 forEach 不兼容 5 数组方法 1 join 2 reverse 3 sort 4 concat 5 slice 6 splice 7 push pop 8 shift unshift 9 toString 6 新增的数组方法 1 forEach 2 map 3 filter 过滤 4 every some 5 reduce 6 indexOf 7 数组类型 在ES6中，可以使用Array.isArray() 判断是否为数组 8 关于类数组对象 Js数组 有一些特性 是其他对象没有的 length设置length值可以截断数组从Array.prototype 继承一些有用的方法其类属性为‘Array’所以一般类数组想要使用数组中方法，要先将其转为数组。以arguments为例 1var ary = Array.prototype.slice.call(arguments) 这样arguments就可以使用数组中方法了 或者使用 1arguments.__proto__ = Array.prototype try catchtry catch 是js异常捕获的一种方式。不仅可以用在普通JS也可以用在node环境中。 12345try&#123; 可能导致异常的代码&#125;catch (e)&#123; 异常发生时如何处理&#125; 在try中的代码块发生错误时，会执行catch 中代码块 catch中会接收到一个错误对象 e。此错误对象包含的信息因为浏览器的不同而不同，但是所有的浏览器 都包含一个message属性 所以可以在catch错误中打印错误信息 12345try&#123; // 可能导致异常的代码&#125;catch (e)&#123; console.log(e.message)&#125; 关于finally字句问题 finally中代码是无论错误与否都会执行 例子 1234567try&#123; return 'success'&#125;catch (e)&#123; return 'error'&#125; finally &#123; return 'guess'&#125; 以上代码输出的是 ‘guess’ 如果提供了finally字句，则catch字句就成了可选的。 window对象window对象是浏览器的一个实例。 浏览器中的全局对象window是浏览器中的全局对象。【node中全局对象是global】 因此在全局定义的变量后者方法都是属于window对象的。 但是这个直接写在window上还是有点差别。 window.xxx 可以通过 delete 操作符 删除 但是直接写的不可以 直接写的属性和方法相当于其[[configurable]] 为false，所以不能通过delete操作符删除 属性1 window.name 输出本窗口包含的框架名字 2 window.screenTop 输出窗口位置信息 [有兼容问题] 3 window.innerHeight 窗口大小 [有兼容问题] 一般获取当前窗口大小使用的是 1document.documentElement.clientWidth||document.body.clientWidth 方法 [常用的几个]1 window.open() 打开新页面 2 定时器 setTimeout setInterval 2 JSON 3 alert() 是提示 不具有确认以及取消功能 4 confirm() 确认或者取消 会返回一个布尔值。为true，表示确认，为false 表示取消 5 prompt() 比confirm 多一个Inout输入框 用户可以填写一些信息 返回的是输入框的值 6 window.resize 事件 [常用的几个]1 window.onscroll 2 window.inhashchange ajaxAjax 技术核心是XMLHttpRequest对象 能够以异步的方式从服务器获取数据 意味着不用刷新页面 就可以进行数据更新 XHR 的用法ajax需要通过四步 1234var xhr = new XMLHttpRequest();xhr.open(method,url,async);xhr.onreadystatechange= function () &#123;&#125;;xhr.send(); 在调用请求发送后，请求被发送到服务器。 在接受到服务器的响应后 响应数据会自动填充到XHR属性 XHR 属性xhr,responseText 作为响应主体被返回的文本xhr.responseXML 如果响应内容类型是 ‘text/xml’ 或者 ‘application/xml’ 这个属性中将保存数据的XML DOM 文档xhr.status HTTP状态码xhr.statusText HTTP状态的说明 注意，无论内容类型是什么，响应主体内容都会保存在responseText 属性中 ，但是在对于非XML数据 responseXML 属性为 null 关于 readyState 属性 该属性表示请求/响应过程的当前活动阶段 其属性值有 0 -4 个状态 状态 0 未初始化 尚未调用open()状态1 启动 已经调用 open() 但未调用send()状态2 发送 调用send() 接受到响应头状态3 接受 接受响应体状态4 接受完毕 接受完毕响应体通过 onreadystatechange 事件 可以监听到状态的改变 123xhr.onreadystatechange= function () &#123; if(xhr.readystate==4)&#123;......&#125;&#125;; 注意这个函数里面没有用到this 主要是因为onreadystatechange 事件处理程序的作用域问题 如果是this对象 在有的浏览器会导致函数执行失败或者导致错误发生 在接受到响应之前还可以通过调用abort() 方法来取消请求 调用这个方法后 XHR 会停止触发事件 而且不允许访问任何与响应有关的对象属性 一般在终止请求之后 还应该对XHR对象进行解应用操作 就是将其设置为null 这样浏览器在空闲的时候 会对其进行内存销毁 HTTP 头部信息每个HTTP请求和响应会带有响应头部信息 XHR对象提供了操作这两种头部[请求头和响应头] 的方法 设置请求头 xhr.setRequestHeader()获取请求头 xhr.getRequestHeader() 注意，有的浏览器允许重写默认头部信息 有的则禁止重写 get请求 GET是最常见的请求类型 常用于向服务器查询信息 可以将查询字符串参数追加到URL末尾 用于将信息发送给服务器 get请求经常在查询字符串格式那里出问题 POST请求 POST请求通过用于向服务器发送数据 数据在请求体中 POST请求体可以包含非常多的数据 而且格式不限 超时设定XHR有一个timeout属性 表示请求在等待响应多少毫秒后就终止 在给其设置一个数值后 如果规定时间内浏览器未收到响应 则触发timeout事件 123456789101112131415161718var xhr = new XMLHttpRequest();xhr.open(method,url,async);xhr.onreadystatechange= function () &#123; if(xhr.readyState==4) &#123; try&#123; if(xhr.status==200)&#123; console.log(xhr.responseText); &#125; &#125;catch (e)&#123; console.log('time out'); &#125; &#125;&#125;;xhr.timeout=2000;xhr.ontimeout= function () &#123; console.log('Request timeout');&#125;xhr.send(); 设置超时时间为2000毫秒 如果请求在此时间未返回 则自动终止请求 而请求终止时 会触发ontimeout事件 注意，在请求终止的时候 有可能readyState已经是4了 但是请求终止后是无法访问status属性 所以使用了一个异常捕获处理 页面中通过效果来吸引用户注意是很常用的，会显著增强页面可用性。通过jQuery，可以轻松为页面添加简单的视觉效果，以及动画。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>学习</tag>
        <tag>对象</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[switch-case]]></title>
    <url>%2F2017%2F02%2F15%2Fswitch-case%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 基本规则switch 使用的是严格比较 === 使用在项目中使用的了switch的另一种写法 是用的是表达式进行判断的 代码如下 123456789101112131415161718let &#123;dailyCount ,totalCount:mileage &#125; = userinfo let mile = 0 switch (true) &#123; case mileage &lt; 500 &amp;&amp; mileage &gt; 200: // 200-499 mile = 1 break; case mileage &lt; 1000 &amp;&amp; mileage &gt; 4999: mile = 2 break; case mileage &lt; 20000 &amp;&amp; mileage &gt; 10000: mile = 3 break; case mileage &gt; 200000: mile = 4 break; default: mile = 0 &#125; 这里switch写的是布尔值 TRUE 其实开始这里写的是 switch (mile)自然不对 这不符合switch的比较规则 switch的比较按照的是 将case 语句后面的结果 与switch中的参数进行严格比较 比较结果为TRUE 则执行对应case语句 所欲当在case 条件为布尔值的时候 switch语句里的也应该是布尔值 因此switch 判断条件应该为 switch (true) 注意以上使用方式虽然正确，但是从代码规范来讲，并不符合switch的使用语义，不推荐这样写]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法-map详谈]]></title>
    <url>%2F2017%2F02%2F15%2F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95-map%E8%AF%A6%E8%B0%88%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 项目组中有一个问题1[1,2,3].map(parseInt) 输出什么 通过大神指点，如下是分析思路 数组中方法map 是用来进行遍历 接受两个参数 1arys.map(callback[, thisArg]) 第一个参数是回调函数 第二个是this 所以题目中回调函数传入的是parseInt 第二个参数为空 回调函数接受三个参数 1function (item, index, array) &#123;...&#125; 当前元素 元素下标 原数组 所以这三次遍历 回调函数一次拿到参数为 1 -&gt; 1 , 0 , [1,2,3]2 -&gt; 2 , 1 , [1,2,3]3 -&gt; 3 , 2 , [1,2,3] 然后来看parseInt 参数的接受 MDN 解析 click me 1parseInt(string, radix) 接受两个参数 原始字符 基数 string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串 radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。始终指定此参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10。 返回值 返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回 NaN 例如：radix参数为10 将会把第一个参数看作是一个数的十进制表示，8 对应八进制，16 对应十六进制，等等。基数大于 10 时，用字母表中的字母来表示大于 9 的数字。例如十六进制中，使用 A 到 F 在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理： 如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。如果字符串 string 以其它任何值开头，则基数是10 (十进制)。如果第一个字符不能被转换成数字，parseInt返回NaN 所以 parseInt 的三次运算为 parseInt(1, 0)parseInt(2, 1)parseInt(3, 2) 后面两次运算的基数不属于有效值 返回NaN 因此最终结果为 [1 NaN NaN]]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组排序]]></title>
    <url>%2F2017%2F02%2F15%2F%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 冒泡排序依次比较大小，如果数值比目标数值大，交换位置 12345678910111213function arySort(arys)&#123; for(var i=0;i&lt;arys.length;i++)&#123; for(var j=i+1;j&lt;arys.length;j++)&#123; if(arys[j]&gt;arys[i])&#123; var num = arys[i]; arys[i] = arys[j]; arys[j] = num; &#125; &#125; &#125; return arys;&#125;console.log(arySort([1111,2,0,2,7,55,6,7,1]) ) 插入排序2.1 原理 将n个元素的数列分为已有序和无序两个部分。 数列：{a1，a2，a3，a4，…，an} 将该数列的第一元素视为有序数列，后面都视为无序数列： 1&#123;&#123;a1&#125;，&#123;a2，a3，a4，…，an&#125;&#125; 将无序数列中的元素插入到有序数列的对应位置，插入前通过比大小的方式找到其在有序数列中的对应位置。 2.2 实现 1234567891011121314151617181920function sort(arys)&#123; var left =[]; left[0] = arys[0]; for(var i=1;i&lt;arys.length;i++)&#123; var cur = arys[i]; for(var j=left.length-1;j&gt;=0;)&#123; if(cur&gt;left[j])&#123; left.splice(j+1,0,cur) ; break ; &#125;else&#123; j--; if(j==-1)&#123; left.unshift(cur) &#125; &#125; &#125; &#125; return left;&#125;document.write(sort([1,0,33,2,3,109,0,8,3,9])) 如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需（n-1）次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。插入排序的赋值操作是比较操作的次数加上 (n-1）次。平均来说插入排序算法的时间复杂度为O(n^2）。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。 尝试将方法写入原型中 1234567891011121314151617181920212223242526var ary1 =[3,4,2,5,7,3,9,3,0] var ary2=[9,0]; Array.prototype.inSort= function () &#123; if(this.length==1)&#123;return [this]&#125; if(this.length==2)&#123;return [Math.min(this[0],this[1]),Math.max(this[0],this[1])]&#125; var left =[]; left.push(this[0]); for(var i=1;i&lt;this.length;i++)&#123; var cur = this[i]; for(var j=left.length;j&gt;=0;)&#123; if(cur&gt;left[j])&#123; left.splice(j+1,0,cur); break; &#125;else&#123; j--; if(j==-1)&#123; left.unshift(cur) &#125; &#125; &#125; &#125; return left; &#125; console.log(ary1) console.log(ary1.inSort()) console.log([9,0].inSort()) 快速排序3.1 原理 快速排序（Quicksort）是对冒泡排序的一种改进，是一种分而治之算法归并排序的风格 核心的思想就是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 在数据集之中，选择一个元素作为”基准”（pivot）。所有小于”基准”的元素，都push到左边数组；所有大于”基准”的元素，都push到右边数组。对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 3.2 实现 123456789101112131415161718192021function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 并且在原数组中删除该值 // 剩余的元素与中间值进行比较 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//小于中间值的数传到左边数组 &#125; else&#123; right.push(arr[i]);//不小于中间值传到右边数组 &#125; &#125; return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较&#125;console.log(quickSort([32,45,37,16,2,87])); // “2,16,32,37,45,87”]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>array</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Number 类型]]></title>
    <url>%2F2017%2F02%2F13%2FNumber%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 Number正数 负数 小数 0 NaN（not a number） 在不能计算或者数据类型转换不成功的时候，可能出现NaN 1console.log( NaN == NaN ) // false 全局方法 方法 含义 isNaN 判断是否是 NaN Number 强制转化为数字类型 转化不成功返回NaN parseInt 非强制转换 parseFloat() 非强制转换, 比parseInt多识别小数点 isNaN 123456789isNaN(NaN) // trueisNaN(78) // falseisNaN('09') // falseisNaN(undefined) //trueisNaN(null) //false 可以看出，当执行该isNaN 方法, 会先使用Number方法会参数进行转化，再进行判断 Number() 当全部是数字时候才转化成功 12345678910111213141516Number('34') //34Number('34lp') //NaNNumber(['0']) //0Number(['009iu']) //NaNNumber([8,0]) //NaN 有逗号，不符合全部都是数字这一条件Number(undefined) //NaN// 几个特殊的Number(null) //0Number([]) // 0Number('') //0//布尔值转化为0 或者1Number(true) //1Number(false) //0 parseInt 将转化内容从左到右依次转化，直到不是有效数字，停止查找。返回。 转化不成功返回NaN 123parseInt('509s5yyy') //509parseInt(12.3) //12parseInt('yy') //NaN parseFloat 1parseFloat('123.45#') // 123.45 es6es6中 将以前的一些全局的方法 移动到Number对象上了，有的行为发生了变动 方法 含义 Number.isNaN() 判断是否是 NaN Number.parseInt() 非强制转换，与之前保持一致 Number.parseFloat() 非强制转换, 比parseInt多识别小数点，与之前保持一致 12345678910isNaN(NaN) // trueisNaN("NaN") // trueNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true' / 0) // trueNumber.isNaN(NaN) // trueNumber.isNaN("NaN") // falseNumber.isNaN(1) // false 与传统的全局方法isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断， Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 ( 或者说判断的是 参数本身 是不是 NaN ) NaN表示不是数字 什么情况下得到NaN 1 类型转化不成功2 计算不成功 Math 对象方法1 Math.abs() 2 Math.floor() 向下取整 3 Math.ceil() 向上取整 4 Math.min() 5 Math.max() 6 Math.round() 四舍五入 12Math.round(11.5) // 12 Math.round(-11.5) // -11 7 Math.random() 0到1之间的随机数 [0,1) 取[n,m]之间的随机整数 1Math.round( Math.random * (m-n) + n ) 8 Math.sqrt() 开平方 10 Math.pow(x,y) x的y次方 1Math.pow(3,2) //9 es6 新增 1 Math.trunc() 去除一个数的小数部分，返回整数部分。 对于非数值，Math.trunc内部使用Number方法将其先转为数值。对于空值和无法截取整数的值，返回NaN。 1234567891011Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc('123.456') // 123Math.trunc(true) //1Math.trunc(false) // 0Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaNMath.trunc(undefined) // NaN]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boolean 类型]]></title>
    <url>%2F2017%2F02%2F11%2FBoolean%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 Booleantrue false 方法 ! 取反 使用Boolean() 先转为布尔类型 再进行取反 Boolean() 将任意值转为布尔类型 结果为true或者false 五个被转为false ： null undefined ‘’ 0 NaN !! 相当于使用 Boolean()直接转为布尔类型 以上三个方法的结果，为true false 两种可能]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>boolean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数封装]]></title>
    <url>%2F2017%2F02%2F10%2F%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 类数组转为数组 写一个兼容所有浏览器的函数方法1234567891011function myArray(arg)&#123; try&#123; return Array.prototype.slice.call(arg); &#125;catch (e)&#123; var end =[]; for(var i=0;i&lt;arg.length;i++)&#123; end.push(arg[i]) &#125; return end; &#125;&#125; try catch 是异常捕获 求平均值思路分析: 去掉一个最大值 和最小值 然后求平均值 1 不需要传参，借助arguments 2 有返回值 123456function myFun()&#123; // 利用上文的类数组转数组方法 arguments 转为数组后排序 var argsAry = myArray(arguments).sort(function(a,b)&#123;return a-b;&#125;) argsAry.shift(); argsAry.pop(); // 删除数组最大最小元素 return (eval('('+argsAry+')')/argsAry.length).toFixed(2); // 平均值&#125; div排序 div内容是汉字思路： 1 获取元素2类数组转数组3 排序 4 重新插入页面 123456789101112var adivs = document.getElementsByTagName('div');var myDivs = myArray(adivs);myDivs.sort(function(a,b)&#123; // a 为数组第一项元素 b为数组第二项元素 a = a.innerHTML; b = b.innerHTML; return a.localeCompare(b); // 根据文字排序&#125;)// 重新插入页面while(myDivs.length)&#123; document.body.appendChild(myDivs.shift())&#125;]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器]]></title>
    <url>%2F2017%2F02%2F09%2F%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 setTimeout &amp;&amp; setInterval1234let timer = setTimeout( fn, time )// 清除定时器clearTimeout(timer) 在time之后执行一次fn函数 ，time 为毫秒 setInterval 与其不同的是，持续间隔 time 执行 fn 函数 1234let timer = setInterval( fn, time )// 清除定时器clearInterval(timer) requestAnimationFrame一般使用定时器做一些页面特效，但是这两个方法有缺点，由于线程（JavaScript的单线程机制使得其可能在有阻塞的情况下无法精确到毫秒触发）的问题，最后展示出现的效果并不是我们真正认为的一段时间后继续执行，会有卡顿不流畅的感觉,所以推荐使用 requestAnimationFrame 来替代 requestAnimationFrame()方法正是为了满足高性能动画的需求而提供的API，通过setInterval方法控制的动画其调用的间隔由程序员设置，而requestAnimationFrame()无须设置调用间隔， 它自动紧跟浏览器的绘制的帧率（一般浏览器的显示帧率是60fps，差不多每帧间隔16.7ms） 参考文章 requestAnimationFrame]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2F2017%2F02%2F07%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 面向过程 考虑封装函数 面向对象 会调用就可以了 对象的特征1.1 属性 1.2方法 2 面向对象思想 OO思想 或者是OOP思想 面向对象的三个特点 ：封装 继承 多态3.1 封装:对于同一功能函数，只封装一次。以后只需调用，无需重写 【低耦合 高内聚】3.2 继承:子类可以继承父类的属性和方法3.3 多态:多种形态【重载 重写】 1 重载: 其实JS中没有严格意义上的重载。有类似重载的功能，传入不同的参数，可实现不同功能比如任意数求和，可根据传入参数长度不同做一些不同功能2 重写 子类可以重写父类的属性和方法 面向对象的设计模式设计模式是用来封装库的。 高级工程师可以手写库。比如jquery库 单例模式1 单例模式就是把描述同一个对象的属性和方法放在同一个命名空间下。可以避免全局变量的污染和冲突。命名空间： 描述对象的属性和方法，所存储的空间，起个名字，比如person2 单例模式的本质就是普通对象。3 模块化开发：单例模式是最简单的模块化开发大型项目中，不同人同步进行开发，最后进行代码合并4 本模块进行函数调用，使用this.属性名 不同模块之间进行函数调用，使用模块名字加点加属性名5 单例模式的优缺点5.1 优点1 避免全局变量的污染和冲突 2 是最简单的模块化开发5.2 缺点当多个对象功能相同，会存在大量冗余代码 工厂模式工厂模式的本质就是封装 封装的三个步骤： 1 引入原材料-》 创建一个空对象 2 加工 -》 给对象添加属性和方法 3 输出 -》 输出加工后的对象 想让工厂模式的调用方式与系统类使用方式，1 首字母大写 2 使用时候通过new 也就是构造函数模式 1234567function person(name,age)&#123; var obj=&#123;&#125;; obj.name = name; obj.age=age; return obj;&#125;var pwr1 = person('mxx',24) 构造函数模式系统会自动创建对象，this。 手写加工部分 并且默认返回this 12345function Person(name)&#123; this.name =name;&#125;var p1 =new Person('mxx')console.dir(p1) 构造函数模式与工厂模式区别：1 工厂模式调用就是普通函数调用， 构造函数模式 调用 通过 new 2 函数体内不同。构造函数只执行加工部分。为什么学习构造函数1 自己写类 这些自己写的类，是自定义类。系统的那些，是系统类 2 了解系统类 3 创建实例构造函数知识点1 构造函数中的那个this，永远都是new出来的实例 2 构造函数中都是 私有的 属性和方法 3 实例只和this.xxx有关，与var无关 4 构造函数中 ,系统会默认创建实例, 系统会默认返回实例,所以不要手写return 4.1 手写返回基本数据类型，无效。 4.2 手写返回引用数据类型，有影响。以前写的属性方法无效。 5 构造函数是实例和类打交道 9 在new 的时候，如果不需要传参，可以省略小括号。构造函数缺点构造函数中的方法并没有实现真正的封装 原型模式,又叫构造函数原型模式将公共方法放在prototype上 Person.prototype.getName =function(){ } 系统提供的一个prototype属性，存放的是共有的属性或者方法、 实例 类 原型 三者打交道 关于原型模式的一些基础知识1 每个函数数据类型上，都有一个属性，叫prototype。prototype是个原型 [对象] 2 prototype这个对象，存放的是共有的属性和方法。 他天生自带一个属性constructor， constructor指向 当前构造函数 3 每个对象数据类型上，都有一个属性proto，指向当前实例所属类的原型 Object.prototype的方法 1 obj.hasOwnProperty() 判断是否为对象的私有属性 2 obj1.isPrototypeOf(Obj2) obj1是否在obj2的原型链上 3 propertyIsEnumerable：是否为可枚举的属性 原型链 proto 1 实例可以调用私有的属性方法以及调用共有的； 2 查找属性的规则： 2.1 先看该对象的私有空间是否有，有，就说明是私有属性 2.2 没有就，通过proto 找到原型 2.3 一直找到基类 Object.prototype 在没有就是Undefined other没有属性报undefined 没有变量报错]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2017%2F02%2F06%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 闭包的定义闭包就是函数运行时产生的那个私有作用域。 闭包是为了保证变量安全，隔离变量。防止与其他环境中的变量发生冲突。 1234function closure()&#123; var name ='web' var age = 9;&#125; 最常见的闭包 for 循环事件 12345678var ary = [1,2,3];for(var i=0;i&lt;ary.length;i++)&#123; (function (index) &#123; setTimeout (function () &#123; console.log(ary[index]); &#125;,1000*index) &#125;)(i);&#125;; 注： es6 中 let 可解决循环中变量问题]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Date]]></title>
    <url>%2F2017%2F02%2F06%2FDate%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 JS中的日期对象Date() 方法12345678910111213let time= new Date();console.log(time.getTime()) // 得到现在到1970的毫秒数console.log(time) // Sun Dec 04 2016 12:41:09 GMT+0800 (中国标准时间)console.log(time.getFullYear()) 2016console.log(time.getMonth()) 11[0-11]console.log(time.getDate()) 4console.log(time.getDay()) // 星期0-6console.log(time.getHours())console.log(time.getSeconds())console.log(time.getMinutes()) 常见使用写一个倒计时 123456789101112131415161718function time()&#123; let time = new Date(); let nowD = time.getTime(); // 当前 距离1970之间的毫秒差 let objTime = new Date('2016/12/4 16:51:34');// 考试时间 let objTimeM = objTime.getTime(); //考试 距离1970之间的毫秒差 let diff = objTimeM -nowD ; // 之间相差的毫秒数 let Mdiff = parseInt(diff/1000) ; // 转为秒 let Hdiff = parseInt(Mdiff/3600); // 小时 let endS = Mdiff%3600; //计算小时之后剩余的秒数 let MSdiff = parseInt(endS/60); // 计算有几个分钟 let endMS = endS%60; //计算分钟之后剩余的秒数 let show = ad(Hdiff) +':'+ad(MSdiff) +':'+ad(endMS) ; document.querySelector('#box').innerHTML = show;&#125;setInterval(time ,1000)]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>Date</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2017%2F02%2F06%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 使用indexOf12345678910function ary(arys)&#123; var newAry = []; for(var i=0;i&lt;arys.length;i++)&#123; if(newAry.indexOf(arys[i])==-1)&#123; newAry.push(arys[i]) &#125; &#125; return newAry;&#125;console.log(ary([2,3,2,2,6,6,7,8])) 利用对象12345678910111213var aryAry = [3,0,6,7,8,3,2,7];var obj=&#123;&#125;;for(var i=0;i&lt;aryAry.length;i++)&#123; var cur = aryAry[i] if(obj[cur])&#123; aryAry.splice(i,1); i--; &#125;else&#123; obj[cur] = cur; &#125;&#125;console.log(obj)console.log(aryAry) 注意那里，有一个i–; 如果不写，当删除之后，会发生数组塌陷。 这种方法消耗性能。因为一旦删除，数组索引发生变化 改进： 不使用splice 123456if(obj[cur])&#123; aryAry[i] = aryAry[aryAry.length-1] // 用最后一个位置的元素代替此位置 然后数组长度减一 aryAry.pop(); i--;&#125; 去重+排序12345678910var arys = [3,0,6,7,8,3,2,7]var obj=&#123;&#125;;for(var i=0;i&lt;arys.length;i++)&#123; obj[arys[i]] = arys[i];&#125;var newA =[]for(var key in obj)&#123; newA.push(key)&#125;document.write(newA) // 这种方法去重 并且 排序了 因为对象中的输出是按照数字大小来输出的。所以会改变原数组位置。 利用es612345var arr = [1, 1, 4, 50, 50, 6, 2, 2];function unique(arr)&#123; return Array.from(new Set(arr));&#125;document.write(unique(arr));]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dom操作系列3]]></title>
    <url>%2F2017%2F02%2F06%2FDom%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%973%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 创建元素12var ele = document.createElement('div')document.body.appendChild(ele) 插入元素2.1 放在元素末尾 appendChild 1document.body.appendChild(ele) 2.2 放在旧元素前面 insertBefore 12document.body.insertBefore(ele ,oldEle)oldEle.parentNode.insertBefore(ele,oldEle) 父级元素.insertBefore(新元素，旧元素) 克隆元素 cloneNode1oNode.cloneNode() 该方法有一个参数，可写可不写：true或者false 如果是true，表示全部克隆，包含所有子元素。 如果是false，表示只克隆目标元素自己 删除元素 removeChild1myBox.removeChild(wrongNode) 替换元素 replaceChild父级元素.replaceChild(新元素，旧元素) 1myBox.replaceChild(newNode,oldNode)]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dom操作系列2]]></title>
    <url>%2F2017%2F02%2F05%2FDom%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%972%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 获取某一个元素的所有子元素节点1.1 使用 obj.children 1.2 第一种方法不兼容IE,自己写一个 123456789101112function node(obj)&#123; var nodes = obj.childNodes ; var end =[]; for(var i=0;i&lt;nodes.length;i++)&#123; var item = nodes[i]; if(item.nodeType==1)&#123; end.push(item) &#125; &#125; return end;&#125;console.log(node(document.querySelector('#box'))) 获取某一个元素的上一个兄弟元素节点12345678function pre(obj)&#123; var preNode = obj.previousSibling; while(preNode&amp;&amp;preNode.nodeType!=1)&#123; preNode = preNode.previousSibling; &#125; return preNode;&#125;console.log(pre(document.querySelector('ul'))) attribute123obj.setAttribute(属性名,属性值)obj.getAttribute(属性名)obj.removeAttribute(属性名) 注意：setAttribute 不可设置class box.setAttribute(‘class’,’showing’) 是无效的 可以通过点加属性名来设置一个属性，这两种方法，怎么设置的就怎么获取。 注意，增加class属性只能通过点的形式 obj.seAttribute(‘class’)无效]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dom操作系列1]]></title>
    <url>%2F2017%2F02%2F05%2FDom%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%971%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 DOM : document object modal 文档对象模型 获取DOM元素的方法1.1 通过元素id 1document.getElementById('idName') 得到的是id名为idName的DOM元素 假使有重复的ID，那么这种方法获取的是第一个 标准浏览器区分id的大小写，但是IE6,7中不区分大小写 1.2 直接使用id名 idName 此方法可以使用但不推荐 1.3 通过元素标签名 1document.getElementsByTagName() 得到的是类数组 1.4 通过元素class名 1document.getElementsByClassName() 得到的是类数组 注意： DOM操作的是类数组中具体元素 1.5 通过name [只对于form表单而言] 1document.getElementsByName() 1.6 获取body 1document.body() 1.7 获取html 1document.documentElement() 1.7 1document.querySelector() 获取的是第一个元素 支持css选择器 ‘#idName’ ‘.className’ 标签等 1.7 1document.querySelectorAll() 获取的是一组元素 支持css选择器 ‘#idName’ ‘.className’ 标签等 获取可视窗口的信息2.1 宽度 clientWidth 高度 clientHeight 1let viewWidth = document.documentElement.clientWidth || document.body.clientWidth 获取相关节点节点包括 1 元素节点 2 文本节点[空格 标签 回车] 3 注释节点 4 document节点 nodeType 1 3 8 9 nodeName 大写的元素标签 #Text #comment #document nodeValue null 文本内容 注释内容 null 3.1 获取所有子节点 childNodes 1document.body.childNodes 3.2 获取所有子元素节点 children 1document.body.children 3.3 获取父级元素节点 parentNode 1document.body.parentNode 3.4 获取哥哥节点 previousSibling 可能会得到文本节点 1document.body.previousSibling 3.5 获取弟弟节点 nextSibling 可能会得到文本节点 1document.body.nextSibling 3.6 第一个子节点 firstChild 可能会得到文本节点 3.7 最后一个子节点 lastChild 可能会得到文本节点]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类型]]></title>
    <url>%2F2017%2F02%2F04%2FString%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 字符串12let str = 'I am string'console.log(str.length) // 输出字符串长度 一个字符占一个长度，空格也算的 字符串中方法2.1 charAt(索引数字) 通过索引找到该位置的字符 12let str = 'I am string'console.log(str.charAt(2)) //a 2.2 charCodeAt(索引数字) 通过索引找到该位置的字符对应的Unicode编码 12let str = 'I am string'console.log(str.charCodeAt(2)) //a 2.3 indexOf(‘a’) 找到字符第一次出现位置 返回索引 没有则返回-1 2.4 lastIndexOf(‘a’) 找到字符最后一次出现位置 返回索引 没有则返回-1 这两个方法完全兼容。 2.5 字符串的截取 2.5.1 str.substr(n,m) 从索引n开始 截取m个 2.5.2 str.substring(n,m) 从索引n开始 截取到m，不包括m 【包前不包后】 2.5.3 str.slice(n,m) 从索引n开始 截取到m，不包括m 【包前不包后】 但是slice和substring 不同在于,slice支持负数 console.log(str.slice(1,-5))2.6 转化大小写 toLowerCase toUpperCase 2.7 替换 replace.(旧字符,新字符) 这个方法不会修改原字符串 console.log(str.replace(‘I’ ,’who’))要想修改原字符串记得对原字符串重新赋值 2.7 分割为数组 split 12let str = 'I am string'console.log(str.split(' ')) //["I", "am", "string"] 2.7.1 str.split() // [原字符串] 12let str1 = 'hello'console.log(str1.split()) //["hello"] 2.7.1 str.split(‘’) //每一个字符都被分割 1234let str1 = 'hello'console.log(str1.split('')) //["h", "e", "l", "l", "o"]let str1 = 'hello'console.log(str1.split('m')) //["hello"] 如果分割字符不存在，返回原数组 2.8 match 捕获 返回字符的详细信息 1console.log(str.match('a')) //["a", index: 2, input: "I am string"] 2.9 search 同indexOf 返回字符所在位置索引 没有则返回-1 不过search可以写正则 es6新增 includes(), startsWith(), endsWith() includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // "" padStart() padEnd() 两个参数， 第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 练习获取四位不同字符当做验证码 借助字符串和Math 12345678910let str2 = 'qazwsxedcrfvtgbyhnujmikolpQAZWSXEDCRFVTGBYHNUJMIKOLP'let endStr2 ='';while(endStr2.length!=4)&#123; let cur = Math.round(Math.random()*51); // 获取随机数字 let theCode = str2.charAt(cur); // 获取索引对应的字符 if(endStr2.indexOf(theCode)==-1)&#123; // 判断字符是否已经存在于字符串 endStr2 += theCode; // 没有则拼接到字符串 &#125;&#125;console.log(endStr2)]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础练习题]]></title>
    <url>%2F2017%2F02%2F02%2Fjs%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 传入任意参数，求出其中被3和5整除的之和1234567891011let total =0;function add()&#123; for(let i=0;i&lt;arguments.length;i++)&#123; let cur = arguments[i]; if(cur%3==0 &amp;&amp; cur%5==0)&#123; total += cur; &#125; &#125; return total;&#125;document.querySelector('div').innerHTML = add(15,2,30); 十秒之内每秒返回一个不重复的四位随机数，每一位都在【0-60】123456789101112131415161718let n=0;getN ();function getN ()&#123; let str=''; while(str.length!=4)&#123; let cur = Math.round(Math.random()*(60)); if(str.indexOf(cur)==-1)&#123; str += cur; &#125; &#125; document.getElementsByTagName('div')[0].innerHTML= str+','+n; n++; clearTimeout(timer) if(n==10) &#123; return &#125; let timer = setTimeout(getN,1000)&#125; 输出一个四位不重复，从指定字符中选择。12345678910let str = 'qazwsxedcrfvtgbyhnujmiklop123456780'let end =''while(end.length!=4)&#123; let cur = Math.round(Math.random()*(str.length)) let code = str.charAt(cur) if(end.indexOf(cur)==-1)&#123; end+= code; &#125; document.getElementsByTagName('div')[0].innerHTML= end;&#125; 函数创建请创建一个函数 该函数参数值为一个整数 函数返回值为一个数字 该数字由整数中相同数字组成 但是该数字要比传入的参数值大 如果无法获取更大的数字 返回-1 123nextBigger(33) -&gt; -1nextBigger(123) -&gt; 213nextBigger(303) -&gt; 330 思路分析 将传入的参数转化为数组形式 该数组位数从左到右依次降低 以输入 2017为例 得到数组 [2,0,1,7] 则依次对应位置为 千分为 百分为 十位 个位 所以从右边开始依次与左边进行比较 一旦左侧数字小于右侧 两者进行位置交换 一旦数组中有发生一次位置交换 则停止遍历 输出此时的值 代码展示 1234567891011121314151617181920212223242526272829function nextBigger(num) &#123; if (num &lt; 10 || typeof num != 'number') &#123; // 小于10 各位数字 直接返回 -1 return -1 &#125; let originAry = String(num).split('') // [3, 3, 3] // 进行一次数组去重 let newAry = Array.from(new Set(originAry)) if (newAry.length === 1) &#123; // 如果数组去重之后长度为1 表示参数类型为多位相同值重复 return -1 &#125; // 从右到左依次判断 如果左侧大 则进行位置交换 只要发生一次位置交换 则可将数值返回 let i = originAry.length - 1 while (i &gt; 0) &#123; let right = originAry[i] let left = originAry[i - 1] if (right &gt; left) &#123; // 交换位置 originAry.splice(i - 1, 2, right, left) i = 0 break &#125; i-- &#125; let lastNum = Number(originAry.join('')) let endNum = num === lastNum ? -1 : lastNum return endNum&#125; 其实最开始的时候没有看清题目要求 我之间返回了进行重新排列之后最大的数字 代码展示 12345678910111213141516function nextBigger (num) &#123; if (num &lt; 10 || typeof num != 'number') &#123; // 小于10 各位数字 直接返回 -1 return -1 &#125; let originAry = String(num).split('').sort() // [3, 3, 3] // 进行一次数组去重 let newAry = Array.from(new Set(originAry)) if (newAry.length === 1) &#123; // 如果数组去重之后长度为1 表示参数类型为多位相同值重复 return -1 &#125; let lastNum = Number(originAry.reverse().join('')) let endNum = num === lastNum ? -1 : lastNum return endNum &#125; 数组的问题1let arr=[3,1,2,3,3,3,2,1,1,1,1,2] 要求输出 每个元素出现的次数 并且按照次数排序 处理方案 1234let ary = [12,12,2,2,3,4,5,6,6,88]let obj = &#123;&#125;ary.map( (item) =&gt; obj[item] = obj[item] ? obj[item] + 1 : 1 )conosle.log(obj) 变动题目为 1let arr=[3,1,2,3,3,3,2,1,1,1,1,2] 要求输出的 按照Value进行排序 【出现次数】 比如 1:5 3:4 2:3 解决思路 123456789101112let ary = [12,12,2,2,3,4,5,6,6,88,234,234,88,88,11]let obj = &#123;&#125;ary.map( (item) =&gt; obj[item] = obj[item] ? obj[item] + 1 : 1 )let newAry = Object.keys(obj)let endAry = []newAry.map((item) =&gt; &#123;let once = &#123;&#125;once[item] = obj[item]endAry.push(once)&#125;)let ans = endAry.sort((a,b) =&gt; Object.values(b)[0] - Object.values(a)[0])console.log(ans) 思路2 1234567891011121314let arys = [123,123,44,55,22,44,123,0]let shortAry = Array.from(new Set(arys))let endAry = []shortAry.map((item) =&gt; &#123;let obj = &#123;key: null, val: null&#125; // key 是谁出现 val 出现次数obj.key = itemwhile (arys.includes(item)) &#123;obj.val ++arys.splice(arys.indexOf(item), 1)&#125;endAry.push(obj)&#125;)endAry.sort((a, b) =&gt; b.val - a.val ) // 按照val 出现次数 进行排序console.log(endAry) 函数分析12345let x= 1;if((function f()&#123;&#125;)())&#123; x += typeof f&#125;console.log(x); 这个是输出1 因为if条件不成立 所以不执行代码 函数执行 没写return 返回值是undefined 在js中 条件为false的情况是 undefined null 0 ‘’ NaN false 统计字符串中出现最多的字符请封装一个函数，该函数的功能是： 1 传入任意字符串,统计该字符串中出现最多的字符并输出结果.不用考虑出现次数相同的字符。 123456// 比如function get(str)&#123; // 函数体内部代码&#125;var myStr = '5ssffflsjkssssmddnjkdkuuua6';console.log(get(myStr)) // 控制台输出: 字符出现次数最多的是s,出现次数为7 2 进阶版 传入任意字符串,统计该字符串中出现最多的字符并输出结果。并且考虑出现次数相同的字符。 123456// 比如function get(str)&#123; // 函数体内部代码&#125;var myStr = 'wwwdddcccvvvnklkopl';console.log(get(myStr)) // 控制台输出: 字符出现次数最多的是w,d,c,v,出现次数全部为3 基础版思路分析 1 思路1 利用对象A 基础版A1 创建空对象 循环字符串 将字符串保存为属性名 出现次数为属性值，重复出现次数加1A2 创建新数组 for in循环对象 将每一个属性值存入数组A3 利用Math 查找数组中最大值保存为max -》 出现的最多次数数值A4 for in循环对象 当属性值==max 输出该属性名 -》 就是出现次数最多的字符 2 思路2 利用数组A 基础版A1 创建两个空数组：字符数组与数值数组，循环字符串将字符存入第一个数组 将字符出现次数存入第二个数组A2 利用Math查找次数数组中最大值并记录位置index -》 出现的最多次数数值A3 输出字符数组index位置处的字符 -》 就是出现次数最多的字符 3 思路3 利用正则的重复子项A1 将分开的相同字符写到一起。也就是利用sort重新排序。字符串转数组-》sort排序-》join重新拼接A2 利用重复子项查找字符出现次数以下代码为利用对象基础版 12345678910111213141516171819202122232425function getStr(str)&#123; var obj=&#123;&#125;; for(var i=0;i&lt;str.length;i++)&#123; var cur=str[i]; if(obj[cur])&#123; obj[cur]++; &#125;else&#123; obj[cur]=1; &#125; &#125; var ary=[]; for(var key in obj)&#123; ary.push(obj[key]) &#125; ary.sort(function(a,b)&#123; return a-b; &#125;) for(var key in obj)&#123; if(obj[key]==ary[ary.length-1])&#123; return "出现次数最多的字符是"+key+"共"+obj[key]+"次"; &#125; &#125;&#125;var str="2399llaaaaaa"console.log(getStr(str)); 以下代码为利用数组方式 1 基础版12345678910111213141516171819202122var str = 'aafabgbbcgcfffaaddd';function findMax(str)&#123; var endCode='', max=0,codeAry =[], codeNum=[]; /* 1 循环字符串 第一个数组 放入字符 第二个放入次数 这样两个数组之间形成映射关系 2 次数数组查找最大值 查找对应位置 index 3 根据index输出第一组对应位置的字符 */ for(var i=0;i&lt;str.length;i++)&#123; if(codeAry.indexOf(str[i])==-1)&#123; /* 字符不存在放入数组*/ codeAry.push(str[i]); codeNum[codeAry.indexOf(str[i])] = 1; // codeNum 对应位置字符次数 为1 &#125;else&#123; /* 字符存在 */ codeNum[codeAry.indexOf(str[i])] += 1; // codeNum 对应位置字符次数 +1 &#125; &#125; var max = Math.max.apply(Math,codeNum); // 找到最大数字 var cur = codeNum.indexOf(max);// max 在 codeNum 中出现的第一次的位置 endCode = codeAry[cur]; return '字符出现次数最多的是'+ endCode+',出现次数为'+max;&#125;console.log(findMax(str)); 2 进阶版 12345678910111213141516171819202122232425var str = 'bab233c33222aeeeacbbace';function findMax(str)&#123; var endCode='', max=0,codeAry =[], codeNum=[]; for(var i=0;i&lt;str.length;i++)&#123; if(codeAry.indexOf(str[i])==-1)&#123; /* 字符不存在放入数组*/ codeAry.push(str[i]); codeNum[codeAry.indexOf(str[i])] = 1; // codeNum 对应位置字符次数 为1 &#125;else&#123; /* 字符存在 */ codeNum[codeAry.indexOf(str[i])] += 1; // codeNum 对应位置字符次数 +1 &#125; &#125; var max = Math.max.apply(Math,codeNum); // 找到最大数字 //cur = codeNum.indexOf(max);// max 在 codeNum 中出现的第一次的位置 while( codeNum.indexOf(max) != -1)&#123; var cur = codeNum.indexOf(max); endCode += codeAry[cur]; codeNum.splice(cur,1,'change');// max 在 codeNum 中出现的第一次的位置 使用新字符进行替换 // 注意这里不能删除 如果使用删除 会导致位置变化，两个数组之间映射关系会出错 &#125; return '字符出现次数最多的是'+ endCode+',出现次数为'+max;&#125;console.log(findMax(str)); 利用正则重复子项 123456789101112131415161718var str = 'aaCAcCDcDFF';function regFind(str)&#123; str = str.split('').sort(function(a,b)&#123;return a.localeCompare(b)&#125;).join(''); // console.log(str); 这里会得到一个重新排序后的按照各自顺序aaAccCCDDFF var reg = /(\w)\1+/gi ; // 利用重复子项 这里忽略大小写 var max=0,maxCode =''; str.replace(reg,function($0,$1)&#123; console.log(arguments);// ['aaA' 'a' 0 原字符串] 利用第一第二个参数 if($0.length&gt;max)&#123; max = $0.length; maxCode = $1; &#125;else&#123;// 最大值相同时 进行拼接 maxCode += $1; &#125; &#125;); return ('重复次数最高为 '+max+'，重复代码是'+maxCode);&#125;document.write(regFind(str));]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则基本知识]]></title>
    <url>%2F2017%2F01%2F22%2F%E6%AD%A3%E5%88%99%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[正则正则可以用来检查某一个子串是否存在 或者将其进行查找 替换等操作 元字符正则元字符分为两种 基本元字符 修饰元字符 基本元字符 元字符 含义 \ 转义 或者 \n 换行符 . 除了换行之外的任意字符 \b 开头 结尾 空格 \B 非 开头 结尾 空格 ^ 开始 $ 结尾 \S 非空格 \d 数字 \D 非数字 \w 数字字母下划线 \W 非数字字母下划线 [abc] a b c三者中任何一个 [a-z] a到z {n} n个 {n,} 大于n个 {n,m} n到m个 量词元字符 元字符 含义 ? 可有可无 + 1个或者多个 * 0个或者多个 修饰元字符 元字符 含义 g 全局查找 i 忽略大小写 m 换行 创建正则字面量1let reg = /\d+/ new 一个实例1let reg = new RegExp('\d+', 'g') 实例创建的时候,传入两个参数,第一个是你本来要在两个反斜杠之间的内容, 所以有时候需要转义。第二个参数是修饰符 实例创建可以进行变量拼接 1let reg = new RegExp(`new$&#123;arg&#125;\d`, 'g') 正则的方法test 验证字符串是否正则规则123let reg = /^\d$/let end = reg.test('6')console.log(end) // true 方法 返回值 test 布尔值 exec 捕获123let reg = /\w&#123;2&#125;/let end = reg.exec('d3fe')console.log(end) // ["d3", index: 0, input: "d3fe"] 返回值为数组: 负责大正则的内容 内容下标 原始字符串 如果正则表达式中有小分组 就是() 这种的 exec 还可以将小分组的内容进行捕获 并且返回到数组第二项 方法 返回值 exec 数组 正则的属性lastIndex表示下一次正则开始查找的索引 可以一个影响此属性变动的是test与exec 如果不使用全局搜索 每次lastIndex 将会是0 如果添加全局g 则lastIndex会发生变化 1234567891011let reg = /\d+/reg.test('love2017')console.log(reg.lastIndex) // 0reg.test('love2017')console.log(reg.lastIndex) // 0// 添加全局查找glet reg2 = /[0-3]/greg2.exec('love2017and2018') // ['2', index: 4 ]console.log(reg2.lastIndex) // 5reg2.exec('love2017and2018') // ['0', index: 5 ]console.log(reg2.lastIndex) // 6 支持正则的字符串常用的方法match在没有全局修饰符g时 进行一次查找，返回值为和exec一样的数组 正则加上全局g 进行多次查找 返回值为符合大正则的内容 12345let reg = /4|6/;let reg2 =/4|6/g;let str ='5624'; console.log(str.match(reg));//["6", index: 1, input: "5624"]console.log(str.match(reg2));// ['4','6'] 关于是否能找到小分组中内容 在没有全局修饰符g时 可以找到小分组内容 返回值为和exec一样的数组，就是从第二项开始为小分组 正则加上全局g 只能捕获匹配大正则的内容 无法捕获小分组 match 与 exec 1 没有全局g 的时候 match 与exec 都能得到分组信息 2 有全局g的时候 exec 能得到分组信息 match 只能返回符合大正则的内容 replacereplace 两个参数 第一个可以是字符也可以是正则 第二个可以是字符也可以是匿名函数 123let reg = /\d&#123;2&#125;/; // 两个数字let str ='45ggh78yue9';str.replace(reg,'数字'); // 第二个参数是字符 匿名函数接受的参数arguments 和 exec一模一样 匿名函数被调用的次数取决于前面正则匹配成功的次数。当匹配成功,函数被调用一次 根据匿名函数的返回值return 进行替换 模板字符串模拟 1234567let str ='i am &#123;0&#125; , i come from &#123;1&#125; , i like &#123;2&#125;'let words =['mxx' ,'china','js']str = str.replace(/&#123;(\d+)&#125;/g , function () &#123; // arguments[0] &#123;0&#125; 0 return words[arguments[1]];&#125;);document.write(str); // i am mxx , i come from china , i like js 特殊符号含义 字符 含义 $1 $2 …$99 表示与正则表达式中的第1-99个子表达式相匹配的文本 $&amp; 与正则表达式相匹配的子字符串 $`(反单引号) 位于匹配子字符串左侧的文本 $’(单引号) 位于匹配子字符串右侧的文本 searchsplitother[] 中括号里面特殊符号没有特殊含义 不会出现两位数 ?1 可有可无 2 在小分组前加 ?: 表示只匹配不捕获 3 关于拿到小分组中内容 由于test exec在全局g的时候会对lastIndex产生影响 所以如果使用的全局搜索需要注意 有可能拿到的是null 比如 1234let reg= /^aplha\(opacity[=:](\d+)\)/gi; // 获取 在IE 678中的opacity值if(reg.test(str))&#123; val = reg.exec(str)[1]; // 这么写出问题 因为在全局搜索下 str.lastIndex此时已经到末尾了&#125; 解决方案 1 不使用全局搜索g 1let reg= /^aplha\(opacity[=:](\d+)\)/i; 2 使用RegExp.$1 这个是构造函数RegExp属性 用来拿到小分组中内容 最多能拿到九个小分组 RegExp.$9 这个会在调用test或者exec方法时 自动进行填充 123if(reg.test(str))&#123; val = RegExp.$1; &#125; 正则知识补充1 只匹配不进行捕获 ?:如果只是对内容进行匹配，但是不想在小分组中拿到该值 可以使用只匹配不捕获 比如，在查找歌词 12let reg = /\[(\d+)&amp;#58;(\d+)&amp;#46;(?:\d+)\]([^$#]+)(?:&amp;#10;)/g;// [00&amp;#58;30&amp;#46;70]穿华丽的服装&amp;#32;为原始的渴望而站着&amp;#10; 这样只拿到 分钟 秒数 文字内容 2 处理贪婪性 正则表达式是贪婪的 会匹配最多 在修饰匹配次数的特殊符号后再加上一个 “?” 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 “不匹配”。这种匹配原则叫作 “非贪婪” 模式， es6 具名组匹配 123456const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 “具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 1234const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;const matchObj = RE_OPT_A.exec('');matchObj.groups.as // undefined]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>练习</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3D魔方旋转]]></title>
    <url>%2F2017%2F01%2F19%2F3D%E9%AD%94%E6%96%B9%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 3D魔方旋转效果是在移动端设备上基于touch事件写的一个滑动旋转效果 在线效果展示 【建议在移动端访问】 有背景音乐 请注意减少音量 1 html部分结构 一个魔方盒子里面有六个面 使用ul li 即可 2 CSS核心部分 对于魔方盒子ul 需要设置一个透视效果 -webkit-transform-style:preserve-3d;transform-style:preserve-3d;然后就是六个面的移动 初始状态 利用定位将其重叠在一起 移动规则 z 轴 正方向 移动Z轴 负方向 移动 Y轴旋转180X轴 正方向 移动 Y轴旋转90X轴 负方向 移动 Y轴旋转90Y轴 正方向 移动 X轴旋转90Y轴 负方向 移动 X轴旋转90 123456789101112131415161718192021222324252627282930/* Z方向向前 */li:nth-child(1) &#123; -webkit-transform: translateZ(2.55rem); transform: translateZ(2.55rem);&#125;/* Z 向后 Y轴旋转90deg */li:nth-child(2) &#123; -webkit-transform: translateZ(@box-S) rotateY(180deg); transform: translateZ(@box-S) rotateY(180deg);&#125;/* X 负方向 移动 Y轴旋转 90*/li:nth-child(3) &#123; -webkit-transform: translateX(@box-S) rotateY(-90deg); transform: translateX(@box-S) rotateY(-90deg);&#125;/* X 正方向 移动 Y轴旋转 90*/li:nth-child(4) &#123; -webkit-transform: translateX(@boxS) rotateY(90deg); transform: translateX(@boxS) rotateY(90deg);&#125;/* Y 正方向 移动 X轴旋转 90*/li:nth-child(5) &#123; -webkit-transform: translateY(@boxS) rotateX(-90deg); transform: translateY(@boxS) rotateX(-90deg);&#125;/* Y 负方向 移动 X轴旋转 90*/li:nth-child(6) &#123; -webkit-transform: translateY(@box-S) rotateX(90deg); transform: translateY(@box-S) rotateX(90deg);&#125; 这样进行魔方每一个面的拼接后 需要将魔方盒子进行角度旋转 才能看到立体效果 12-webkit-transform: scale(0.6) rotateX(30deg) rotateY(-45deg);transform: scale(0.6) rotateX(30deg) rotateY(-45deg); 核心CSS代码 3 JS部分 主要思路 就是在手指接触到屏幕 记录手指位置 开始移动 更新位置 释放 计算位置变化 根据魔方盒子的位置变化 按照一定比例 进行旋转 这里需要注意 获取的属性值是字符串 需要转为数字判断元素是否移动 有一个10px 的误差考虑 也就是变化位置差值在10px之内的 不算移动根据移动变化旋转的时候 方向需要注意 X轴是加 Y轴是减 核心JS代码展示 音频播放部分JS代码 音频播放部分有一个CSS旋转效果 是通过动画来做的 客户端存储Web 允许使用浏览器API将数据存储在用户电脑上。比如，可以记住用户偏好甚至是状态信息，可以回忆起用户上一次的访问位置 客户端存储遵循“同源策略”，所以在不同站点之间是无法互相读取数据的。但是在同一站点的不同页面之间，是可以进行存储数据共享 客户端存储一般常用有 1 Web存储 2 cookie 关于存储 安全和隐私Web浏览器通常会提供“记住密码”功能，这些密码会以加密的形式安全的存在硬盘中。但是，本文章介绍的任何形式的客户端数据存储不涉及加密。因此，任何形式的客户端存储不应该用来保存密码等 3 localStorage 和 sessionStorage 能够实现web存储的浏览器在window对象上定义了两个属性 localStorage 和 sessionStorage 。这两个属性都代表一个Storage对象—一个关联数组 数组值为字符串形式 3.1 localStorage 和 sessionStorage 两者区别就在于 存储的有效期和作用域的不同，也就是数据可以保存多久以及谁拥有数据的访问权 localStorage 的存储有效期和作用域 有效期 localStorage 的有效期是永久性的 除非web应用可以删除数据 或者用户通过设置浏览器配置 来删除 否则一直保存在用户电脑 不会过期 作用域 localStorage的 作用域是限制在文档源级别 只用同源的文档间可以互相读取甚至进行数据覆盖 sessionStorage 的存储有效期和作用域 有效期 通过sessionStorage 的有效期和存储数据的脚本所在的最顶层的窗口 或者是浏览器标签页 一旦关闭窗口页面 数据被删除销毁 作用域 sessionStorage 限制在文档源级别 而且限制在窗口中 只用同源的文档并且是同一个标签页间才可以互相读取 不同的标签页 即使渲染的是同一个页面 也无法进行sessionStorage 数据的共享 存储APIlocalStorage 和 sessionStorage 通常被当做普通的js对象使用 通过设置属性来存储字符串值 查询该属性来读取该值 存储 setItem(attr,val) 读取 getItem(attr) 删除 removeItem(attr) 清除全部 clear() 123456localStorage.setItem('age',20);for (var i = 0; i &lt; localStorage.length; i++) &#123; var name = localStorage.key(i); console.log(localStorage.getItem[name])&#125;localStorage.removeItem('age'); 存储事件当存储数据发生变化的时候 浏览器会在其他对于该数据可见的窗口对象触发存储事件，但是对数据进行变化的窗口不会触发 如果浏览器打开了两个来自同源的页面 其中一个页面在localStorage存储了数据 则另一个会触发存储事件 只有存储数据发生了真正变化 才会触发存储事件 如果是将已存在的存储项设置一个一模一样的值 或者删除一个原本就不存在的存储项 是不会触发存储事件的]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则练习]]></title>
    <url>%2F2017%2F01%2F14%2F%E6%AD%A3%E5%88%99%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[笔记迁移系列，由于原始笔记所在网站即将下线，现将笔记全部迁移，并对原有笔记进行修正或添加 统计出现次数最多的单词(可能是多个)，及出现多少次1234567891011121314let str8 = 'aaa22v2vvDDDad';str8= str8.split('').sort(function(a,b)&#123;return a.localeCompare(b)&#125;).join('');let max=0,maxCode='';str8.replace(/(.)\1+/gi, function ($1,$2) &#123; // 注意这里的正则忽略大小写 // arguments [aaa , a ,index ,input] if(max&lt;$1.length)&#123; max = $1.length; maxCode = $2; &#125;else if(max==$1.length)&#123; maxCode += $2; &#125;&#125;)console.log('统计出现次数最多的单词',str8,max,maxCode); 获取地址栏中的参数1234567let str9='http://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2'let reg9=/(([^?&amp;=]+)=([^?&amp;=]+))/g;let got =&#123;&#125;;str9.replace(reg9, function ($1,$2,$3) &#123; got[$2] = $3;&#125;)console.log('获取地址栏中的参数',got) 检测数据类型是不是预期的类型123456function isType(val,type)&#123; var realType = Object.prototype.toString.call(val); var reg = new RegExp('^\\[object '+type+'\\]$','i'); // 注意这里转义两次 return reg.test(realType);&#125; 注意那里是进行了两次转义 因为挨着\ 的那个被认为是字符串 最前面的\ 就是将后面那个\变为转义符 然后后面那个转义符进行真正的转义 假设一个数字是22223333，怎么把他用空格隔开成2222 3333，直接用js方法在第4位后加空格123456var str ='22223333444455556666';var reg = /\d&#123;4&#125;/g;str = str.replace(reg, function ($0) &#123; return $0+=',';&#125;);console.log(str); 编写trim 去掉字符串首尾空格1234567var str = ' what is you name? ';String.prototype.trim = function () &#123; var reg = /(^\s+)|(\s+$)/g; var str=null; str=this.replace(reg,'') return str;&#125;; 利用正则进行汉字去重12345678910111213var strC ='今夕何夕今夕何夕今夕何夕';String.prototype.removeSame= function () &#123; var str= this.split('').sort(function (a,b) &#123; return a.localeCompare(b); &#125;).join(''); var reg = /([\u4e00-\u9fa5])\1+/g; var end = []; str.replace(reg, function ($0,$1) &#123; end.push($1); &#125;); return end.join('');&#125;;console.log(strC.removeSame()); 使用了正则中的重复子项]]></content>
      <categories>
        <category>javascript基础</category>
      </categories>
      <tags>
        <tag>笔记迁移</tag>
        <tag>练习</tag>
        <tag>正则</tag>
      </tags>
  </entry>
</search>
